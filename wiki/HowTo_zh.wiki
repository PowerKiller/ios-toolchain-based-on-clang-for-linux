=新的基于clang的iOS toolchain=

Cjacker <cjacker@gmail.com> 2012-11-26

LLVM/clang的Linux版本提供了全面的Objective C 2.0支持，包括了blocks, ARC等高级特性。

Linux最早的iOS工具链是iphone 1刚发布时由iphonedev team开发的，使用的是gcc/binutils组合，提供对arm target的支持，后来有了基于llvm-gcc/odcctools的toolchain，但是也使用了clang作为预处理器来支持objc的高级特性，并且使用llvm-gcc作为Makefile的ld链接器。

其实clang/llvm作为一个完整的编译器实现，本身就可以完成所有的工作，而不再需要llvm-gcc等其他工具。当然，如果有些特殊代码需要，比如使用了gcc扩展的c/c++代码，你仍然可以通过llvm-gcc来构建出目标文件。

这里提供了一个完整的说明，一步一步的在Linux系统上构建一个基于clang的iOS工具链和开发环境。

实际上，iOS工具链跟其他的跨平台编译工具链一样，主要包含以下组件：

  # *汇编器和链接器*: 这里我们使用来自opendarwin的较新版本的cctools和ld64.
  # *编译器*: 这里我们使用clang
  # *目标文件系统*. 提供了开发库和头文件
  # *辅助工具*: 比如ldid签名工具


==第一步，准备环境==
一个较新的Linux发行版都应该可以工作的很好，你可能需要确定系统提供了gcc/g++或者llvm/clang，另外你需要xar和dmg2img工具。我一直使用自己维护的一个定制化系统gcc版本是4.7.1，clang版本是3.3svn，这些编译器都可以编译后面所提到的所有的工具代码。

*dmg2img* 可以从 http://vu1tur.eu.org/tools/ 下载

*xar* 可以从 https://code.google.com/p/xar/ 下载


==第二步，编译安装clang==
即将发布的clang/llvm 3.2以及svn版本应该都是可以的，llvm官方提供了一个怎么构建llvm/clang的说明：

http://llvm.org/docs/GettingStarted.html#checkout

写这个howto的时候（也就是1个小时前），我checkout的是168581 版本。

===1,从svn取得clang代码===
{{{
$cd where-you-want-llvm-to-live
$svn co http://llvm.org/svn/llvm-project/llvm/trunk llvm-svn -r 168581

$cd where-you-want-llvm-to-live
$cd llvm-svn/tools
$svn co http://llvm.org/svn/llvm-project/cfe/trunk clang -r 168581

$cd where-you-want-llvm-to-live
$cd llvm-svn/projects
$svn co http://llvm.org/svn/llvm-project/compiler-rt/trunk compiler-rt -r 168581
}}}

===2. 打补丁===

从这里下载补丁:

http://ios-toolchain-based-on-clang-for-linux.googlecode.com/files/clang-iphoneos-linker.patch

这个补丁修复了这个问题：
1, 根据IPHONE_DEPLOYMENT_TARGET的环境变量设置，clang会有不同的链接参数，如果我们把这个环境变量设置为4以上，那么，clang回去链接crt1.3.1.o，但是会有一个符号缺失，我们还需要在Makefile里手工链接dylib1.o，这个Patch的作用就是直接链接crt1.o。

{{{
$cd llvm-svn
$cat clang-iphoneos-linker.patch|patch -p1
}}}

===3. 编译安装. ===
{{{
$./configure --prefix=/usr  --enable-optimized
$make 
$make install
}}}

===4. 测试clang编译器===
clang会安装一个clang命令和clang++命令，分别是针对c/objc和c++/objc++的。
我们可以写一个简单的C语言Hello World来验证一下clang是否工作正常。

编译：
{{{
$clang -o hello hello.c
$clang++ -o hello hello.cpp
}}}


==第三步，安装汇编器和链接器==
saurik提供的toolchain.sh提供了cctools-782/ld64-85.2.1版本。这里提供的是一个更新的cctools版本，并且完成了x86_64的移植，且可以直接通过gcc或者clang编译。

opendarwin代码移植的过程有一点点复杂，就不讲了，这里提供了一个针对Linux的tar包下载: http://ios-toolchain-based-on-clang-for-linux.googlecode.com/files/cctools-836-for-linux.tar.gz

直接下载编译就可以了。


如果你要用clang/clang++来编译，需要export以下环境变量。
{{{
$export CC=clang
$export CXX=clang++
}}}

*据报告32位系统clang/clang++编译cctools的时候会有一些问题，建议在32位系统使用gcc/g++编译*

{{{
$export CC=gcc
$export CXX=g++
}}}

然后就是配置编译过程:
{{{
$export CFLAGS=-fno-stack-protector
$export CXXFLAGS=-fno-stack-protector
$./configure --target=arm-apple-ios --prefix=/opt/ios/toolchain
$make
$make install
$cd /usr/bin
$ln -s /opt/ios/toolchain/bin/arm-apple-ios-* .
}}}

安装后，在 */opt/ios/toolchain/bin* 你会看到:

{{{
arm-apple-ios-ar               
arm-apple-ios-as
arm-apple-ios-ld                  
arm-apple-ios-codesign_allocate
….
}}}

之所以要将命令链接到/usr/bin目录，是为了让clang能够找到这些工具，以便在编译，链接时使用。

==第四步，通过iPhoneSDK建立cross compile文件系统==
你可以直接从这里下载预先生成的文件系统: http://ios-toolchain-based-on-clang-for-linux.googlecode.com/files/sys50.tar.xz

将它解压到 */opt/ios/"
{{{
$tar xvf sys50.tar.xz -C /opt/ios/
}}}

如果你要自己生成文件系统，请按照以下步骤进行：

===1. 从xcode-xxx.img中取得iPhoneSDk pkg===
在Mac下点击xcode.img会自动完成挂载，一般是 */Volumes/Xcode* ,在里面找到 find *iPhoneSDK5_0.pkg* 和 *iPhoneSimulatorSDK5_0.pkg*.

===2. 解出文件，修复头文件路径.===

{{{
#libraries and headers.
mkdir -p /opt/ios/sys
cd /opt/ios/sys
xar -xf iPhoneSDK5_0.pkg Payload; cat Payload | zcat | cpio -id
mv Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS5.0.sdk .
rm -fr Platforms

cp -R -pf iPhoneOS5.0.sdk/System /opt/ios/sys
cp -R -pf iPhoneOS5.0.sdk/usr /opt/ios/sys

cd iPhoneOS5.0.sdk/System/Library/Frameworks
for i in *.framework
do
     f=`basename $i .framework`
     echo $f
     mkdir -p opt/ios/sys/usr/include/$f
     if [ -d $i/Headers ]; then
     cp -Rf -p $i/Headers/* /opt/ios/sys/usr/include/$f/
     fi
done
cd -
rm -rf Payload
rm -rf iPhoneOS5.0.sdk
}}}

{{{
#IOKit headers from iPhoneSimulatorSDK5_0.pkg, for older version, just skip it.
xar -xf iPhoneSimulatorSDK5_0.pkg Payload; cat Payload | zcat | cpio -id
mv Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator5.0.sdk .
rm -rf Platforms
mkdir -p /opt/ios/sys/usr/include/IOKit
cp -Rf -p iPhoneSimulator5.0.sdk/System/Library/Frameworks/IOKit.framework/Headers/* /opt/ios/sys/usr/include/IOKit/
rm -rf Payload
rm -rf iPhoneSimulator5.0.sdk
}}}


现在我们已经有了一个可供crosscompile的filesystem。

如果你需要使用ARC(Auto Reference Counting), 你需要将libarclite_iphoneos.a这个静态库加入文件系统，这个文件来自xcode，可以在这里下载：
http://ios-toolchain-based-on-clang-for-linux.googlecode.com/files/libarclite_iphoneos.a.tar.gz

然后解压：
{{{
mkdir -p /opt/ios/sys/usr/lib/arc/
tar zxvf libarclite_iphoneos.a.tar.gz -C /opt/ios/sys/usr/lib/arc/
}}}

编译代码时，给编译器加上'-fobjc-arc'就可以打开ARC支持了。


==第五步，安装ldid代码签名工具==
ldid是saurik做的一个代码签名工具，如果编译出来的目标代码不签名，在iOS上是不能运行的。 

这里提供了一个修改过的版本，可以支持clang/cctools生成的Mach-O armv7 二进制的签名

从这里下载：http://ios-toolchain-based-on-clang-for-linux.googlecode.com/files/ldid-1.0.610-modified.tar.gz

编译安装：
{{{	
$make
$install -m 0755 util/ldid /opt/ios/toolchain/bin
}}}

如果你要使用clang++来编译，需要下面这个补丁：
{{{
diff -Nur ldid-1.0.610/util/ldid.cpp ldid-1.0.610new/util/ldid.cpp
--- ldid-1.0.610/util/ldid.cpp  2012-11-25 20:34:24.247450779 +0800
+++ ldid-1.0.610new/util/ldid.cpp   2012-11-25 20:34:39.624454277 +0800
@@ -38,9 +38,10 @@
 #include "minimal/stdlib.h"
 #include "minimal/string.h"
 #include "minimal/mapping.h"
-
+extern "C"
+{
 #include "sha1.h"
-
+}
 #include <cstring>
 #include <string>
 #include <vector>
}}}


==第六步，设置环境变量==
现在我们已经有了编译器，汇编器和链接器以及iOS 文件系统。

||/opt/ios/toolchain/bin/||Assembler and Linker.||
||/opt/ios/sys/||IOS crosscompile libraries and headers.||
||/opt/ios/toolchain/bin/ldid|| ldid codesign utility||

我们需要设置一些环境变量来方便的使用它们，你可以将下面的代码加进~/.bashrc，或在/etc/profile.d下面建一个ios-toolchain.sh，把代码贴进去。

{{{

export IPHONEOS_TOOLCHAIN_PATH="/opt/ios/toolchain/bin"
export IPHONEOS_FS="/opt/ios/sys"
export PATH=$PATH:$IPHONE_TOOLCHAIN_PATH
#this var only affect llvm/clang link flags.
#it will links to crt1.3.1.o if we set it to 4.2 and above
#and we need add -ldylib1.o to LDFLAGS.
#after llvm/clang patched, this problem already fixed.
export IPHONEOS_DEPLOYMENT_TARGET=5.0
export CODESIGN_ALLOCATE=$IPHONEOS_TOOLCHAIN_PATH/arm-apple-ios-codesign_allocate

}}}


==第七步，创建ios-clang/ios-clang++脚本==
使用clang编译器来编译针对iOS的代码时，我们需要加一些额外的参数：

*--target arm-apple-ios* ：告诉clang目标架构是arm-apple-ios，这样clang能够找到<target>-ld等命令。

*--isysroot /opt/ios/sys* ：告诉clang使用/opt/ios/sys作为根文件系统来寻找开发库和头文件。

我们创建了两个脚本来自动添加这些参数。

*ios-clang*
{{{
#!/bin/bash
clang -target arm-apple-ios -isysroot $IPHONEOS_FS $@
}}}

*ios-clang++*
{{{
#!/bin/bash
clang++ -target arm-apple-ios -isysroot $IPHONEOS_FS $@
}}}

把这两个脚本放到 */opt/ios/toolchain/bin* 。


*注意* ：如果你使用了 iOS 4.2 文件系统，你还需要加上 *-arch armv6* 参数，否则ldid会签名失败。


==第八步，越狱你的设备==
下载合适的越狱工具越狱你的设备，然后通过cyndia安装openssh并测试ssh连接。

*注意* ： 默认的密码是*alpine*。


==第九步，测试工具链==
===1. 写一个简单的objc hello world.===

helloworld.m
{{{
#import <Foundation/Foundation.h>

int main(int argc, const char **argv)
{
    NSLog(@"Hello World");
    return 0;
}
}}}

===2. 编译===
{{{
$ios-clang -o helloworld helloworld.m -framework Foundation
}}}

*注意* ： 如果你 *没有* 给llvm-svn打patch，可能需要加上-ldylib1.o。

===3. 签名===
{{{
$ldid -S helloworld
}}}

===4. 上传到你的设备并运行===
使用scp上传helloworld二进制到你的设备，然后ssh进你的设备运行它。


==第十步，测试iOS app==
从这里下载helloworld.tar.gz:
http://ios-toolchain-based-on-clang-for-linux.googlecode.com/files/helloworld.tar.gz

解压/编译/安装到你的设备，你可能需要修改一下Makefile，把里面的IPHONE_IP设置为你真实的IP。

{{{
$tar zxvf helloworld.tar.gz 
$cd helloworld
$make
$make dist
$make install
}}}

下载里还有一个UICatalog.tar.gz，也可以尝试一下。

==第十一步，API文档==
从这里下载iOS的API文档：
http://devimages.apple.com/docsets/20120109/com.apple.adc.documentation.AppleiOS5_0.iOSLibrary.xar

解压：
{{{
xar -xf com.apple.adc.documentation.AppleiOS5_0.iOSLibrary.xar
cd com.*iOSLibrary.docset/Contents/Resources/Documents/
firefox ./index.html
}}}


==最后，开始吧==
 