diff -Nur cctools-855-ld64-236.3/ar/archive.c ../cctools-port.bak/cctools/ar/archive.c
--- cctools-855-ld64-236.3/ar/archive.c	2014-06-30 02:37:05.669089468 +0800
+++ ../cctools-port.bak/cctools/ar/archive.c	2014-06-30 02:06:45.584154528 +0800
@@ -340,21 +340,21 @@
 			(void)sprintf(hb, HDR3, name, (long int)tv_sec,
 			    (unsigned int)(u_short)sb->st_uid,
 			    (unsigned int)(u_short)sb->st_gid,
-			    sb->st_mode, sb->st_size, ARFMAG);
+			    sb->st_mode, (int64_t)sb->st_size, ARFMAG);
 			lname = 0;
 		} else if (lname > sizeof(hdr->ar_name) || strchr(name, ' '))
 			(void)sprintf(hb, HDR1, AR_EFMT1, (lname + 3) & ~3,
 			    (long int)tv_sec,
 			    (unsigned int)(u_short)sb->st_uid,
 			    (unsigned int)(u_short)sb->st_gid,
-			    sb->st_mode, sb->st_size + ((lname + 3) & ~3),
+			    sb->st_mode, (int64_t)sb->st_size + (int64_t)((lname + 3) & ~3),
 			    ARFMAG);
 		else {
 			lname = 0;
 			(void)sprintf(hb, HDR2, name, (long int)tv_sec,
 			    (unsigned int)(u_short)sb->st_uid,
 			    (unsigned int)(u_short)sb->st_gid,
-			    sb->st_mode, sb->st_size, ARFMAG);
+			    sb->st_mode, (int64_t)sb->st_size, ARFMAG);
 		}
 		size = sb->st_size;
 	} else {
diff -Nur cctools-855-ld64-236.3/ar/contents.c ../cctools-port.bak/cctools/ar/contents.c
--- cctools-855-ld64-236.3/ar/contents.c	2014-06-30 02:37:05.392089478 +0800
+++ ../cctools-port.bak/cctools/ar/contents.c	2014-06-30 02:06:45.584154528 +0800
@@ -2,14 +2,14 @@
  * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
  *
  * @APPLE_LICENSE_HEADER_START@
- * 
+ *
  * This file contains Original Code and/or Modifications of Original Code
  * as defined in and that are subject to the Apple Public Source License
  * Version 2.0 (the 'License'). You may not use this file except in
  * compliance with the License. Please obtain a copy of the License at
  * http://www.opensource.apple.com/apsl/ and read it before using this
  * file.
- * 
+ *
  * The Original Code and all software distributed under the License are
  * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
  * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
@@ -17,7 +17,7 @@
  * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
  * Please see the License for the specific language governing rights and
  * limitations under the License.
- * 
+ *
  * @APPLE_LICENSE_HEADER_END@
  */
 /*	$OpenBSD: contents.c,v 1.2 1996/06/26 05:31:19 deraadt Exp $	*/
@@ -81,6 +81,10 @@
 #include "archive.h"
 #include "extern.h"
 
+#ifndef HAVE_STRMODE
+extern void strmode(int mode, char *p);
+#endif
+
 /*
  * contents --
  *	Handles t[v] option - opens the archive and then reads headers,
@@ -93,7 +97,7 @@
 	int afd, all;
 	struct tm *tp;
 	char *file, buf[25];
-	
+
 	afd = open_archive(O_RDONLY);
 
 	for (all = !*argv; get_arobj(afd);) {
@@ -113,7 +117,7 @@
 		if (!all && !*argv)
 			break;
 next:		skip_arobj(afd);
-	} 
+	}
 	close_archive(afd);
 
 	if (*argv) {
diff -Nur cctools-855-ld64-236.3/as/driver.c ../cctools-port.bak/cctools/as/driver.c
--- cctools-855-ld64-236.3/as/driver.c	2014-06-30 02:37:04.987089492 +0800
+++ ../cctools-port.bak/cctools/as/driver.c	2014-06-30 02:06:45.554154529 +0800
@@ -61,7 +61,7 @@
 	    _NSGetExecutablePath(p, &bufsize);
 	}
 	prefix = realpath(p, resolved_name);
-	if(realpath == NULL)
+	if(prefix == NULL)
 	    system_fatal("realpath(3) for %s failed", p);
 	p = rindex(prefix, '/');
 	if(p != NULL)
diff -Nur cctools-855-ld64-236.3/as/dwarf2dbg.c ../cctools-port.bak/cctools/as/dwarf2dbg.c
--- cctools-855-ld64-236.3/as/dwarf2dbg.c	2014-06-30 02:37:04.962089493 +0800
+++ ../cctools-port.bak/cctools/as/dwarf2dbg.c	2014-06-30 02:06:45.553154529 +0800
@@ -421,7 +421,7 @@
     *line = current;
 }
 
-/* A hook to allow the target backend to inform the line number state 
+/* A hook to allow the target backend to inform the line number state
    machine of isa changes when assembler debug info is enabled.  */
 
 void
@@ -1682,9 +1682,9 @@
   section_set(ranges_section);
 
   /* Base Address Entry.  */
-  for (i = 0; i < addr_size; i++) 
+  for (i = 0; i < addr_size; i++)
     out_byte (0xff);
-  for (i = 0; i < addr_size; i++) 
+  for (i = 0; i < addr_size; i++)
     out_byte (0);
 
   /* Range List Entry.  */
@@ -1715,9 +1715,9 @@
     }
 
   /* End of Range Entry.   */
-  for (i = 0; i < addr_size; i++) 
+  for (i = 0; i < addr_size; i++)
     out_byte (0);
-  for (i = 0; i < addr_size; i++) 
+  for (i = 0; i < addr_size; i++)
     out_byte (0);
 }
 
@@ -2002,7 +2002,7 @@
 #ifdef OLD
   comp_dir = getpwd ();
 #else
-  comp_dir = getwd(xmalloc(MAXPATHLEN + 1));
+  comp_dir = getcwd(xmalloc(MAXPATHLEN + 1), MAXPATHLEN + 1);
 #endif
   len = strlen (comp_dir) + 1;
   p = frag_more (len);
@@ -2207,7 +2207,7 @@
 #endif
 
       assert (all_segs);
-  
+
 #ifdef OLD
       info_seg = subseg_new (".debug_info", 0);
       abbrev_seg = subseg_new (".debug_abbrev", 0);
@@ -2245,7 +2245,7 @@
 	{
 #ifdef OLD
 	  ranges_seg = subseg_new (".debug_ranges", 0);
-	  bfd_set_section_flags (stdoutput, ranges_seg, 
+	  bfd_set_section_flags (stdoutput, ranges_seg,
 				 SEC_READONLY | SEC_DEBUGGING);
 	  record_alignment (ranges_seg, ffs (2 * sizeof_address) - 1);
 	  out_debug_ranges (ranges_seg);
diff -Nur cctools-855-ld64-236.3/as/input-scrub.c ../cctools-port.bak/cctools/as/input-scrub.c
--- cctools-855-ld64-236.3/as/input-scrub.c	2014-06-30 02:37:04.974089493 +0800
+++ ../cctools-port.bak/cctools/as/input-scrub.c	2014-06-30 02:06:45.553154529 +0800
@@ -198,7 +198,7 @@
       if (p <= buffer_start + BEFORE_SIZE)
 	{
 	  int new;
-	
+
 	  new = limit - (buffer_start + BEFORE_SIZE + partial_size);
 	  partial_size += new;
 
@@ -326,7 +326,7 @@
   *line_ret = 0;
   if (physical_input_file)
     {				/* we tried to read SOME source */
-      *file_ret = logical_input_file ? 
+      *file_ret = logical_input_file ?
 		  logical_input_file : physical_input_file;
       if (input_file_is_open())
 	{			/* we can still read lines from source */
@@ -350,7 +350,7 @@
     char *p, *q;
     static char directory_buf[MAXPATHLEN];
 
-	getwd(directory_buf);
+	getcwd(directory_buf, sizeof(directory_buf));
 	*fileName = NULL;
 	*directory = directory_buf;
 	*line = 0;
@@ -384,13 +384,15 @@
   fprintf (stderr,"as:file(%s) %s! ",
 	   filename, gripe
 	   );
-  if (errno > sys_nerr)
+  int xerrno = errno;
+  char errbuf[64];
+  if (strerror_r (errno, errbuf, sizeof(errbuf)))
     {
-      fprintf (stderr, "Unknown error #%d.", errno);
+      fprintf (stderr, "Unknown error #%d.", xerrno);
     }
   else
     {
-      fprintf (stderr, "%s.", sys_errlist [errno]);
+      fprintf (stderr, "%s.", errbuf);
     }
   (void)putc('\n', stderr);
   errno = 0;			/* After reporting, clear it. */
diff -Nur cctools-855-ld64-236.3/as/obstack.c ../cctools-port.bak/cctools/as/obstack.c
--- cctools-855-ld64-236.3/as/obstack.c	2014-06-30 02:37:04.896089495 +0800
+++ ../cctools-port.bak/cctools/as/obstack.c	2014-06-30 02:06:45.550154529 +0800
@@ -16,6 +16,7 @@
 Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
 
 #include <stdlib.h>
+#include <stdint.h>
 #include "obstack.h"
 
 #ifdef __STDC__
diff -Nur cctools-855-ld64-236.3/as/read.c ../cctools-port.bak/cctools/as/read.c
--- cctools-855-ld64-236.3/as/read.c	2014-06-30 02:37:05.061089489 +0800
+++ ../cctools-port.bak/cctools/as/read.c	2014-06-30 02:06:45.556154529 +0800
@@ -103,7 +103,7 @@
   3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
   3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
   3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
-  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3 
+  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3
 };
 
 /*
@@ -142,7 +142,7 @@
 
 /*
  * The conditional assembly feature (.if, .else, .elseif and .endif) is
- * implemented with cond_state that tells us what we are in the middle of 
+ * implemented with cond_state that tells us what we are in the middle of
  * processing.  ignore can be either TRUE or FALSE.  When TRUE we are ignoring
  * the block of code in the middle of a conditional.  MAX_IF_DEPTH is the
  * maximum depth that if's can be nested.
@@ -202,7 +202,7 @@
 static void pseudo_op_begin(void);
 #ifdef PPC
 static void ppcasm_pseudo_op_begin(void);
-#endif 
+#endif
 static void stab(uintptr_t what);
 static char get_absolute_expression_and_terminator(int32_t *val_pointer);
 static char *demand_copy_string(int *lenP);
@@ -852,7 +852,7 @@
  *    		a full line comment (in the case of "well formed" assembly it
  *				     must be "#APP\n" of a collection of lines
  *				     wrapped in "#APP\n ... #NO_APP\n")
- * 
+ *
  * input:
  *	buffer		pointer to the start of the buffer of lines
  *			(passed as an argument)
@@ -1219,9 +1219,9 @@
  * The operand field can contain subfields separated by commas.  The number of
  * subfields is determined by the type of operation.  Spaces can appear
  * anywhere in the operand field except within a single symbol.
- * 
+ *
  * The comment field starts with a ; or a # .
- * 
+ *
  * input:
  *	buffer		pointer to the start of the buffer of lines
  *			(passed as an argument)
@@ -1560,7 +1560,7 @@
 	free(new_buf);
 
 	/*
-	 * After coming back from our recursive call parse_a_buffer() we want 
+	 * After coming back from our recursive call parse_a_buffer() we want
 	 * resume parsing after the "#NO_APP\n".  So bump the line counters
 	 * for the "#NO_APP\n" and restore the state so we can return to
 	 * parse_a_buffer().
@@ -1588,7 +1588,7 @@
 	while(is_end_of_line(*p) == FALSE)
 	    p++;
 	*p = '\0';
-	
+
 	as_fatal(".abort %s detected.  Assembly stopping.", input_line_pointer);
 }
 
@@ -1625,7 +1625,7 @@
  *  .p2alignl align_expression [ , 4byte_fill_expression [,max_bytes_to_fill]]
  *  .align32  align_expression [ , 4byte_fill_expression [,max_bytes_to_fill]]
  * Where align_expression is a power of 2 alignment.
- * 
+ *
  * The parameter fill_size can only be 1, 2 or 4 which is the size of the
  * fill_expression.  If the parameter bytes_p is non-zero the alignment value
  * is interpreted as the byte boundary, rather than the power of 2.
@@ -2503,7 +2503,7 @@
 	}
 	frcP = section_new(s->segname, s->sectname,
 			   s->flags & SECTION_TYPE,
-			   s->flags & SECTION_ATTRIBUTES, 
+			   s->flags & SECTION_ATTRIBUTES,
 			   s->sizeof_stub);
 	if(frcP->frch_section.align < s->default_align)
 	    frcP->frch_section.align = s->default_align;
@@ -3316,14 +3316,14 @@
 	    symbolP->sy_value = exp.X_add_number + exp.X_add_symbol->sy_value;
 	    symbolP->sy_frag  = exp.X_add_symbol->sy_frag;
 	    break;
-	  
+
 	case SEG_UNKNOWN:
 	    symbolP->sy_forward = exp.X_add_symbol;
 /* commented out by GNU */
 /* as_bad("unknown symbol"); */
 /* need_pass_2 = TRUE; */
 	    break;
-	  
+
 	default:
 	    BAD_CASE(segment);
 	    break;
@@ -3347,7 +3347,7 @@
  * This clobbers input_line_pointer, checks end-of-line.
  */
 void
-cons(	
+cons(
 uintptr_t nbytes) /* nbytes == 1 for .byte, 2 for .word, 4 for .long, 8 for .quad */
 {
     char c;
@@ -3370,7 +3370,7 @@
 	 */
 	if(nbytes >= (int)sizeof(signed_expr_t))
 	    mask = 0;
-	else 
+	else
 	    /* Don't store these bits. */
 	    mask = ~0ULL << (BITS_PER_CHAR * nbytes);
 	unmask = ~mask;		/* Do store these bits. */
@@ -3469,7 +3469,7 @@
 			0);
 		/*
 		 * If we have the special assembly time constant expression
-		 * of the difference of two symbols defined in the same section 
+		 * of the difference of two symbols defined in the same section
 		 * then divided by exactly 2 mark the fix to indicate this.
 		 */
 		fixP->fx_sectdiff_divide_by_two = exp.X_sectdiff_divide_by_two;
@@ -3793,7 +3793,7 @@
 #else
       symbolS *sym;
       expressionS *expression;
-  
+
       sym = symbol_temp_new(exp->X_add_symbol->sy_other /* GUESS */, 0, NULL);
       expression = xmalloc(sizeof(expressionS));
       *expression = *exp;
@@ -3883,7 +3883,7 @@
 
 /*
  * next_char_of_string() is used by stringer() and demand_copy_string() and
- * returns the next character from input_line_pointer that is in the string or 
+ * returns the next character from input_line_pointer that is in the string or
  * -1 for the trailing " character.  This routine handles escaped characters
  * like \b, \f, etc.
  */
@@ -4304,7 +4304,7 @@
 	demand_empty_rest_of_line();
 }
 
-/* 
+/*
  * totally_ignore_line() ignores lines during conditional assembly.
  */
 void
@@ -4793,7 +4793,7 @@
 /*
  * s_secure_log_unique() implements the pseudo op:
  *	.s_secure_log_unique log_msg
- * This opens the file given by the environment varable AS_SECURE_LOG_FILE, and 
+ * This opens the file given by the environment varable AS_SECURE_LOG_FILE, and
  * appends the current filename, line number, and the text given as the log_msg
  * in the directive.  If this is present, but AS_SECURE_LOG_FILE is not set,
  * an error message is generated.   If this appears twice without
@@ -4967,7 +4967,7 @@
 /* Special stuff to allow assembly of Sun assembler sources
    This unfortunatley needs to be here instead of sparc.c because it
    uses the hash tables defined here.
-   see also sparc.c for pseudo_table entries 
+   see also sparc.c for pseudo_table entries
 */
 
 /* Handle the SUN sparc assembler .seg directive. .seg should only occur with
@@ -5016,7 +5016,7 @@
 
 #ifdef PPC
 /*
- * 
+ *
  */
 /*
  * s_ppcasm_end() implements the ppcasm pseudo op:
diff -Nur cctools-855-ld64-236.3/as/sections.c ../cctools-port.bak/cctools/as/sections.c
--- cctools-855-ld64-236.3/as/sections.c	2014-06-30 02:37:04.973089493 +0800
+++ ../cctools-port.bak/cctools/as/sections.c	2014-06-30 02:06:45.553154529 +0800
@@ -25,6 +25,7 @@
  */
 #include <stdlib.h>
 #include <strings.h>
+#include <string.h>
 #include "sections.h"
 #include "obstack.h"
 #include "xmalloc.h"
diff -Nur cctools-855-ld64-236.3/configure.ac ../cctools-port.bak/cctools/configure.ac
--- cctools-855-ld64-236.3/configure.ac	2014-06-30 01:51:55.000000000 +0800
+++ ../cctools-port.bak/cctools/configure.ac	2014-06-30 02:06:45.572154528 +0800
@@ -9,9 +9,19 @@
 #force compiler to clang
 CC=clang
 CXX=clang++
+
+CFLAGS="$CFLAGS `cat tmp/cflags 2>/dev/null`"
+CFLAGS="$CFLAGS -isystem /usr/local/include -isystem /usr/pkg/include -O3"
+CXXFLAGS="$CXXFLAGS -std=c++0x `cat tmp/cxxflags 2>/dev/null`"
+CXXFLAGS="$CXXFLAGS -isystem /usr/local/include -isystem /usr/pkg/include -O3"
+
+LDFLAGS="$LDFLAGS -L/usr/local/lib `cat tmp/ldflags 2>/dev/null`"
+export LD_LIBRARY_PATH="`cat tmp/ldpath 2>/dev/null`"
+
 CPP="clang -E"
 
-AM_INIT_AUTOMAKE([1.10 no-define no-dist-gzip dist-bzip2 tar-ustar])
+# FIXME 'subdir-objects' breaks dependency tracking
+AM_INIT_AUTOMAKE([1.10 no-define no-dist-gzip dist-bzip2 tar-ustar subdir-objects no-dependencies])
 
 AC_CONFIG_MACRO_DIR([m4])
 AM_MAINTAINER_MODE
@@ -65,7 +62,7 @@
         AC_DEFINE(EMULATED_HOST_CPU_TYPE, 7, [Emulated CPU type])
         AC_DEFINE(EMULATED_HOST_CPU_SUBTYPE, 10, [Emulated CPU subtype])
     ;;
-     x86_64)
+     x86_64|amd64)
         AC_DEFINE(EMULATED_HOST_CPU_TYPE, 16777223, [Emulated CPU type])
         AC_DEFINE(EMULATED_HOST_CPU_SUBTYPE, 3, [Emulated CPU subtype])
     ;;
@@ -164,6 +161,51 @@
 )
 CFLAGS=$ORIGCFLAGS
 
+
+ORIGCFLAGS=$CFLAGS
+CFLAGS="$CFLAGS -Wno-unused-private-field"
+AC_MSG_CHECKING([if -Wno-unused-private-field is supported])
+AC_COMPILE_IFELSE(
+   [AC_LANG_SOURCE([[const char hw[] = "Hello, World\n";]])],
+   [WARNINGS="$WARNINGS -Wno-unused-private-field"
+    AC_MSG_RESULT([yes])],
+   [AC_MSG_RESULT([no])]
+)
+CFLAGS=$ORIGCFLAGS
+
+ORIGCFLAGS=$CFLAGS
+CFLAGS="$CFLAGS -Wno-unused-function"
+AC_MSG_CHECKING([if -Wno-unused-function is supported])
+AC_COMPILE_IFELSE(
+   [AC_LANG_SOURCE([[const char hw[] = "Hello, World\n";]])],
+   [WARNINGS="$WARNINGS -Wno-unused-function"
+    AC_MSG_RESULT([yes])],
+   [AC_MSG_RESULT([no])]
+)
+CFLAGS=$ORIGCFLAGS
+
+ORIGCFLAGS=$CFLAGS
+CFLAGS="$CFLAGS -Wno-objc-root-class"
+AC_MSG_CHECKING([if -Wno-objc-root-class is supported])
+AC_COMPILE_IFELSE(
+   [AC_LANG_SOURCE([[const char hw[] = "Hello, World\n";]])],
+   [WARNINGS="$WARNINGS -Wno-objc-root-class"
+    AC_MSG_RESULT([yes])],
+   [AC_MSG_RESULT([no])]
+)
+CFLAGS=$ORIGCFLAGS
+
+ORIGCFLAGS=$CFLAGS
+CFLAGS="$CFLAGS -Wno-deprecated-objc-isa-usage"
+AC_MSG_CHECKING([if -Wno-deprecated-objc-isa-usage is supported])
+AC_COMPILE_IFELSE(
+   [AC_LANG_SOURCE([[const char hw[] = "Hello, World\n";]])],
+   [WARNINGS="$WARNINGS -Wno-deprecated-objc-isa-usage"
+    AC_MSG_RESULT([yes])],
+   [AC_MSG_RESULT([no])]
+)
+CFLAGS=$ORIGCFLAGS
+
 ORIGCFLAGS=$CFLAGS
 CFLAGS="$CFLAGS -Wno-invalid-offsetof"
 AC_MSG_CHECKING([if -Wno-invalid-offsetof is supported])
@@ -175,30 +217,43 @@
 )
 CFLAGS=$ORIGCFLAGS
 
+ORIGCFLAGS=$CFLAGS
+CFLAGS="$CFLAGS -Wno-int-conversion"
+AC_MSG_CHECKING([if -Wno-int-conversion is supported])
+AC_COMPILE_IFELSE(
+   [AC_LANG_SOURCE([[const char hw[] = "Hello, World\n";]])],
+   [WARNINGS="$WARNINGS -Wno-int-conversion"
+    AC_MSG_RESULT([yes])],
+   [AC_MSG_RESULT([no])]
+)
+CFLAGS=$ORIGCFLAGS
+
+ORIGCFLAGS=$CFLAGS
+CFLAGS="$CFLAGS -Wno-char-subscripts"
+AC_MSG_CHECKING([if -Wno-char-subscripts is supported])
+AC_COMPILE_IFELSE(
+   [AC_LANG_SOURCE([[const char hw[] = "Hello, World\n";]])],
+   [WARNINGS="$WARNINGS -Wno-char-subscripts"
+    AC_MSG_RESULT([yes])],
+   [AC_MSG_RESULT([no])]  
+)  
+CFLAGS=$ORIGCFLAGS
+
 AC_SUBST([WARNINGS], [$WARNINGS])
 
 
-AC_CHECK_LIB([dl],[dlopen],[
-         DL_LIBS=-ldl
-         ])
+AC_CHECK_LIB([dl],[dlopen],[DL_LIBS=-ldl])
 AC_SUBST(DL_LIBS)
 
-AC_CHECK_LIB([pthread],[pthread_create],[
-         PTHREAD_FLAGS=-pthread
-         ])
+AC_CHECK_LIB([pthread],[pthread_create],[PTHREAD_FLAGS=-pthread])
 AC_SUBST(PTHREAD_FLAGS)
 
-AC_CHECK_LIB([uuid],[uuid_generate_random],[
-         UUID_LIBS=-luuid
-         ])
+AC_CHECK_LIB([uuid],[uuid_generate_random],[UUID_LIBS=-luuid])
 AC_SUBST(UUID_LIBS)
 
-AC_CHECK_LIB([crypto],[MD5_Init],[
-         CRYPT_LIBS=-lcrypto
-         ])
+AC_CHECK_LIB([crypto],[MD5_Init],[CRYPT_LIBS=-lcrypto])
 AC_SUBST(CRYPT_LIBS)
 
-
 AC_CHECK_LIB([c++abi],[__cxa_demangle],[CXXABI_LIB=-lc++abi],[
   AC_CHECK_LIB([supc++],[__cxa_demangle],[CXXABI_LIB=-lsupc++],[
     AC_CHECK_LIB([stdc++],[__cxa_demangle],[CXXABI_LIB=-lstdc++],[exit 1])
diff -Nur cctools-855-ld64-236.3/gprof/gprof.h ../cctools-port.bak/cctools/gprof/gprof.h
--- cctools-855-ld64-236.3/gprof/gprof.h	2014-06-30 02:37:05.578089471 +0800
+++ ../cctools-port.bak/cctools/gprof/gprof.h	2014-06-30 02:06:45.557154528 +0800
@@ -57,17 +57,17 @@
  *
  *	@(#)gprof.h	8.1 (Berkeley) 6/6/93
  */
-#include <stdio.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <gnu/a.out.h>
+#import <stdio.h>
+#import <sys/types.h>
+#import <sys/stat.h>
+#import <gnu/a.out.h>
 #ifdef __OPENSTEP__
-#include <mach-o/rld_state.h>
-#include <mach-o/gmon.h>
+#import <mach-o/rld_state.h>
+#import <mach-o/gmon.h>
 #else
-#include <sys/gmon.h>
+#import <sys/gmon.h>
 #endif
-#include "stuff/bool.h"
+#import "stuff/bool.h"
 
 /*
  * Used for comparison routine return values.
diff -Nur cctools-855-ld64-236.3/include/foreign/architecture/alignment.h ../cctools-port.bak/cctools/include/foreign/architecture/alignment.h
--- cctools-855-ld64-236.3/include/foreign/architecture/alignment.h	2014-06-30 01:18:32.000000000 +0800
+++ ../cctools-port.bak/cctools/include/foreign/architecture/alignment.h	2014-06-30 02:06:45.564154528 +0800
@@ -34,12 +34,8 @@
  */
  
 
-#if defined (__ppc__)
-#include "architecture/ppc/alignment.h"
-#elif defined (__i386__)
+#if defined (__i386__)
 #include "architecture/i386/alignment.h"
-#elif defined (__arm__)
-#include "architecture/arm/alignment.h"
 #else
 #error architecture not supported
 #endif
diff -Nur cctools-855-ld64-236.3/include/foreign/architecture/APPLE_LICENSE ../cctools-port.bak/cctools/include/foreign/architecture/APPLE_LICENSE
--- cctools-855-ld64-236.3/include/foreign/architecture/APPLE_LICENSE	1970-01-01 08:00:00.000000000 +0800
+++ ../cctools-port.bak/cctools/include/foreign/architecture/APPLE_LICENSE	2014-06-30 02:06:45.564154528 +0800
@@ -0,0 +1,367 @@
+APPLE PUBLIC SOURCE LICENSE
+Version 2.0 - August 6, 2003
+
+Please read this License carefully before downloading this software.
+By downloading or using this software, you are agreeing to be bound by
+the terms of this License. If you do not or cannot agree to the terms
+of this License, please do not download or use the software.
+
+1. General; Definitions. This License applies to any program or other
+work which Apple Computer, Inc. ("Apple") makes publicly available and
+which contains a notice placed by Apple identifying such program or
+work as "Original Code" and stating that it is subject to the terms of
+this Apple Public Source License version 2.0 ("License"). As used in
+this License:
+
+1.1 "Applicable Patent Rights" mean: (a) in the case where Apple is
+the grantor of rights, (i) claims of patents that are now or hereafter
+acquired, owned by or assigned to Apple and (ii) that cover subject
+matter contained in the Original Code, but only to the extent
+necessary to use, reproduce and/or distribute the Original Code
+without infringement; and (b) in the case where You are the grantor of
+rights, (i) claims of patents that are now or hereafter acquired,
+owned by or assigned to You and (ii) that cover subject matter in Your
+Modifications, taken alone or in combination with Original Code.
+
+1.2 "Contributor" means any person or entity that creates or
+contributes to the creation of Modifications.
+
+1.3 "Covered Code" means the Original Code, Modifications, the
+combination of Original Code and any Modifications, and/or any
+respective portions thereof.
+
+1.4 "Externally Deploy" means: (a) to sublicense, distribute or
+otherwise make Covered Code available, directly or indirectly, to
+anyone other than You; and/or (b) to use Covered Code, alone or as
+part of a Larger Work, in any way to provide a service, including but
+not limited to delivery of content, through electronic communication
+with a client other than You.
+
+1.5 "Larger Work" means a work which combines Covered Code or portions
+thereof with code not governed by the terms of this License.
+
+1.6 "Modifications" mean any addition to, deletion from, and/or change
+to, the substance and/or structure of the Original Code, any previous
+Modifications, the combination of Original Code and any previous
+Modifications, and/or any respective portions thereof. When code is
+released as a series of files, a Modification is: (a) any addition to
+or deletion from the contents of a file containing Covered Code;
+and/or (b) any new file or other representation of computer program
+statements that contains any part of Covered Code.
+
+1.7 "Original Code" means (a) the Source Code of a program or other
+work as originally made available by Apple under this License,
+including the Source Code of any updates or upgrades to such programs
+or works made available by Apple under this License, and that has been
+expressly identified by Apple as such in the header file(s) of such
+work; and (b) the object code compiled from such Source Code and
+originally made available by Apple under this License.
+
+1.8 "Source Code" means the human readable form of a program or other
+work that is suitable for making modifications to it, including all
+modules it contains, plus any associated interface definition files,
+scripts used to control compilation and installation of an executable
+(object code).
+
+1.9 "You" or "Your" means an individual or a legal entity exercising
+rights under this License. For legal entities, "You" or "Your"
+includes any entity which controls, is controlled by, or is under
+common control with, You, where "control" means (a) the power, direct
+or indirect, to cause the direction or management of such entity,
+whether by contract or otherwise, or (b) ownership of fifty percent
+(50%) or more of the outstanding shares or beneficial ownership of
+such entity.
+
+2. Permitted Uses; Conditions & Restrictions. Subject to the terms
+and conditions of this License, Apple hereby grants You, effective on
+the date You accept this License and download the Original Code, a
+world-wide, royalty-free, non-exclusive license, to the extent of
+Apple's Applicable Patent Rights and copyrights covering the Original
+Code, to do the following:
+
+2.1 Unmodified Code. You may use, reproduce, display, perform,
+internally distribute within Your organization, and Externally Deploy
+verbatim, unmodified copies of the Original Code, for commercial or
+non-commercial purposes, provided that in each instance:
+
+(a) You must retain and reproduce in all copies of Original Code the
+copyright and other proprietary notices and disclaimers of Apple as
+they appear in the Original Code, and keep intact all notices in the
+Original Code that refer to this License; and
+
+(b) You must include a copy of this License with every copy of Source
+Code of Covered Code and documentation You distribute or Externally
+Deploy, and You may not offer or impose any terms on such Source Code
+that alter or restrict this License or the recipients' rights
+hereunder, except as permitted under Section 6.
+
+2.2 Modified Code. You may modify Covered Code and use, reproduce,
+display, perform, internally distribute within Your organization, and
+Externally Deploy Your Modifications and Covered Code, for commercial
+or non-commercial purposes, provided that in each instance You also
+meet all of these conditions:
+
+(a) You must satisfy all the conditions of Section 2.1 with respect to
+the Source Code of the Covered Code;
+
+(b) You must duplicate, to the extent it does not already exist, the
+notice in Exhibit A in each file of the Source Code of all Your
+Modifications, and cause the modified files to carry prominent notices
+stating that You changed the files and the date of any change; and
+
+(c) If You Externally Deploy Your Modifications, You must make
+Source Code of all Your Externally Deployed Modifications either
+available to those to whom You have Externally Deployed Your
+Modifications, or publicly available. Source Code of Your Externally
+Deployed Modifications must be released under the terms set forth in
+this License, including the license grants set forth in Section 3
+below, for as long as you Externally Deploy the Covered Code or twelve
+(12) months from the date of initial External Deployment, whichever is
+longer. You should preferably distribute the Source Code of Your
+Externally Deployed Modifications electronically (e.g. download from a
+web site).
+
+2.3 Distribution of Executable Versions. In addition, if You
+Externally Deploy Covered Code (Original Code and/or Modifications) in
+object code, executable form only, You must include a prominent
+notice, in the code itself as well as in related documentation,
+stating that Source Code of the Covered Code is available under the
+terms of this License with information on how and where to obtain such
+Source Code.
+
+2.4 Third Party Rights. You expressly acknowledge and agree that
+although Apple and each Contributor grants the licenses to their
+respective portions of the Covered Code set forth herein, no
+assurances are provided by Apple or any Contributor that the Covered
+Code does not infringe the patent or other intellectual property
+rights of any other entity. Apple and each Contributor disclaim any
+liability to You for claims brought by any other entity based on
+infringement of intellectual property rights or otherwise. As a
+condition to exercising the rights and licenses granted hereunder, You
+hereby assume sole responsibility to secure any other intellectual
+property rights needed, if any. For example, if a third party patent
+license is required to allow You to distribute the Covered Code, it is
+Your responsibility to acquire that license before distributing the
+Covered Code.
+
+3. Your Grants. In consideration of, and as a condition to, the
+licenses granted to You under this License, You hereby grant to any
+person or entity receiving or distributing Covered Code under this
+License a non-exclusive, royalty-free, perpetual, irrevocable license,
+under Your Applicable Patent Rights and other intellectual property
+rights (other than patent) owned or controlled by You, to use,
+reproduce, display, perform, modify, sublicense, distribute and
+Externally Deploy Your Modifications of the same scope and extent as
+Apple's licenses under Sections 2.1 and 2.2 above.
+
+4. Larger Works. You may create a Larger Work by combining Covered
+Code with other code not governed by the terms of this License and
+distribute the Larger Work as a single product. In each such instance,
+You must make sure the requirements of this License are fulfilled for
+the Covered Code or any portion thereof.
+
+5. Limitations on Patent License. Except as expressly stated in
+Section 2, no other patent rights, express or implied, are granted by
+Apple herein. Modifications and/or Larger Works may require additional
+patent licenses from Apple which Apple may grant in its sole
+discretion.
+
+6. Additional Terms. You may choose to offer, and to charge a fee for,
+warranty, support, indemnity or liability obligations and/or other
+rights consistent with the scope of the license granted herein
+("Additional Terms") to one or more recipients of Covered Code.
+However, You may do so only on Your own behalf and as Your sole
+responsibility, and not on behalf of Apple or any Contributor. You
+must obtain the recipient's agreement that any such Additional Terms
+are offered by You alone, and You hereby agree to indemnify, defend
+and hold Apple and every Contributor harmless for any liability
+incurred by or claims asserted against Apple or such Contributor by
+reason of any such Additional Terms.
+
+7. Versions of the License. Apple may publish revised and/or new
+versions of this License from time to time. Each version will be given
+a distinguishing version number. Once Original Code has been published
+under a particular version of this License, You may continue to use it
+under the terms of that version. You may also choose to use such
+Original Code under the terms of any subsequent version of this
+License published by Apple. No one other than Apple has the right to
+modify the terms applicable to Covered Code created under this
+License.
+
+8. NO WARRANTY OR SUPPORT. The Covered Code may contain in whole or in
+part pre-release, untested, or not fully tested works. The Covered
+Code may contain errors that could cause failures or loss of data, and
+may be incomplete or contain inaccuracies. You expressly acknowledge
+and agree that use of the Covered Code, or any portion thereof, is at
+Your sole and entire risk. THE COVERED CODE IS PROVIDED "AS IS" AND
+WITHOUT WARRANTY, UPGRADES OR SUPPORT OF ANY KIND AND APPLE AND
+APPLE'S LICENSOR(S) (COLLECTIVELY REFERRED TO AS "APPLE" FOR THE
+PURPOSES OF SECTIONS 8 AND 9) AND ALL CONTRIBUTORS EXPRESSLY DISCLAIM
+ALL WARRANTIES AND/OR CONDITIONS, EXPRESS OR IMPLIED, INCLUDING, BUT
+NOT LIMITED TO, THE IMPLIED WARRANTIES AND/OR CONDITIONS OF
+MERCHANTABILITY, OF SATISFACTORY QUALITY, OF FITNESS FOR A PARTICULAR
+PURPOSE, OF ACCURACY, OF QUIET ENJOYMENT, AND NONINFRINGEMENT OF THIRD
+PARTY RIGHTS. APPLE AND EACH CONTRIBUTOR DOES NOT WARRANT AGAINST
+INTERFERENCE WITH YOUR ENJOYMENT OF THE COVERED CODE, THAT THE
+FUNCTIONS CONTAINED IN THE COVERED CODE WILL MEET YOUR REQUIREMENTS,
+THAT THE OPERATION OF THE COVERED CODE WILL BE UNINTERRUPTED OR
+ERROR-FREE, OR THAT DEFECTS IN THE COVERED CODE WILL BE CORRECTED. NO
+ORAL OR WRITTEN INFORMATION OR ADVICE GIVEN BY APPLE, AN APPLE
+AUTHORIZED REPRESENTATIVE OR ANY CONTRIBUTOR SHALL CREATE A WARRANTY.
+You acknowledge that the Covered Code is not intended for use in the
+operation of nuclear facilities, aircraft navigation, communication
+systems, or air traffic control machines in which case the failure of
+the Covered Code could lead to death, personal injury, or severe
+physical or environmental damage.
+
+9. LIMITATION OF LIABILITY. TO THE EXTENT NOT PROHIBITED BY LAW, IN NO
+EVENT SHALL APPLE OR ANY CONTRIBUTOR BE LIABLE FOR ANY INCIDENTAL,
+SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES ARISING OUT OF OR RELATING
+TO THIS LICENSE OR YOUR USE OR INABILITY TO USE THE COVERED CODE, OR
+ANY PORTION THEREOF, WHETHER UNDER A THEORY OF CONTRACT, WARRANTY,
+TORT (INCLUDING NEGLIGENCE), PRODUCTS LIABILITY OR OTHERWISE, EVEN IF
+APPLE OR SUCH CONTRIBUTOR HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
+DAMAGES AND NOTWITHSTANDING THE FAILURE OF ESSENTIAL PURPOSE OF ANY
+REMEDY. SOME JURISDICTIONS DO NOT ALLOW THE LIMITATION OF LIABILITY OF
+INCIDENTAL OR CONSEQUENTIAL DAMAGES, SO THIS LIMITATION MAY NOT APPLY
+TO YOU. In no event shall Apple's total liability to You for all
+damages (other than as may be required by applicable law) under this
+License exceed the amount of fifty dollars ($50.00).
+
+10. Trademarks. This License does not grant any rights to use the
+trademarks or trade names "Apple", "Apple Computer", "Mac", "Mac OS",
+"QuickTime", "QuickTime Streaming Server" or any other trademarks,
+service marks, logos or trade names belonging to Apple (collectively
+"Apple Marks") or to any trademark, service mark, logo or trade name
+belonging to any Contributor. You agree not to use any Apple Marks in
+or as part of the name of products derived from the Original Code or
+to endorse or promote products derived from the Original Code other
+than as expressly permitted by and in strict compliance at all times
+with Apple's third party trademark usage guidelines which are posted
+at http://www.apple.com/legal/guidelinesfor3rdparties.html.
+
+11. Ownership. Subject to the licenses granted under this License,
+each Contributor retains all rights, title and interest in and to any
+Modifications made by such Contributor. Apple retains all rights,
+title and interest in and to the Original Code and any Modifications
+made by or on behalf of Apple ("Apple Modifications"), and such Apple
+Modifications will not be automatically subject to this License. Apple
+may, at its sole discretion, choose to license such Apple
+Modifications under this License, or on different terms from those
+contained in this License or may choose not to license them at all.
+
+12. Termination.
+
+12.1 Termination. This License and the rights granted hereunder will
+terminate:
+
+(a) automatically without notice from Apple if You fail to comply with
+any term(s) of this License and fail to cure such breach within 30
+days of becoming aware of such breach;
+
+(b) immediately in the event of the circumstances described in Section
+13.5(b); or
+
+(c) automatically without notice from Apple if You, at any time during
+the term of this License, commence an action for patent infringement
+against Apple; provided that Apple did not first commence
+an action for patent infringement against You in that instance.
+
+12.2 Effect of Termination. Upon termination, You agree to immediately
+stop any further use, reproduction, modification, sublicensing and
+distribution of the Covered Code. All sublicenses to the Covered Code
+which have been properly granted prior to termination shall survive
+any termination of this License. Provisions which, by their nature,
+should remain in effect beyond the termination of this License shall
+survive, including but not limited to Sections 3, 5, 8, 9, 10, 11,
+12.2 and 13. No party will be liable to any other for compensation,
+indemnity or damages of any sort solely as a result of terminating
+this License in accordance with its terms, and termination of this
+License will be without prejudice to any other right or remedy of
+any party.
+
+13. Miscellaneous.
+
+13.1 Government End Users. The Covered Code is a "commercial item" as
+defined in FAR 2.101. Government software and technical data rights in
+the Covered Code include only those rights customarily provided to the
+public as defined in this License. This customary commercial license
+in technical data and software is provided in accordance with FAR
+12.211 (Technical Data) and 12.212 (Computer Software) and, for
+Department of Defense purchases, DFAR 252.227-7015 (Technical Data --
+Commercial Items) and 227.7202-3 (Rights in Commercial Computer
+Software or Computer Software Documentation). Accordingly, all U.S.
+Government End Users acquire Covered Code with only those rights set
+forth herein.
+
+13.2 Relationship of Parties. This License will not be construed as
+creating an agency, partnership, joint venture or any other form of
+legal association between or among You, Apple or any Contributor, and
+You will not represent to the contrary, whether expressly, by
+implication, appearance or otherwise.
+
+13.3 Independent Development. Nothing in this License will impair
+Apple's right to acquire, license, develop, have others develop for
+it, market and/or distribute technology or products that perform the
+same or similar functions as, or otherwise compete with,
+Modifications, Larger Works, technology or products that You may
+develop, produce, market or distribute.
+
+13.4 Waiver; Construction. Failure by Apple or any Contributor to
+enforce any provision of this License will not be deemed a waiver of
+future enforcement of that or any other provision. Any law or
+regulation which provides that the language of a contract shall be
+construed against the drafter will not apply to this License.
+
+13.5 Severability. (a) If for any reason a court of competent
+jurisdiction finds any provision of this License, or portion thereof,
+to be unenforceable, that provision of the License will be enforced to
+the maximum extent permissible so as to effect the economic benefits
+and intent of the parties, and the remainder of this License will
+continue in full force and effect. (b) Notwithstanding the foregoing,
+if applicable law prohibits or restricts You from fully and/or
+specifically complying with Sections 2 and/or 3 or prevents the
+enforceability of either of those Sections, this License will
+immediately terminate and You must immediately discontinue any use of
+the Covered Code and destroy all copies of it that are in your
+possession or control.
+
+13.6 Dispute Resolution. Any litigation or other dispute resolution
+between You and Apple relating to this License shall take place in the
+Northern District of California, and You and Apple hereby consent to
+the personal jurisdiction of, and venue in, the state and federal
+courts within that District with respect to this License. The
+application of the United Nations Convention on Contracts for the
+International Sale of Goods is expressly excluded.
+
+13.7 Entire Agreement; Governing Law. This License constitutes the
+entire agreement between the parties with respect to the subject
+matter hereof. This License shall be governed by the laws of the
+United States and the State of California, except that body of
+California law concerning conflicts of law.
+
+Where You are located in the province of Quebec, Canada, the following
+clause applies: The parties hereby confirm that they have requested
+that this License and all related documents be drafted in English. Les
+parties ont exige que le present contrat et tous les documents
+connexes soient rediges en anglais.
+
+EXHIBIT A.
+
+"Portions Copyright (c) 1999-2003 Apple Computer, Inc. All Rights
+Reserved.
+
+This file contains Original Code and/or Modifications of Original Code
+as defined in and that are subject to the Apple Public Source License
+Version 2.0 (the 'License'). You may not use this file except in
+compliance with the License. Please obtain a copy of the License at
+http://www.opensource.apple.com/apsl/ and read it before using this
+file.
+
+The Original Code and all software distributed under the License are
+distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+Please see the License for the specific language governing rights and
+limitations under the License."
diff -Nur cctools-855-ld64-236.3/include/foreign/architecture/i386/asm_help.h ../cctools-port.bak/cctools/include/foreign/architecture/i386/asm_help.h
--- cctools-855-ld64-236.3/include/foreign/architecture/i386/asm_help.h	2014-06-30 01:18:32.000000000 +0800
+++ ../cctools-port.bak/cctools/include/foreign/architecture/i386/asm_help.h	2014-06-30 02:06:45.564154528 +0800
@@ -82,26 +82,26 @@
  */
 #if defined(__i386__)
 #define NESTED_FUNCTION_PROLOGUE(localvarsize)			\
-	.set	__framesize,ROUND_TO_STACK(localvarsize)	;\
-	.set	__nested_function, 1				;\
+	.set	L__framesize,ROUND_TO_STACK(localvarsize)	;\
+	.set	L__nested_function, 1				;\
 	CALL_MCOUNT						\
-	.if __framesize						;\
+	.if L__framesize						;\
 	  pushl	%ebp						;\
 	  movl	%esp, %ebp					;\
-	  subl	$__framesize, %esp				;\
+	  subl	$L__framesize, %esp				;\
 	.endif							;\
 	pushl	%edi						;\
 	pushl	%esi						;\
 	pushl	%ebx
 #elif defined(__x86_64__)
 #define NESTED_FUNCTION_PROLOGUE(localvarsize)			\
-	.set	__framesize,ROUND_TO_STACK(localvarsize)	;\
-	.set	__nested_function, 1				;\
+	.set	L__framesize,ROUND_TO_STACK(localvarsize)	;\
+	.set	L__nested_function, 1				;\
 	CALL_MCOUNT						\
-	.if __framesize						;\
+	.if L__framesize						;\
 	  pushq	%rbp						;\
 	  movq	%rsp, %rbp					;\
-	  subq	$__framesize, %rsp				;\
+	  subq	$L__framesize, %rsp				;\
 	.endif							;
 #endif
 
@@ -112,23 +112,23 @@
  */
 #if defined(__i386__)
 #define LEAF_FUNCTION_PROLOGUE(localvarsize)			\
-	.set	__framesize,ROUND_TO_STACK(localvarsize)	;\
-	.set	__nested_function, 0				;\
+	.set	L__framesize,ROUND_TO_STACK(localvarsize)	;\
+	.set	L__nested_function, 0				;\
 	CALL_MCOUNT						\
-	.if __framesize						;\
+	.if L__framesize						;\
 	  pushl	%ebp						;\
 	  movl	%esp, %ebp					;\
-	  subl	$__framesize, %esp				;\
+	  subl	$L__framesize, %esp				;\
 	.endif
 #elif defined(__x86_64__)
 #define LEAF_FUNCTION_PROLOGUE(localvarsize)			\
-	.set	__framesize,ROUND_TO_STACK(localvarsize)	;\
-	.set	__nested_function, 0				;\
+	.set	L__framesize,ROUND_TO_STACK(localvarsize)	;\
+	.set	L__nested_function, 0				;\
 	CALL_MCOUNT						\
-	.if __framesize						;\
+	.if L__framesize						;\
 	  pushq	%rbp						;\
 	  movq	%rsp, %rbp					;\
-	  subq	$__framesize, %rsp				;\
+	  subq	$L__framesize, %rsp				;\
 	.endif
 #endif
 
@@ -140,19 +140,19 @@
  */
 #if defined(__i386__)
 #define FUNCTION_EPILOGUE					\
-	.if __nested_function					;\
+	.if L__nested_function					;\
 	  popl	%ebx						;\
 	  popl	%esi						;\
 	  popl	%edi						;\
 	.endif							;\
-	.if __framesize						;\
+	.if L__framesize						;\
 	  movl	%ebp, %esp					;\
 	  popl	%ebp						;\
 	.endif							;\
 	ret
 #elif defined(__x86_64__)
 #define FUNCTION_EPILOGUE					\
-	.if __framesize						;\
+	.if L__framesize						;\
 	  movq	%rbp, %rsp					;\
 	  popq	%rbp						;\
 	.endif							;\
diff -Nur cctools-855-ld64-236.3/include/foreign/architecture/i386/fenv.h ../cctools-port.bak/cctools/include/foreign/architecture/i386/fenv.h
--- cctools-855-ld64-236.3/include/foreign/architecture/i386/fenv.h	2014-06-30 01:18:32.000000000 +0800
+++ ../cctools-port.bak/cctools/include/foreign/architecture/i386/fenv.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,287 +0,0 @@
-/*
- * Copyright (c) 2002 Apple Computer, Inc. All rights reserved.
- *
- * @APPLE_LICENSE_HEADER_START@
- * 
- * The contents of this file constitute Original Code as defined in and
- * are subject to the Apple Public Source License Version 1.1 (the
- * "License").  You may not use this file except in compliance with the
- * License.  Please obtain a copy of the License at
- * http://www.apple.com/publicsource and read it before using this file.
- * 
- * This Original Code and all software distributed under the License are
- * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
- * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
- * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
- * License for the specific language governing rights and limitations
- * under the License.
- * 
- * @APPLE_LICENSE_HEADER_END@
- */
- 
-/*******************************************************************************
-*                                                                              *
-*     File:  fenv.h	                                                       *
-*                                                                              *
-*     Contains: typedefs and prototypes for C99 floating point environment.    *
-*                                                                              *
-*******************************************************************************/
-
-#ifndef __FENV__
-#define __FENV__
-
-#if defined( __ppc__ ) || defined( __ppc64__ )
-    #error  Wrong arch. This is Intel only.
-#endif
-   
-#if defined(__GNUC__) && (__GNUC__ >= 4)   
-#pragma GCC fenv
-#endif
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*
-    A collection of functions designed to provide access to the floating
-    point environment for numerical programming. It is compliant with
-    the floating-point requirements in C99.
-    
-    Earlier versions of fenv.h were merely "modeled after" C9X. Many of the functions 
-    that formerly returned ints now return void to be standard compliant.
-    
-    Note: There are actually two physical floating point environments on x86. There
-    is the one described by the x87 floating point control and status words, which applies 
-    primarily to calculations done with long double on MacOS X for Intel. There is the 
-    MXCSR which applies primarily to calculations done with scalar float, scalar double 
-    and SSE/SSE2/SSE3. The high level interface, which uses FE_ macros as int arguments 
-    to configure the fexcep_t, returns and works with values that represents the logical 
-    OR of these two sets of flags or masks. That is, if a flag or mask is set in either 
-    environment, it will be set in fexcept_t when the state is read. Likewise, setting 
-    the mask using a fexcep_t will set that mask on both environments. For this reason, 
-    changing the value of the MXCSR state or floating point control/status word state on 
-    your own will make the results of the functions declared in this header undefined. 
-    See below for details about how and when. Exception: you may change the FZ, DAZ, DE 
-    and DM bits in the MXCSR independent of this interface and retain defined behavior, 
-    so long as you do not change the other bits. It is suggested that developers who wish 
-    this level of control access the bits in the fenv_t directly. They are direct copies 
-    of the hardware special purpose registers of similar name. Please consult appropriate 
-    Intel documentation for the processor about the meaning of various bits in each register. 
-        
-    The file <fenv.h> declares many functions in support of numerical
-    programming. Programs that test flags or run under
-    non-default modes must do so under the effect of an enabling
-    "fenv_access" pragma.
-*/
-
-/********************************************************************************
-*                                                                               *
-*    fenv_t         is a type for representing the entire floating-point        *
-*                   environment in a single object.                             *
-*                                                                               *
-*    fexcept_t      is a type for representing the floating-point               *
-*                   exception flag state collectively.                          *
-*                                                                               *
-********************************************************************************/
-typedef struct {
-    unsigned short  __control;      /* A direct copy of the floaing point control word */
-    unsigned short  __status;       /* A direct copy of the floaing point status word */
-    unsigned int    __mxcsr;        /* A direct copy of the MXCSR */
-    char            __reserved[8];  /* Reserved for future expansion. */   
-} fenv_t;
-
-typedef unsigned short fexcept_t;
-
-/*    Definitions of floating-point exception macros                          */
-#define FE_INEXACT          0x0020
-#define FE_UNDERFLOW        0x0010
-#define FE_OVERFLOW         0x0008
-#define FE_DIVBYZERO        0x0004
-#define FE_INVALID          0x0001
-#define FE_ALL_EXCEPT       0x003D
-
-/*    Definitions of rounding direction macros                                */
-#define FE_TONEAREST        0x0000
-#define FE_DOWNWARD         0x0400
-#define FE_UPWARD           0x0800
-#define FE_TOWARDZERO       0x0C00
-
-/* default environment object        */
-extern const fenv_t _FE_DFL_ENV;
-#define FE_DFL_ENV &_FE_DFL_ENV          /* pointer to default environment    */
-
-/*******************************************************************************
-* A environment object that sets to defualt settings and in addition sets the  *
-* FZ and DAZ bits in the MXCSR, which causes flush-to-zero behavior of         *
-* denormals. When using this environment, denormals encountered by XMM based   *
-* calculation (which normally should be all single and double precision scalar *
-* floating point calculations, and all SSE/SSE2/SSE3 computation) will be      *
-* treated as zero. Calculation results that are denormals will also be         *
-* truncated to zero. This calculation mode is not IEEE-754 compliant, but may  *
-* prevent lengthy stalls that occur in code that encounters denormals. It is   *
-* suggested that you do not use this mode unless you have established that     *
-* denormals are causing trouble for your code. Please use wisely.              *
-*                                                                              *
-* CAUTION: The math library currently is not architected to do the right       *
-* thing in the face of DAZ + FZ mode.  For example, ceil( +denormal) returns   *
-* +denormal rather than 1.0 in some versions of MacOS X. In some circumstances *
-* this may lead to unexpected application behavior. Use at your own risk.      *
-*                                                                              *
-* It is not possible to disable denorm stalls on calculation using the x87 FPU.*
-*******************************************************************************/
-extern const fenv_t _FE_DFL_DISABLE_SSE_DENORMS_ENV;
-#define FE_DFL_DISABLE_SSE_DENORMS_ENV  &_FE_DFL_DISABLE_SSE_DENORMS_ENV
-
-/*******************************************************************************
-*     The following functions provide high level access to the exception flags.*  
-*     The "int" input argument can be constructed by bitwise ORs of the        *
-*     exception macros: for example: FE_OVERFLOW | FE_INEXACT.                 *
-*******************************************************************************/
-
-/*******************************************************************************
-*     The function "feclearexcept" clears the supported floating point         *
-*     exceptions represented by its argument.                                  *
-*******************************************************************************/
-
-extern int  feclearexcept(int /*excepts*/);
-
-
-/*******************************************************************************
-*    The function "fegetexceptflag" stores a implementation-defined            *
-*    representation of the states of the floating-point status flags indicated *
-*    by its integer argument excepts in the object pointed to by the argument, * 
-*    flagp.                                                                    *
-*******************************************************************************/
-
-extern int  fegetexceptflag(fexcept_t * /*flagp*/, int /*excepts*/);
-
-
-/*******************************************************************************
-*     The function "feraiseexcept" raises the supported floating-point         *
-*     exceptions represented by its argument. The order in which these         *
-*     floating-point exceptions are raised is unspecified.                     *
-*******************************************************************************/
-
-extern int  feraiseexcept(int /*excepts*/);
-
-
-/*******************************************************************************
-*     The function "fesetexceptflag" sets or clears the floating point status  *
-*     flags indicated by the argument excepts to the states stored in the      *
-*     object pointed to by flagp. The value of the *flagp shall have been set  *
-*     by a previous call to fegetexceptflag whose second argument represented  *
-*     at least those floating-point exceptions represented by the argument     *
-*     excepts. This function does not raise floating-point exceptions; it just *
-*     sets the state of the flags.                                             *
-*******************************************************************************/
-
-extern int  fesetexceptflag(const fexcept_t * /*flagp*/, int /*excepts*/);
-
-
-/*******************************************************************************
-*     The function "fetestexcept" determines which of the specified subset of  *
-*     the floating-point exception flags are currently set.  The excepts       *
-*     argument specifies the floating-point status flags to be queried. This   *
-*     function returns the value of the bitwise OR of the floating-point       *
-*     exception macros corresponding to the currently set floating-point       *
-*     exceptions included in excepts.                                          *
-*                                                                              *
-*     On MacOS X for Intel, the result is the value of union of the            *
-*     corresponding result from the x87 and SSE floating point states.         *
-*******************************************************************************/
-
-extern int  fetestexcept(int /*excepts*/);
-
-
-/*******************************************************************************
-*     The following functions provide control of rounding direction modes.     *
-*******************************************************************************/
-
-/*******************************************************************************
-*     The function "fegetround" returns the value of the rounding direction    *
-*     macro which represents the current rounding direction, or a negative     *
-*     if there is no such rounding direction macro or the current rounding     *
-*     direction is not determinable.                                           *
-*******************************************************************************/
-
-extern int  fegetround(void);
-
-
-/*******************************************************************************
-*     The function "fesetround" establishes the rounding direction represented *
-*     by its argument "round". If the argument is not equal to the value of a  *
-*     rounding direction macro, the rounding direction is not changed.  It     *
-*     returns zero if and only if the argument is equal to a rounding          *
-*     direction macro.                                                         *
-*******************************************************************************/
-
-extern int  fesetround(int /*round*/);
-
-
-/*******************************************************************************
-*    The following functions manage the floating-point environment, exception  *
-*    flags and dynamic modes, as one entity.                                   *
-*******************************************************************************/
-
-/*******************************************************************************
-*    The fegetenv function stores the current floating-point enviornment in    *
-*    the object pointed to by envp.                                            *
-*******************************************************************************/
-extern int  fegetenv(fenv_t * /*envp*/);
-
-/*******************************************************************************
-*    The feholdexcept function saves the current floating-point environment in *
-*    the object pointed to by envp, clears the floating-point status flags,    *
-*    and then installs a non-stop (continue on floating-point exceptions)      *
-*    mode, if available, for all floating-point exceptions. The feholdexcept   *
-*    function returns zero if and only if non-stop floating-point exceptions   *
-*    handling was successfully installed.                                      *
-*******************************************************************************/
-extern int   feholdexcept(fenv_t * /*envp*/);
-
-/*******************************************************************************
-*    The fesetnv function establishes the floating-point environment           *
-*    represented by the object pointed to by envp. The argument envp shall     *
-*    point to an object set by a call to fegetenv or feholdexcept, or equal to *
-*    a floating-point environment macro -- we define only *FE_DFL_ENV and      *
-*    FE_DISABLE_SSE_DENORMS_ENV -- to be C99 standard compliant and portable   *
-*    to other architectures. Note that fesetnv merely installs the state of    *
-*    the floating-point status flags represented through its argument, and     *
-*    does not raise these floating-point exceptions.                           *
-*                                                                              *
-*    On MacOS X for Intel you may test and set the bits in *envp yourself,     *
-*    provided that you conditionalize the code appropriately to preserve       *
-*    portability and you follow the various strictures and suggestions         *
-*    provided by Intel in appropriate processor documentation. Please be aware *
-*    that because there are two hardware locations for setting and reading     *
-*    floating point environment, this function (and others like it) are not    *
-*    atomic -- that is, for a brief period of time during the function call    *
-*    your new environment will have been applied to one but not both of the    *
-*    floating point engines (x87 and SSE). In addition, the behavior of some   *
-*    higher level interfaces (fegetround) is undefined if the x87 and SSE      *
-*    floating point units rounding modes are configured differently.  Please   *
-*    use common sense.                                                         *
-*******************************************************************************/
-extern int  fesetenv(const fenv_t * /*envp*/);
-
-/*******************************************************************************
-*    The feupdateenv function saves the currently raised floating-point        *
-*    exceptions in its automatic storage, installs the floating-point          *
-*    environment represented by the object pointed to by envp, and then raises *
-*    the saved floating-point exceptions. The argument envp shall point to an  *
-*    object set by a call to feholdexcept or fegetenv or equal a               *
-*    floating-point environment macro.                                         *
-*                                                                              *
-*    Please see the description of feholdexcept for additional ways to create  *
-*    a fenv_t object, which are valid only for MacOS X for Intel.              *
-*******************************************************************************/
-extern int  feupdateenv(const fenv_t * /*envp*/);
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* __FENV__ */
-
diff -Nur cctools-855-ld64-236.3/include/foreign/architecture/i386/math.h ../cctools-port.bak/cctools/include/foreign/architecture/i386/math.h
--- cctools-855-ld64-236.3/include/foreign/architecture/i386/math.h	2014-06-30 01:18:32.000000000 +0800
+++ ../cctools-port.bak/cctools/include/foreign/architecture/i386/math.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,642 +0,0 @@
-/*
- * Copyright (c) 2002 Apple Computer, Inc. All rights reserved.
- *
- * @APPLE_LICENSE_HEADER_START@
- * 
- * The contents of this file constitute Original Code as defined in and
- * are subject to the Apple Public Source License Version 1.1 (the
- * "License").  You may not use this file except in compliance with the
- * License.  Please obtain a copy of the License at
- * http://www.apple.com/publicsource and read it before using this file.
- * 
- * This Original Code and all software distributed under the License are
- * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
- * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
- * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
- * License for the specific language governing rights and limitations
- * under the License.
- * 
- * @APPLE_LICENSE_HEADER_END@
- */
- 
-/*******************************************************************************
-*                                                                              *
-*     File:  math.h	                                                       *
-*                                                                              *
-*     Contains: typedefs, prototypes, and macros germane to C99 floating point.*
-*                                                                              *
-*******************************************************************************/
-#ifndef __MATH__
-#define __MATH__
-
-#include "sys/cdefs.h" /* For definition of __DARWIN_UNIX03 et al */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/******************************************************************************
-*       Floating point data types                                             *
-******************************************************************************/
-
-/*	Define float_t and double_t per C standard, ISO/IEC 9899:1999 7.12 2,
-	taking advantage of GCC's __FLT_EVAL_METHOD__ (which a compiler may
-	define anytime and GCC does) that shadows FLT_EVAL_METHOD (which a compiler
-	must and may define only in float.h).
-*/
-#if __FLT_EVAL_METHOD__ == 0
-	typedef float float_t;
-	typedef double double_t;
-#elif __FLT_EVAL_METHOD__ == 1
-	typedef double float_t;
-	typedef double double_t;
-#elif __FLT_EVAL_METHOD__ == 2 || __FLT_EVAL_METHOD__ == -1
-	typedef long double float_t;
-	typedef long double double_t;
-#else /* __FLT_EVAL_METHOD__ */
-	#error "Unsupported value of __FLT_EVAL_METHOD__."
-#endif /* __FLT_EVAL_METHOD__ */
-
-
-#if defined(__GNUC__)
-	#define	HUGE_VAL	__builtin_huge_val()
-	#define	HUGE_VALF	__builtin_huge_valf()
-	#define	HUGE_VALL	__builtin_huge_vall()
-    #define NAN         __builtin_nanf("0x7fc00000") /* Constant expression, can be used as initializer. */
-    #define __MATH_H_ALWAYS_INLINE__		__attribute__ ((always_inline))
-#else
-    #define	HUGE_VAL	1e500
-    #define	HUGE_VALF	1e50f
-    #define	HUGE_VALL	1e5000L
-    #define NAN		__nan( )
-    #define __MATH_H_ALWAYS_INLINE__
-#endif
-
-#define INFINITY	HUGE_VALF
-
-
-/******************************************************************************
-*      Taxonomy of floating point data types                                  *
-******************************************************************************/
-
-#define FP_NAN          1
-#define FP_INFINITE     2
-#define FP_ZERO         3
-#define FP_NORMAL       4
-#define FP_SUBNORMAL    5
-#define FP_SUPERNORMAL  6 /* meaningful only on PowerPC */
-
-/* fma() *function call* is more costly than equivalent (in-line) multiply and add operations    */
-/* For single and double precision, the cost isn't too bad, because we can fall back on higher   */
-/* precision hardware, with the necessary range to handle infinite precision products. However,  */
-/* expect the long double fma to be at least an order of magnitude slower than a simple multiply */
-/* and an add.                                                                                   */
-#undef FP_FAST_FMA
-#undef FP_FAST_FMAF
-#undef FP_FAST_FMAL
-
-/* The values returned by `ilogb' for 0 and NaN respectively. */
-#define FP_ILOGB0	(-2147483647 - 1)
-#define FP_ILOGBNAN	(-2147483647 - 1)
-
-/* Bitmasks for the math_errhandling macro.  */
-#define MATH_ERRNO	1	/* errno set by math functions.  */
-#define MATH_ERREXCEPT	2	/* Exceptions raised by math functions.  */
-
-#define math_errhandling (__math_errhandling())
-extern unsigned int __math_errhandling ( void );
-
-/********************************************************************************
-*                                                                               *
-*                              Inquiry macros                                   *
-*                                                                               *
-*   fpclassify      Returns one of the FP_≈ values.                             *
-*   isnormal        Non-zero if and only if the argument x is normalized.       *
-*   isfinite        Non-zero if and only if the argument x is finite.           *
-*   isnan           Non-zero if and only if the argument x is a NaN.            *
-*   signbit         Non-zero if and only if the sign of the argument x is       *
-*                   negative.  This includes, NaNs, infinities and zeros.       *
-*                                                                               *
-********************************************************************************/
-
-#define fpclassify(x)	\
-	(	sizeof (x) == sizeof(float )	?	__fpclassifyf((float)(x))	\
-	:	sizeof (x) == sizeof(double)	?	__fpclassifyd((double)(x))	\
-										:	__fpclassify ((long double)(x)))
-
-extern int __fpclassifyf(float      );
-extern int __fpclassifyd(double     );
-extern int __fpclassify (long double);
-
-#if defined( __GNUC__ ) && 0 == __FINITE_MATH_ONLY__ 
-    /*  Yes, that's right. You only get the fast iswhatever() macros if you do NOT turn on -ffast-math.  */
-    /*  These inline functions require the compiler to be compiling to standard in order to work.        */
-    /*  -ffast-math, among other things, implies that NaNs don't happen. The compiler can in that case   */
-    /*  optimize x != x to be false always, wheras it would be true for NaNs. That breaks __inline_isnan() */
-    /*  below.                                                                                           */
-	#define isnormal(x)	\
-		(	sizeof (x) == sizeof(float )	?	__inline_isnormalf((float)(x))	\
-		:	sizeof (x) == sizeof(double)	?	__inline_isnormald((double)(x))	\
-											:	__inline_isnormal ((long double)(x)))
-
-	#define isfinite(x)	\
-		(	sizeof (x) == sizeof(float )	?	__inline_isfinitef((float)(x))	\
-		:	sizeof (x) == sizeof(double)	?	__inline_isfinited((double)(x))	\
-											:	__inline_isfinite ((long double)(x)))
-
-	#define isinf(x)	\
-		(	sizeof (x) == sizeof(float )	?	__inline_isinff((float)(x))	\
-		:	sizeof (x) == sizeof(double)	?	__inline_isinfd((double)(x))	\
-											:	__inline_isinf ((long double)(x)))
-
-	#define isnan(x)	\
-		(	sizeof (x) == sizeof(float )	?	__inline_isnanf((float)(x))	\
-		:	sizeof (x) == sizeof(double)	?	__inline_isnand((double)(x))	\
-											:	__inline_isnan ((long double)(x)))
-
-	#define signbit(x)	\
-		(	sizeof (x) == sizeof(float )	?	__inline_signbitf((float)(x))	\
-		:	sizeof (x) == sizeof(double)	?	__inline_signbitd((double)(x))	\
-											:	__inline_signbit((long double)(x)))
-
-	static __inline__  int __inline_isfinitef	(float      ) __MATH_H_ALWAYS_INLINE__;
-	static __inline__  int __inline_isfinited	(double     ) __MATH_H_ALWAYS_INLINE__;
-	static __inline__  int __inline_isfinite	(long double) __MATH_H_ALWAYS_INLINE__;
-	static __inline__  int __inline_isinff		(float      ) __MATH_H_ALWAYS_INLINE__;
-	static __inline__  int __inline_isinfd		(double     ) __MATH_H_ALWAYS_INLINE__;
-	static __inline__  int __inline_isinf		(long double) __MATH_H_ALWAYS_INLINE__;
-	static __inline__  int __inline_isnanf		(float      ) __MATH_H_ALWAYS_INLINE__;
-	static __inline__  int __inline_isnand		(double     ) __MATH_H_ALWAYS_INLINE__;
-	static __inline__  int __inline_isnan		(long double) __MATH_H_ALWAYS_INLINE__;
-	static __inline__  int __inline_isnormalf    (float      ) __MATH_H_ALWAYS_INLINE__;
-	static __inline__  int __inline_isnormald    (double     ) __MATH_H_ALWAYS_INLINE__;
-	static __inline__  int __inline_isnormal     (long double) __MATH_H_ALWAYS_INLINE__;
-	static __inline__  int __inline_signbitf     (float      ) __MATH_H_ALWAYS_INLINE__;
-	static __inline__  int __inline_signbitd     (double     ) __MATH_H_ALWAYS_INLINE__;
-	static __inline__  int __inline_signbit      (long double) __MATH_H_ALWAYS_INLINE__;
-	
-	static __inline__  int __inline_isinff( float __x ) { return __builtin_fabsf(__x) == __builtin_inff(); }
-	static __inline__  int __inline_isinfd( double __x ) { return __builtin_fabs(__x) == __builtin_inf(); }
-	static __inline__  int __inline_isinf( long double __x ) { return __builtin_fabsl(__x) == __builtin_infl(); }
-	static __inline__  int __inline_isfinitef( float __x ) { return __x == __x && __builtin_fabsf(__x) != __builtin_inff(); }
-	static __inline__  int __inline_isfinited( double __x ) { return __x == __x && __builtin_fabs(__x) != __builtin_inf(); }
-	static __inline__  int __inline_isfinite( long double __x ) { return __x == __x && __builtin_fabsl(__x) != __builtin_infl(); }
-	static __inline__  int __inline_isnanf( float __x ) { return __x != __x; }
-	static __inline__  int __inline_isnand( double __x ) { return __x != __x; }
-	static __inline__  int __inline_isnan( long double __x ) { return __x != __x; }
-	static __inline__  int __inline_signbitf( float __x ) { union{ float __f; unsigned int __u; }__u; __u.__f = __x; return (int)(__u.__u >> 31); }
-	static __inline__  int __inline_signbitd( double __x ) { union{ double __f; unsigned int __u[2]; }__u; __u.__f = __x; return (int)(__u.__u[1] >> 31); }
-	static __inline__  int __inline_signbit( long double __x ){ union{ long double __ld; struct{ unsigned int __m[2]; short __sexp; }__p; }__u; __u.__ld = __x; return (int) (((unsigned short) __u.__p.__sexp) >> 15); } 
-	static __inline__  int __inline_isnormalf( float __x ) { float fabsf = __builtin_fabsf(__x); if( __x != __x ) return 0; return fabsf < __builtin_inff() && fabsf >= __FLT_MIN__; }  
-	static __inline__  int __inline_isnormald( double __x ) { double fabsf = __builtin_fabs(__x); if( __x != __x ) return 0; return fabsf < __builtin_inf() && fabsf >= __DBL_MIN__; }  
-	static __inline__  int __inline_isnormal( long double __x ) { long double fabsf = __builtin_fabsl(__x); if( __x != __x ) return 0; return fabsf < __builtin_infl() && fabsf >= __LDBL_MIN__; }  
-	
-#else
-
-	#define isnormal(x)	\
-		(	sizeof (x) == sizeof(float )	?	__isnormalf((float)(x))	\
-		:	sizeof (x) == sizeof(double)	?	__isnormald((double)(x))	\
-											:	__isnormal ((long double)(x)))
-
-	#define isfinite(x)	\
-		(	sizeof (x) == sizeof(float )	?	__isfinitef((float)(x))	\
-		:	sizeof (x) == sizeof(double)	?	__isfinited((double)(x))	\
-											:	__isfinite ((long double)(x)))
-
-	#define isinf(x)	\
-		(	sizeof (x) == sizeof(float )	?	__isinff((float)(x))	\
-		:	sizeof (x) == sizeof(double)	?	__isinfd((double)(x))	\
-											:	__isinf ((long double)(x)))
-
-	#define isnan(x)	\
-		(	sizeof (x) == sizeof(float )	?	__isnanf((float)(x))	\
-		:	sizeof (x) == sizeof(double)	?	__isnand((double)(x))	\
-											:	__isnan ((long double)(x)))
-
-	#define signbit(x)	\
-		(	sizeof (x) == sizeof(float )	?	__signbitf((float)(x))	\
-		:	sizeof (x) == sizeof(double)	?	__signbitd((double)(x))	\
-											:	__signbitl((long double)(x)))
-
-
-	extern int __isnormalf  (float      );
-	extern int __isnormald  (double     );
-	extern int __isnormal   (long double);
-
-	extern int __isfinitef  (float      );
-	extern int __isfinited  (double     );
-	extern int __isfinite   (long double);
-
-	extern int __isinff     (float      );
-	extern int __isinfd     (double     );
-	extern int __isinf      (long double);
-
-	extern int __isnanf     (float      );
-	extern int __isnand     (double     );
-	extern int __isnan      (long double);
-
-	extern int __signbitf   (float      );
-	extern int __signbitd   (double     );
-	extern int __signbitl   (long double);
-
-#endif
-
-
-
-/********************************************************************************
-*                                                                               *
-*                              Math Functions                                   *
-*                                                                               *
-********************************************************************************/
-
-extern double  acos( double );
-extern float  acosf( float );
-
-extern double  asin( double );
-extern float  asinf( float );
-
-extern double  atan( double );
-extern float  atanf( float );
-
-extern double  atan2( double, double );
-extern float  atan2f( float, float );
-
-extern double  cos( double );
-extern float  cosf( float );
-
-extern double  sin( double );
-extern float  sinf( float );
-
-extern double  tan( double );
-extern float  tanf( float );
-
-extern double  acosh( double );
-extern float  acoshf( float );
-
-extern double  asinh( double );
-extern float  asinhf( float );
-
-extern double  atanh( double );
-extern float  atanhf( float );
-
-extern double  cosh( double );
-extern float  coshf( float );
-
-extern double  sinh( double );
-extern float  sinhf( float );
-
-extern double  tanh( double );
-extern float  tanhf( float );
-
-extern double exp ( double );
-extern float expf ( float );
-
-extern double exp2 ( double ); 
-extern float exp2f ( float );
-
-extern double expm1 ( double ); 
-extern float expm1f ( float );
-
-extern double log ( double );
-extern float logf ( float );
-
-extern double log10 ( double );
-extern float log10f ( float );
-
-extern double log2 ( double );
-extern float log2f ( float );
-
-extern double log1p ( double );
-extern float log1pf ( float );
-
-extern double logb ( double );
-extern float logbf ( float );
-
-extern double modf ( double, double * );
-extern float modff ( float, float * );
-
-extern double ldexp ( double, int );
-extern float ldexpf ( float, int );
-
-extern double frexp ( double, int * );
-extern float frexpf ( float, int * );
-
-extern int ilogb ( double );
-extern int ilogbf ( float );
-
-extern double scalbn ( double, int );
-extern float scalbnf ( float, int );
-
-extern double scalbln ( double, long int );
-extern float scalblnf ( float, long int );
-
-extern double  fabs( double );
-extern float  fabsf( float );
-
-extern double  cbrt( double );
-extern float  cbrtf( float );
-
-extern double hypot ( double, double );
-extern float hypotf ( float, float );
-
-extern double pow ( double, double );
-extern float powf ( float, float );
-
-extern double  sqrt( double );
-extern float  sqrtf( float );
-
-extern double  erf( double );
-extern float  erff( float );
-
-extern double  erfc( double );
-extern float  erfcf( float );
-
-/*	lgamma and lgammaf are not thread-safe.  The thread-safe variants
- *	lgamma_r and lgammaf_r are available on OS X 10.6 and later.
- *
- *	To use the thread-safe variants, you must define the _REENTRANT symbol.
- */
-extern double  lgamma( double );
-extern float  lgammaf( float );
-
-extern double  tgamma( double );
-extern float  tgammaf( float );
-
-extern double ceil ( double );
-extern float ceilf ( float );
-
-extern double floor ( double );
-extern float floorf ( float );
-
-extern double nearbyint ( double );
-extern float nearbyintf ( float );
-
-extern double rint ( double );
-extern float rintf ( float );
-
-extern long int lrint ( double );
-extern long int lrintf ( float );
-
-extern double round ( double );
-extern float roundf ( float );
-
-extern long int lround ( double );
-extern long int lroundf ( float );
-
-#if ( defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L ) || ! defined( __STRICT_ANSI__ )  || ! defined( __GNUC__ )
-
-    /* long long is not part of C90. Make sure you are passing -std=c99 or -std=gnu99 or better if you need this. */
-    extern long long int llrint ( double );
-    extern long long int llrintf ( float );
-
-    extern long long int llround ( double );
-    extern long long int llroundf ( float );
-
-#endif /* #if ( defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L ) || ! defined( __STRICT_ANSI__ )  || ! defined( __GNUC__ ) */
-
-extern double trunc ( double );
-extern float truncf ( float );
-
-extern double fmod ( double, double );
-extern float fmodf ( float, float );
-
-extern double remainder ( double, double );
-extern float remainderf ( float, float );
-
-extern double remquo ( double, double, int * );
-extern float remquof ( float, float, int * );
-
-extern double copysign ( double, double );
-extern float copysignf ( float, float );
-
-extern double nan( const char * );
-extern float nanf( const char * );
-
-extern double nextafter ( double, double );
-extern float nextafterf ( float, float );
-
-extern double fdim ( double, double );
-extern float fdimf ( float, float );
-
-extern double fmax ( double, double );
-extern float fmaxf ( float, float );
-
-extern double fmin ( double, double );
-extern float fminf ( float, float );
-
-extern double fma ( double, double, double );
-extern float fmaf ( float, float, float );
-
-extern long double acosl(long double);
-extern long double asinl(long double);
-extern long double atanl(long double);
-extern long double atan2l(long double, long double);
-extern long double cosl(long double);
-extern long double sinl(long double);
-extern long double tanl(long double);
-extern long double acoshl(long double);
-extern long double asinhl(long double);
-extern long double atanhl(long double);
-extern long double coshl(long double);
-extern long double sinhl(long double);
-extern long double tanhl(long double);
-extern long double expl(long double);
-extern long double exp2l(long double);
-extern long double expm1l(long double);
-extern long double logl(long double);
-extern long double log10l(long double);
-extern long double log2l(long double);
-extern long double log1pl(long double);
-extern long double logbl(long double);
-extern long double modfl(long double, long double *);
-extern long double ldexpl(long double, int);
-extern long double frexpl(long double, int *);
-extern int ilogbl(long double);
-extern long double scalbnl(long double, int);
-extern long double scalblnl(long double, long int);
-extern long double fabsl(long double);
-extern long double cbrtl(long double);
-extern long double hypotl(long double, long double);
-extern long double powl(long double, long double);
-extern long double sqrtl(long double);
-extern long double erfl(long double);
-extern long double erfcl(long double);
-	
-/*	lgammal is not thread-safe.
- *	The thread-safe variant lgammal_r is available on OS X 10.6 and later.
- *
- *	To use the thread-safe variant, you must define the _REENTRANT symbol.
- */
-extern long double lgammal(long double);
-	
-extern long double tgammal(long double);
-extern long double ceill(long double);
-extern long double floorl(long double);
-extern long double nearbyintl(long double);
-extern long double rintl(long double);
-extern long int lrintl(long double);
-extern long double roundl(long double);
-extern long int lroundl(long double);
-
-#if ( defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L ) || ! defined( __STRICT_ANSI__ )  || ! defined( __GNUC__ )
-    /* long long is not part of C90. Make sure you are passing -std=c99 or -std=gnu99 or better if you need this. */
-    extern long long int llrintl(long double);
-    extern long long int llroundl(long double);
-#endif /* #if ( defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L ) || ! defined( __STRICT_ANSI__ )  || ! defined( __GNUC__ ) */
-
-extern long double truncl(long double);
-extern long double fmodl(long double, long double);
-extern long double remainderl(long double, long double);
-extern long double remquol(long double, long double, int *);
-extern long double copysignl(long double, long double);
-extern long double nanl(const char *);
-extern long double nextafterl(long double, long double);
-extern double nexttoward(double, long double);
-extern float nexttowardf(float, long double);
-extern long double nexttowardl(long double, long double);
-extern long double fdiml(long double, long double);
-extern long double fmaxl(long double, long double);
-extern long double fminl(long double, long double);
-extern long double fmal(long double, long double, long double);
-
-#define isgreater(x, y) __builtin_isgreater ((x),(y))
-#define isgreaterequal(x, y) __builtin_isgreaterequal ((x),(y))
-#define isless(x, y) __builtin_isless ((x),(y))
-#define islessequal(x, y) __builtin_islessequal ((x),(y))
-#define islessgreater(x, y) __builtin_islessgreater ((x),(y))
-#define isunordered(x, y) __builtin_isunordered ((x),(y))
-
-extern double  		__inf( void );
-extern float  		__inff( void );
-extern long double  __infl( void );
-extern float  		__nan( void ); /* 10.3 (and later) must retain in ABI for backward compatability */
-
-#if !defined(_ANSI_SOURCE)
-extern double j0 ( double );
-
-extern double j1 ( double );
-
-extern double jn ( int, double );
-
-extern double y0 ( double );
-
-extern double y1 ( double );
-
-extern double yn ( int, double );
-
-extern double scalb ( double, double ); 
-
-
-#define M_E         2.71828182845904523536028747135266250   /* e */
-#define M_LOG2E     1.44269504088896340735992468100189214   /* log 2e */
-#define M_LOG10E    0.434294481903251827651128918916605082  /* log 10e */
-#define M_LN2       0.693147180559945309417232121458176568  /* log e2 */
-#define M_LN10      2.30258509299404568401799145468436421   /* log e10 */
-#define M_PI        3.14159265358979323846264338327950288   /* pi */
-#define M_PI_2      1.57079632679489661923132169163975144   /* pi/2 */
-#define M_PI_4      0.785398163397448309615660845819875721  /* pi/4 */
-#define M_1_PI      0.318309886183790671537767526745028724  /* 1/pi */
-#define M_2_PI      0.636619772367581343075535053490057448  /* 2/pi */
-#define M_2_SQRTPI  1.12837916709551257389615890312154517   /* 2/sqrt(pi) */
-#define M_SQRT2     1.41421356237309504880168872420969808   /* sqrt(2) */
-#define M_SQRT1_2   0.707106781186547524400844362104849039  /* 1/sqrt(2) */
-
-#define	MAXFLOAT	((float)3.40282346638528860e+38)
-extern int signgam;     /* required for unix 2003 */
-
-
-#endif /* !defined(_ANSI_SOURCE) */
-
-#if !defined(__NOEXTENSIONS__) && (!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE))
-#define __WANT_EXTENSIONS__
-#endif
-
-#ifdef __WANT_EXTENSIONS__
-
-#define FP_SNAN		FP_NAN
-#define FP_QNAN		FP_NAN
-
-extern long int rinttol ( double );		/* Legacy API: please use C99 lrint() instead. */
-
-extern long int roundtol ( double );	/* Legacy API: please use C99 lround() instead. */
-
-/*
- * XOPEN/SVID
- */
-#if !defined(_ANSI_SOURCE) && (!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE))
-#if (!defined(_XOPEN_SOURCE) || defined(_DARWIN_C_SOURCE))
-#if !defined(__cplusplus)
-/* used by matherr below */
-struct exception {
-	int type;
-	char *name;
-	double arg1;
-	double arg2;
-	double retval;
-};
-#endif
-
-#define	HUGE		MAXFLOAT
-
-/* 
- * set X_TLOSS = pi*2**52, which is possibly defined in <values.h>
- * (one may replace the following line by "#include <values.h>")
- */
-
-#define X_TLOSS		1.41484755040568800000e+16 
-
-#define	DOMAIN		1
-#define	SING		2
-#define	OVERFLOW	3
-#define	UNDERFLOW	4
-#define	TLOSS		5
-#define	PLOSS		6
-
-#endif /* (!_XOPEN_SOURCE || _DARWIN_C_SOURCE) */
-#endif /* !_ANSI_SOURCE && (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */
-
-#if !defined( __STRICT_ANSI__) && !defined(_ANSI_SOURCE) && (!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE))
-extern int finite ( double );			/* Legacy API: please use C99 isfinite() instead. */
-
-extern double gamma ( double );			/* Legacy API: please use C99 tgamma() instead. */
-
-#if (!defined(_XOPEN_SOURCE) || defined(_DARWIN_C_SOURCE))
-
-#if !defined(__cplusplus)
-extern int matherr ( struct exception * );
-#endif
-
-/*
- * IEEE Test Vector
- */
-extern double significand ( double );
-
-/*
- * BSD math library entry points
- */
-extern double drem ( double, double );	/* Legacy API: please use C99 remainder() instead. */
-	
-/*
- * Reentrant version of lgamma; passes signgam back by reference
- * as the second argument; user must allocate space for signgam.
- */
-	
-#ifdef _REENTRANT
-	#include <AvailabilityMacros.h>
-	// Available on OS X 10.6 and later.
-	extern float  lgammaf_r ( float, int * ) AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER;
-	extern double lgamma_r ( double, int * ) AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER;
-	extern long double lgammal_r ( long double, int * ) AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER;
-#endif /* _REENTRANT */
-	
-#endif /* (!_XOPEN_SOURCE || _DARWIN_C_SOURCE) */
-#endif /* !_ANSI_SOURCE && (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */
-
-#endif /* __WANT_EXTENSIONS__ */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* __MATH__ */
diff -Nur cctools-855-ld64-236.3/include/foreign/architecture/ppc/alignment.h ../cctools-port.bak/cctools/include/foreign/architecture/ppc/alignment.h
--- cctools-855-ld64-236.3/include/foreign/architecture/ppc/alignment.h	2014-06-30 01:18:32.000000000 +0800
+++ ../cctools-port.bak/cctools/include/foreign/architecture/ppc/alignment.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,79 +0,0 @@
-/*
- * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
- *
- * @APPLE_LICENSE_HEADER_START@
- * 
- * This file contains Original Code and/or Modifications of Original Code
- * as defined in and that are subject to the Apple Public Source License
- * Version 2.0 (the 'License'). You may not use this file except in
- * compliance with the License. Please obtain a copy of the License at
- * http://www.opensource.apple.com/apsl/ and read it before using this
- * file.
- * 
- * The Original Code and all software distributed under the License are
- * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
- * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
- * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
- * Please see the License for the specific language governing rights and
- * limitations under the License.
- * 
- * @APPLE_LICENSE_HEADER_END@
- */
-/*
- * Copyright (c) 1996 NeXT Software, Inc.
- *
- *	File:	architecture/ppc/alignment.h
-
- * Natural alignment of shorts and longs (for ppc)
- *
- * HISTORY
- *
- * 29-Dec-96  Umesh Vaishampayan  (umeshv@NeXT.com)
- *	Ported from m98k.
- * 2 Sept 1992 Brian Raymor at NeXT
- *      Moved over to architecture.
- * 17 August 1992 Jack Greenfield at NeXT
- *	Created.
- */
-
-__inline__ static unsigned short 
-get_align_short(void *ivalue)
-{
-    unsigned short	ovalue = ((unsigned char *) ivalue)[0];
-
-    ovalue <<= 8 * sizeof(unsigned char);
-    return ovalue + ((unsigned char *) ivalue)[1];
-}
-
-__inline__ static unsigned short 
-put_align_short(unsigned short ivalue, void *ovalue)
-{
-    unsigned short	*tvalue = &ivalue;
-
-    ((unsigned char *) ovalue)[0] = ((unsigned char *) tvalue)[0];
-    ((unsigned char *) ovalue)[1] = ((unsigned char *) tvalue)[1];
-    return ivalue;
-}
-
-__inline__ static unsigned long 
-get_align_long(void *ivalue)
-{
-    unsigned long	ovalue = get_align_short(ivalue);
-
-    ovalue <<= 8 * sizeof(unsigned short);
-    return ovalue + get_align_short(((unsigned char *) ivalue) + sizeof(short));
-}
-
-__inline__ static unsigned long 
-put_align_long(unsigned long ivalue, void *ovalue)
-{
-    unsigned long	*tvalue = &ivalue;
-
-    ((unsigned char *) ovalue)[0] = ((unsigned char *) tvalue)[0];
-    ((unsigned char *) ovalue)[1] = ((unsigned char *) tvalue)[1];
-    ((unsigned char *) ovalue)[2] = ((unsigned char *) tvalue)[2];
-    ((unsigned char *) ovalue)[3] = ((unsigned char *) tvalue)[3];
-    return ivalue;
-}
-
diff -Nur cctools-855-ld64-236.3/include/foreign/architecture/ppc/asm_help.h ../cctools-port.bak/cctools/include/foreign/architecture/ppc/asm_help.h
--- cctools-855-ld64-236.3/include/foreign/architecture/ppc/asm_help.h	2014-06-30 01:18:32.000000000 +0800
+++ ../cctools-port.bak/cctools/include/foreign/architecture/ppc/asm_help.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,451 +0,0 @@
-/*
- * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
- *
- * @APPLE_LICENSE_HEADER_START@
- * 
- * This file contains Original Code and/or Modifications of Original Code
- * as defined in and that are subject to the Apple Public Source License
- * Version 2.0 (the 'License'). You may not use this file except in
- * compliance with the License. Please obtain a copy of the License at
- * http://www.opensource.apple.com/apsl/ and read it before using this
- * file.
- * 
- * The Original Code and all software distributed under the License are
- * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
- * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
- * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
- * Please see the License for the specific language governing rights and
- * limitations under the License.
- * 
- * @APPLE_LICENSE_HEADER_END@
- */
-/* Copyright (c) 1996 NeXT Software, Inc.  All rights reserved.
- *
- *	File:	architecture/ppc/asm_help.h
- *	Author:	Mike DeMoney, NeXT Software, Inc.
- *
- *	This header file defines macros useful when writing assembly code
- *	for the PowerPC processors.
- *	r12 is used as the tmp register / PICIFY base.
- *
- * HISTORY
- * 20-May-97  Umesh Vaishampayan (umeshv@apple.com)
- *	Implemented Dynamic / PIC macros.
- *
- * 28-Dec-96  Umesh Vaishampayan (umeshv@NeXT.com)
- *	added ".align" directive to various macros to avoid alignment 
- *  	faults. Moved Register Usage #defines to reg_help.h as that's
- *	where they should have been in the first place.
- *	Added Dynamic / PIC macroes for routines which refernce external
- *	symbols. Not implemented fully as yet.
- *
- * 05-Nov-92  Mike DeMoney (mike@next.com)
- *	Created.
- */
-
-#ifndef	_ARCH_PPC_ASM_HELP_H_
-#define	_ARCH_PPC_ASM_HELP_H_
-
-#include	<architecture/ppc/reg_help.h>
-
-#ifdef	__ASSEMBLER__
-/*
- * ppc stack frames look like this after procedure prolog has
- * been executed:
- *
- * Higher address:
- *			.........
- *		+-------------------------------+
- * 		| caller's LR			|
- *		+-------------------------------+
- * 		| caller's CR			|
- *		+-------------------------------+
- * Caller's SP->| caller's caller's sp		|  ^^ Caller's Frame ^^
- *		+===============================+  vv Called Rtn Frame vv
- *		|	Save Area for		| FPF 31
- *			..........
- *		| 	Caller's FPF's		| FPF n
- *		+-------------------------------+
- *		|	Save Area for		| GRF 31
- *			..........
- *		| 	Caller's GRF's		| GRF n
- *		+-------------------------------+
- *		|	alignment pad		|
- *			............
- *		|	(if necessary)		|
- *		+-------------------------------+
- *		|	Local			|
- *			........
- *		| 	Variables		|
- *		+-------------------------------+
- * SP + X ->	| aN for FUTURE call		|
- *		+-------------------------------+
- *			..........
- *		+-------------------------------+
- * SP + 28 ->	| a1 for FUTURE call		|
- *		+-------------------------------+
- * SP + 24 ->	| a0 for FUTURE call		|
- *		+-------------------------------+
- * SP + 20 ->	| caller's TOC			|
- *		+-------------------------------+
- * SP + 16 ->	| reserved			|
- *		+-------------------------------+
- * SP + 12 ->	| reserved			|
- *		+-------------------------------+
- * SP + 8 ->	| LR callee-save for FUTURE call|
- *		+-------------------------------+
- * SP + 4 ->	| CR callee-save for FUTURE call|
- *		+-------------------------------+
- * SP ->	| caller's sp			|
- *		+===============================+
- * Lower address:
- *
- * NOTE: All state with the exception of LR and CR are saved in the
- * called routines frame.  LR and CR are saved in the CALLER'S FRAME.
- *
- * ALSO NOTE: Args to the called routine are found in the caller's frame.
- */
-
-/*
- * ARG(n) -- stack offset to n'th argument
- *
- * NOTE CAREFULLY!  These macros start numbering arguments at 1 (NOT 0)
- * The first argument is ARG(1).
- *
- * ALSO NOTE:  This stack offset is only valid if using routine
- * DOES NOT alter SP.
- *
- */
-#define	ARG(n)		((((n) - 1) * 4) + 24)
-
-/*
- * Macros for building stack frame according to C calling conventions.
- * lr, cr, and sp are saved.
- *
- * NOTE WELL: localvarsize is in bytes, maxargsout is a count of words,
- * grfsaved and fpfsaved is a count of registers.  BE SURE TO COUNT
- * BOTH FP (r31) AND sN REGISTERS IN THE COUNT OF GRF REGISTERS SAVED!
- * This will be TWO more than the N of the highest sN register you
- * save: s2 implies you are saving s2, s1, s0, and fp => grfsaved
- * should be 4!
- *
- * FURTHER NOTE: These macros do NOT SAVE GRF or FPF registers.  User
- * must do that.  GRF sN regs should be saved via
- *	stmw	sN,SAVED_GRF_S(N)(sp)
- * where N is the highest numbered s* register to be saved.  E.g. if
- * s0, s1, and s2 are to be saved use:
- *	stmw	s2,SAVED_GRF_S(2)(sp)
- * Note that this also saves fp.
- * An individual saved grf can be loaded via:
- *	lwz	s2,SAVED_GRF_S(2)(sp)
- * Analogous stuff works for fpf's.
- *
- * NOTE: these simple routines will be replaced with more complicated
- * ones once we know what the linker and gdb will require as for as 
- * register use masks and frame declarations.
- *
- * Warning: ROUND_TO_STACK is only to be used in assembly language;
- * for C usage, use ROUND_FRAME() in reg_help.h.
- */
-#define	ROUND_TO_STACK(len)				\
-	(((len) + STACK_INCR - 1) / STACK_INCR * STACK_INCR)
-
-#define	BUILD_FRAME(localvarsize, maxargsout, grfsaved, fpfsaved)	\
-	.set	__argoutsize, ROUND_TO_STACK((maxargsout) * 4)		@\
-	.if	__argoutsize < 32					@\
-	  .set	__argoutsize,32						@\
-	.endif								@\
-	.set	__framesize, ROUND_TO_STACK(				\
-			24 + __argoutsize + (localvarsize)		\
-			+ 4*(grfsaved) + 8*(fpfsaved))			@\
-	.set	__grfbase,(__framesize - 4*(grfsaved) - 8*(fpfsaved))	@\
-	.set	__fpfbase,(__framesize - 8*(fpfsaved))			@\
-	mflr	r0							@\
-	mfcr	r12							@\
-	stw	r0,8(sp)						@\
-	stw	r12,4(sp)						@\
-	stwu	r1,-__framesize(r1)
-
-/*
- * Macros for referencing data in stack frame.
- *
- * NOTE WELL: ARG's and VAR's start at 1, NOT 0. Why ??? (FIXME)
- */
-#define	LOCAL_VAR(n)	(((n)-1)*4 + __argoutsize + 24)
-#define	SAVED_GRF_S(n)	(__grfbase + ((grfsaved) - (n) - 2) * 4)
-#define	SAVED_FRF_FS(n)	(__fpfbase + ((fpfsaved) - (n) - 1) * 4)
-#define	ARG_IN(n)	(ARG(n) + __framesize)
-#define	ARG_OUT(n)	(ARG(n) + 0)
-#define	SAVED_FP	(__grfbase + ((grfsaved) - 1) * 4)
-#define	SAVED_LR	(__framesize + 8)
-#define	SAVED_CR	(__framesize + 4)
-
-/*
- * Macros for unwinding stack frame.
- * NOTE: GRF's and FPF's are NOT RESTORED.  User must do this before
- * using this macro.
- */
-#define	RETURN						\
-	.if	__framesize				@\
-	  lwz32	r0,r1,SAVED_LR				@\
-	  lwz32	r12,r1,SAVED_CR				@\
-	  addic	sp,r1,__framesize			@\
-	  mtlr	r0					@\
-	  mtcrf	0xff,r12				@\
-	  blr						@\
-	.else						@\
-	  blr						@\
-	.endif
-
-
-/*
- * Macros for declaring procedures
- *
- * Use of these macros allows ctags to have a predictable way
- * to find various types of declarations.  They also simplify
- * inserting appropriate symbol table information.
- *
- * NOTE: these simple stubs will be replaced with more
- * complicated versions once we know what the linker and gdb
- * will require as far as register use masks and frame declarations.
- * These macros may also be ifdef'ed in the future to contain profiling
- * code.
- *
- * FIXME: Document what makes a leaf a LEAF and a handler a HANDLER.
- * (E.g. leaf's have return pc in lr, NESTED's have rpc in offset off
- * sp, handlers have rpc in exception frame which is found via exception
- * link, etc etc.)
- */
-
-/*
- * TEXT -- declare start of text segment
- */
-#define	TEXT						\
-	.text						@\
-	.align 2
-
-/*
- * LEAF -- declare global leaf procedure
- * NOTE: Control SHOULD NOT FLOW into a LEAF!  A LEAF should only
- * be jumped to.  (A leaf may do an align.)  Use a LABEL() if you
- * need control to flow into the label.
- */
-#define	LEAF(name)					\
-	.align 2					@\
-	.globl	name					@\
-name:							@\
-	.set	__framesize,0
-
-/*
- * X_LEAF -- declare alternate global label for leaf
- */
-#define	X_LEAF(name, value)				\
-	.globl	name					@\
-	.set	name,value
-
-/*
- * P_LEAF -- declare private leaf procedure
- */
-#define	P_LEAF(name)					\
-	.align 2					@\
-name:							@\
-	.set	__framesize,0
-
-/*
- * LABEL -- declare a global code label
- * MUST be used (rather than LEAF, NESTED, etc) if control
- * "flows into" the label.
- */
-#define	LABEL(name)					\
-	.align 2					@\
-	.globl	name					@\
-name:
-
-/*
- * NESTED -- declare procedure that invokes other procedures
- */
-#define	NESTED(name, localvarsize, maxargsout, grfsaved, fpfsaved)\
-	.align 2				@\
-	.globl	name				@\
-name:						@\
-	BUILD_FRAME(localvarsize, maxargsout, grfsaved, fpfsaved)
-
-/*
- * X_NESTED -- declare alternate global label for nested proc
- */
-#define	X_NESTED(name, value)			\
-	.globl	name				@\
-	.set	name,value
-
-/*
- * P_NESTED -- declare private nested procedure
- */
-#define	P_NESTED(name, localvarsize, maxargsout, grfsaved, fpfsaved)\
-	.align 2					@\
-name:							@\
-	BUILD_FRAME(locavarsize, maxargsout, grfsaved, fpfsaved)
-
-/*
- * HANDLER -- declare procedure with exception frame rather than
- * standard C frame
- */
-#define	HANDLER(name)					\
-	.align 2					@\
-	.globl	name					@\
-name:
-
-/*
- * X_HANDLER -- declare alternate name for exception handler
- * (Should appear immediately before a HANDLER declaration or
- * another X_HANDLER declaration)
- */
-#define	X_HANDLER(name)					\
-	.align 2					@\
-	.globl	name					@\
-name:
-
-/*
- * P_HANDLER -- declare private handler
- */
-#define	P_HANDLER(name)					\
-	.align 2				@\
-name:
-
-/*
- * END -- mark end of procedure
- * FIXME: Unimplemented for now.
- */
-#define	END(name)
-
-/*
- * BL -- call procedure (relative)
- */
-#define	BL(name)					\
-	bl	name
-
-/*
- * Storage definition macros
- * The main purpose of these is to allow an easy handle for ctags
- */
-
-/*
- * IMPORT -- import symbol
- */
-#define	IMPORT(name)					\
-	.reference	name
-
-/*
- * ABS -- declare global absolute symbol
- */
-#define	ABS(name, value)				\
-	.globl	name					@\
-	.set	name,value
-
-/*
- * P_ABS -- declare private absolute symbol
- */
-#define	P_ABS(name, value)				\
-	.set	name,value
-
-/*
- * EXPORT -- declare global label for data
- */
-#define	EXPORT(name)					\
-	.align 2					@\
-	.globl	name					@\
-name:
-
-/*
- * BSS -- declare global zero'ed storage
- */
-#define	BSS(name,size)					\
-	.comm	name,size
-
-
-/*
- * P_BSS -- declare private zero'ed storage
- */
-#define	P_BSS(name,size)				\
-	.lcomm	name,size
-
-/*
- * dynamic/PIC macros for routines which reference external symbols
- */
-#if defined(__DYNAMIC__)
-#define PICIFY_REG r12
-
-/* Assume that the lr is saved before calling any of these macros */
-/* using PICIFY() */
-
-#define PICIFY(var)				\
-	mflr	r0				@\
-	bcl	20,31,1f			@\
-1:	mflr	PICIFY_REG			@\
-	mtlr	r0				@\
-	addis	PICIFY_REG, PICIFY_REG, ha16(L ## var ## __non_lazy_ptr - 1b) @\
-	lwz	PICIFY_REG, lo16(L ## var ## __non_lazy_ptr - 1b)(PICIFY_REG)
-
-#define CALL_EXTERN_AGAIN(var)			\
-	PICIFY(var)				@\
-	mtctr	PICIFY_REG			@\
-	mflr	r0				@\
-	stw	r0,8(r1)			@\
-	stwu	r1,-64(r1)			@\
-	bctrl					@\
-	addic	r1,r1,64    			@\
-	lwz	r0,8(r1)			@\
-	mtlr	r0
-
-#define NON_LAZY_STUB(var)			\
-	.non_lazy_symbol_pointer		@\
-	.align 2				@\
-L ## var ## __non_lazy_ptr:			@\
-	.indirect_symbol var			@\
-	.long 0					@\
-	.text					@\
-	.align 2
-
-#define	BRANCH_EXTERN(var)			\
-	PICIFY(var)				@\
-	mtctr	PICIFY_REG			@\
-	bctr					@\
-	NON_LAZY_STUB(var)
-
-#define CALL_EXTERN(var)			\
-	CALL_EXTERN_AGAIN(var)			@\
-	NON_LAZY_STUB(var)
-
-#define REG_TO_EXTERN(reg, var)			\
-	PICIFY(var)				@\
-	stw reg, 0(PICIFY_REG)			@\
-	NON_LAZY_STUB(var)
-
-#define EXTERN_TO_REG(reg, var)			\
-	PICIFY(var)				@\
-	lwz	reg, 0(PICIFY_REG)		@\
-	NON_LAZY_STUB(var)
-
-#else /* ! __DYNAMIC__ */
-#define TMP_REG r12
-#define BRANCH_EXTERN(var)			\
-	b	var
-
-#define CALL_EXTERN(var)			\
-	bl	var
-
-#define CALL_EXTERN_AGAIN(var)			\
-	CALL_EXTERN(var)
-
-#define REG_TO_EXTERN(reg, var)			\
-	lis	TMP_REG, ha16(var)		@\
-	stw	reg, lo16(var)(TMP_REG)
-
-#define EXTERN_TO_REG(reg, var)			\
-	lis	reg, ha16(var)			@\
-	lwz	reg, lo16(var)(reg)
-
-#endif	/* __DYNAMIC__ */
-
-#endif	/* __ASSEMBLER__ */
-#endif	/* _ARCH_PPC_ASM_HELP_H_ */
diff -Nur cctools-855-ld64-236.3/include/foreign/architecture/ppc/basic_regs.h ../cctools-port.bak/cctools/include/foreign/architecture/ppc/basic_regs.h
--- cctools-855-ld64-236.3/include/foreign/architecture/ppc/basic_regs.h	2014-06-30 01:18:32.000000000 +0800
+++ ../cctools-port.bak/cctools/include/foreign/architecture/ppc/basic_regs.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,301 +0,0 @@
-/*
- * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
- *
- * @APPLE_LICENSE_HEADER_START@
- * 
- * This file contains Original Code and/or Modifications of Original Code
- * as defined in and that are subject to the Apple Public Source License
- * Version 2.0 (the 'License'). You may not use this file except in
- * compliance with the License. Please obtain a copy of the License at
- * http://www.opensource.apple.com/apsl/ and read it before using this
- * file.
- * 
- * The Original Code and all software distributed under the License are
- * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
- * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
- * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
- * Please see the License for the specific language governing rights and
- * limitations under the License.
- * 
- * @APPLE_LICENSE_HEADER_END@
- */
-/* Copyright (c) 1996 NeXT Software, Inc.  All rights reserved.
- *
- *	File:	architecture/ppc/basic_regs.h
- *	Author:	Doug Mitchell, NeXT Software, Inc.
- *
- *	Basic ppc registers.
- *
- * HISTORY
- * 22-May-97  Umesh Vaishampayan  (umeshv@apple.com)
- 	Updated to match MPCFPE32B/AD 1/97 REV. 1 
- * 29-Dec-96  Umesh Vaishampayan  (umeshv@NeXT.com)
- *	Ported from m98k.
- * 05-Nov-92  Doug Mitchell at NeXT
- *	Created.
- */
-
-#ifndef _ARCH_PPC_BASIC_REGS_H_
-#define _ARCH_PPC_BASIC_REGS_H_
-
-#include <architecture/ppc/reg_help.h>
-#include <architecture/ppc/macro_help.h>
-
-#if !defined(__ASSEMBLER__)
-
-/*
- * Number of General Purpose registers.
- */
-#define PPC_NGP_REGS	32
-
-/*
- * Common half-word used in Machine State Register and in 
- * various exception frames. Defined as a macro because the compiler
- * will align a struct to a word boundary when used inside another struct.
- */
-#define MSR_BITS							   \
-	unsigned	ee:BIT_WIDTH(15),	/* external intr enable    */ \
-			pr:BIT_WIDTH(14),	/* problem state	   */ \
-			fp:BIT_WIDTH(13),	/* floating point avail	   */ \
-			me:BIT_WIDTH(12),	/* machine check enable	   */ \
-			fe0:BIT_WIDTH(11),	/* fp exception mode 0	   */ \
-			se:BIT_WIDTH(10),	/* single step enable	   */ \
-			be:BIT_WIDTH(9),	/* branch trace enable	   */ \
-			fe1:BIT_WIDTH(8),	/* fp exception mode 0	   */ \
-			rsvd1:BIT_WIDTH(7),	/* reserved		   */ \
-			ip:BIT_WIDTH(6),	/* interrupt prefix	   */ \
-			ir:BIT_WIDTH(5),	/* instruction relocate	   */ \
-			dr:BIT_WIDTH(4),	/* data relocate	   */ \
-			rsvd2:BITS_WIDTH(3,2),	/* reserved		   */ \
-			ri:BIT_WIDTH(1),	/* recoverable exception   */ \
-			le:BIT_WIDTH(0)		/* Little-endian mode	   */
-
-/*
- * Machine state register.
- * Read and written via get_msr() and set_msr() inlines, below.
- */
-typedef struct {
-	unsigned	rsvd3:BITS_WIDTH(31,19),	// reserved
-			pow:BIT_WIDTH(18),	// Power management enable
-			rsvd0: BIT_WIDTH(17),	// reserved
-			ile: BIT_WIDTH(16);	// exception little endian
-
-			MSR_BITS;			// see above
-} msr_t;
-
-/*
- * Data Storage Interrupt Status Register (DSISR)
- */
-typedef struct {
-	unsigned	dse:BIT_WIDTH(31);	// direct-store error
-	unsigned	tnf:BIT_WIDTH(30);	// translation not found
-	unsigned	:BITS_WIDTH(29,28);
-	unsigned	pe:BIT_WIDTH(27);	// protection error
-	unsigned	dsr:BIT_WIDTH(26);	// lwarx/stwcx to direct-store
-	unsigned	rw:BIT_WIDTH(25);	// 1 => store, 0 => load
-	unsigned	:BITS_WIDTH(24,23);
-	unsigned	dab:BIT_WIDTH(22);	// data address bkpt (601)
-	unsigned	ssf:BIT_WIDTH(21);	// seg table search failed
-	unsigned	:BITS_WIDTH(20,0);
-} dsisr_t;
-
-/*
- * Instruction Storage Interrupt Status Register (really SRR1)
- */
-typedef struct {
-	unsigned	:BIT_WIDTH(31);
-	unsigned	tnf:BIT_WIDTH(30);	// translation not found
-	unsigned	:BIT_WIDTH(29);
-	unsigned	dse:BIT_WIDTH(28);	// direct-store fetch error
-	unsigned	pe:BIT_WIDTH(27);	// protection error
-	unsigned	:BITS_WIDTH(26,22);
-	unsigned	ssf:BIT_WIDTH(21);	// seg table search failed
-	unsigned	:BITS_WIDTH(20,16);
-	MSR_BITS;
-} isisr_t;
-
-/*
- * Alignment Interrupt Status Register (really DSISR)
- * NOTE: bit numbers in field *names* are in IBM'ese (0 is MSB).
- * FIXME: Yuck!!! Double Yuck!!!
- */
-typedef struct {
-	unsigned	:BITS_WIDTH(31,20);
-	unsigned	ds3031:BITS_WIDTH(19,18);// bits 30:31 if DS form
-	unsigned	:BIT_WIDTH(17);
-	unsigned	x2930:BITS_WIDTH(16,15); // bits 29:30 if X form
-	unsigned	x25:BIT_WIDTH(14);	 // bit 25 if X form or
-						 // bit 5 if D or DS form
-	unsigned	x2124:BITS_WIDTH(13,10); // bits 21:24 if X form or
-						 // bits 1:4 if D or DS form
-	unsigned	all615:BITS_WIDTH(9,0);	 // bits 6:15 of instr
-	MSR_BITS;
-} aisr_t;
-
-/*
- * Program Interrupt Status Register (really SRR1)
- */
-typedef struct {
-	unsigned	:BITS_WIDTH(31,21);
-	unsigned	fpee:BIT_WIDTH(20);	// floating pt enable exception
-	unsigned	ill:BIT_WIDTH(19);	// illegal instruction
-	unsigned	priv:BIT_WIDTH(18);	// privileged instruction
-	unsigned	trap:BIT_WIDTH(17);	// trap program interrupt
-	unsigned	subseq:BIT_WIDTH(16);	// 1 => SRR0 points to
-						// subsequent instruction
-	MSR_BITS;
-} pisr_t;
-
-/*
- * Condition register. May not be useful in C, let's see...
- */
-typedef struct {
-	unsigned	lt:BIT_WIDTH(31),	// negative
-			gt:BIT_WIDTH(30),	// positive
-			eq:BIT_WIDTH(29),	// equal to zero
-			so:BIT_WIDTH(28),	// summary overflow
-			fx:BIT_WIDTH(27),	// floating point exception
-			fex:BIT_WIDTH(26),	// fp enabled exception
-			vx:BIT_WIDTH(25),	// fp invalid operation
-						//    exception
-			ox:BIT_WIDTH(24),	// fp overflow exception
-			rsvd:BITS_WIDTH(23,0);	// reserved
-} cr_t;
-
-/*
- * Abstract values representing fe0:fe1.
- * See get_fp_exc_mode(), below.
- */
-typedef enum {
-	FEM_IGNORE_EXCEP,	// ignore exceptions
-	FEM_IMPR_NONREC,	// imprecise nonrecoverable
-	FEM_IMPR_RECOV,		// imprecise recoverable
-	FEM_PRECISE
-} fp_exc_mode_t;
-
-
-/*
- * Special purpose registers.
- */
- 
-/*
- * Processor version register (special purpose register pvr).
- */
-typedef struct {
-	unsigned	version:BITS_WIDTH(31,16),	
-			revision:BITS_WIDTH(15,0);
-} pvr_t;
-
-/*
- * Fixed point exception register (special purpose register xer)
- */
-typedef struct {
-	unsigned	so:BIT_WIDTH(31),	// summary overflow
-			ov:BIT_WIDTH(30),	// overflow
-			ca:BIT_WIDTH(29),	// carry
-			rsvd1:BITS_WIDTH(28,7), // reserved
-			byte_count:BITS_WIDTH(6,0);	
-} xer_t;
-
-/*
- * Inlines and macros to manipulate the above registers.
- */
- 
-/*
- * Get/set machine state register.
- */
-static __inline__ msr_t
-get_msr()
-{
-	msr_t	__msr_tmp;	
-	__asm__ volatile ("mfmsr %0  /* mfmsr */" : "=r" (__msr_tmp));
-	return __msr_tmp;
-}
-
-static __inline__ void
-set_msr(msr_t msr)
-{
-	__asm__ volatile ("mtmsr %0 /* mtmsr */ " : : "r" (msr));	
-}
-
-/* 
- * Determine current fp_exc_mode_t given prog_mode.
- */
-static __inline__ fp_exc_mode_t
-get_fp_exc_mode(pmr_t pmr)
-{
-	if(pmr.fe0)
-		return pmr.fe1 ? FEM_PRECISE : FEM_IMPR_RECOV;
-	else
-		return pmr.fe1 ? FEM_IMPR_NONREC : FEM_IGNORE_EXCEP;
-}
-
-/*
- * Software definitions for special purpose registers.
- * The same register is used as per_cpu data pointer and
- * vector base register. This requires that the vector
- * table be the first item in the per_cpu table.
- */
-#define SR_EXCEPTION_TMP_LR	sprg0
-#define SR_EXCEPTION_TMP_CR	sprg1
-#define SR_EXCEPTION_TMP_AT	sprg2
-#define SR_PER_CPU_DATA		sprg3
-#define SR_VBR			sprg3
-
-/*
- * Get/set special purpose registers.
- *
- * GET_SPR - get SPR by name.
- *
- * Example usage:
- *
- *   {
- *	xer_t	some_xer;
- *
- *	some_xer = GET_SPR(xer_t, xer);
- *	...
- *   }
- *
- * This is a strange one. We're creating a list of C expressions within
- * a set of curlies; the last expression ("__spr_tmp;") is the return value
- * of the statement created by the curlies.
- *
- */
- 
-#define GET_SPR(type, spr)					\
-({								\
-	unsigned	__spr_tmp;				\
-	__asm__ volatile ("mfspr %0, " STRINGIFY(spr) : "=r" (__spr_tmp));				\
-	*(type *)&__spr_tmp;					\
-})
-
-/* 
- * Example usage of SET_SPR:
- *
- *   {
- *	xer_t some_xer;
- *
- *	...set up some_xer...
- *	SET_SPR(xer, some_xer);
- *   }
- */
-#define	SET_SPR(spr, val)					\
-MACRO_BEGIN							\
-	__typeof__ (val) __spr_tmp = (val);			\
-	__asm__ volatile ("mtspr "STRINGIFY(spr) ", %0" : : "r" (__spr_tmp));					\
-MACRO_END
-
-/*
- * Fully synchronize instruction stream.
- */
-static __inline__ void
-ppc_sync()
-{
-	__asm__ volatile ("sync         /* sync */" : : );
-}
-
-#endif /* ! __ASSEMBLER__ */
-
-#endif /* _ARCH_PPC_BASIC_REGS_H_ */
-
diff -Nur cctools-855-ld64-236.3/include/foreign/architecture/ppc/byte_order.h ../cctools-port.bak/cctools/include/foreign/architecture/ppc/byte_order.h
--- cctools-855-ld64-236.3/include/foreign/architecture/ppc/byte_order.h	2014-06-30 01:18:32.000000000 +0800
+++ ../cctools-port.bak/cctools/include/foreign/architecture/ppc/byte_order.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,28 +0,0 @@
-/*
- * Copyright (c) 1999-2002 Apple Computer, Inc. All rights reserved.
- *
- * @APPLE_LICENSE_HEADER_START@
- * 
- * This file contains Original Code and/or Modifications of Original Code
- * as defined in and that are subject to the Apple Public Source License
- * Version 2.0 (the 'License'). You may not use this file except in
- * compliance with the License. Please obtain a copy of the License at
- * http://www.opensource.apple.com/apsl/ and read it before using this
- * file.
- * 
- * The Original Code and all software distributed under the License are
- * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
- * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
- * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
- * Please see the License for the specific language governing rights and
- * limitations under the License.
- * 
- * @APPLE_LICENSE_HEADER_END@
- */
-
-/*
- * Maintain source compatibility
- */
-
-#include <architecture/byte_order.h>
diff -Nur cctools-855-ld64-236.3/include/foreign/architecture/ppc/cframe.h ../cctools-port.bak/cctools/include/foreign/architecture/ppc/cframe.h
--- cctools-855-ld64-236.3/include/foreign/architecture/ppc/cframe.h	2014-06-30 01:18:32.000000000 +0800
+++ ../cctools-port.bak/cctools/include/foreign/architecture/ppc/cframe.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,62 +0,0 @@
-/*
- * Copyright (c) 1999-2004 Apple Computer, Inc. All rights reserved.
- *
- * @APPLE_LICENSE_HEADER_START@
- * 
- * This file contains Original Code and/or Modifications of Original Code
- * as defined in and that are subject to the Apple Public Source License
- * Version 2.0 (the 'License'). You may not use this file except in
- * compliance with the License. Please obtain a copy of the License at
- * http://www.opensource.apple.com/apsl/ and read it before using this
- * file.
- * 
- * The Original Code and all software distributed under the License are
- * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
- * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
- * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
- * Please see the License for the specific language governing rights and
- * limitations under the License.
- * 
- * @APPLE_LICENSE_HEADER_END@
- */
-/* Copyright (c) 1991 NeXT Software, Inc.  All rights reserved.
- *
- *	File:	architecture/ppc/cframe.h
- *	Author:	Mike DeMoney, NeXT Software, Inc.
- *
- *	This include file defines C calling sequence defines
- *	for ppc port.
- *
- * HISTORY
- * 20-May-97  Umesh Vaishampayan  (umeshv@apple.com)
- *	Added C_RED_ZONE.
- * 29-Dec-96  Umesh Vaishampayan  (umeshv@NeXT.com)
- *	Ported from m98k.
- * 11-June-91  Mike DeMoney (mike@next.com)
- *	Created.
- */
-
-#ifndef	_ARCH_PPC_CFRAME_H_
-#define	_ARCH_PPC_CFRAME_H_
-
-/* Note that these values are copies of the somewhat more authoritative
- * values in <architecture/ppc/mode_independent_asm.h>.  We do not
- * include that file to avoid breaking legacy clients due to name
- * collisions.
- *
- * Note also that C_ARGSAVE_LEN isn't well defined or useful in PPC.
- * Most legacy uses of it are assuming it is the minimum stack frame
- * size, which is what we define it to be.
- */
-#if defined (__ppc64__)
-#define	C_ARGSAVE_LEN	64      /* "minimum arg save area" (but see above) */
-#define	C_STACK_ALIGN	32      /* stack must be 32 byte aligned */
-#define	C_RED_ZONE      320     /* 320 bytes to skip over saved registers */
-#else
-#define	C_ARGSAVE_LEN	32      /* "minimum arg save area" (but see above) */
-#define	C_STACK_ALIGN	16      /* stack must be 16 byte aligned */
-#define	C_RED_ZONE      224     /* 224 bytes to skip over saved registers */
-#endif
-
-#endif	/* _ARCH_PPC_CFRAME_H_ */
diff -Nur cctools-855-ld64-236.3/include/foreign/architecture/ppc/fenv.h ../cctools-port.bak/cctools/include/foreign/architecture/ppc/fenv.h
--- cctools-855-ld64-236.3/include/foreign/architecture/ppc/fenv.h	2014-06-30 01:18:32.000000000 +0800
+++ ../cctools-port.bak/cctools/include/foreign/architecture/ppc/fenv.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,179 +0,0 @@
-/*
- * Copyright (c) 2002 Apple Computer, Inc. All rights reserved.
- *
- * @APPLE_LICENSE_HEADER_START@
- * 
- * The contents of this file constitute Original Code as defined in and
- * are subject to the Apple Public Source License Version 1.1 (the
- * "License").  You may not use this file except in compliance with the
- * License.  Please obtain a copy of the License at
- * http://www.apple.com/publicsource and read it before using this file.
- * 
- * This Original Code and all software distributed under the License are
- * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
- * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
- * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
- * License for the specific language governing rights and limitations
- * under the License.
- * 
- * @APPLE_LICENSE_HEADER_END@
- */
- 
-/*******************************************************************************
-*                                                                              *
-*     File:  fenv.h	                                                       *
-*                                                                              *
-*     Contains: typedefs and prototypes for C99 floating point environment.    *
-*                                                                              *
-*******************************************************************************/
-
-#ifndef __FENV__
-#define __FENV__
-
-#if defined( __i386__ ) || defined( __x86_64__ )
-    #error  Wrong arch. This is PowerPC only.
-#endif
-
-#if defined(__GNUC__) && (__GNUC__ >= 4)   
-#pragma GCC fenv
-#endif
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/*
-    A collection of functions designed to provide access to the floating
-    point environment for numerical programming. It is modeled after
-    the floating-point requirements in C9X.
-    
-    The file <fenv.h> declares many functions in support of numerical
-    programming. Programs that test flags or run under
-    non-default modes must do so under the effect of an enabling
-    "fenv_access" pragma.
-*/
-
-/********************************************************************************
-*                                                                               *
-*    fenv_t         is a type for representing the entire floating-point        *
-*                   environment in a single object.                             *
-*                                                                               *
-*    fexcept_t      is a type for representing the floating-point               *
-*                   exception flag state collectively.                          *
-*                                                                               *
-********************************************************************************/
-typedef unsigned int			fenv_t;
-typedef unsigned int			fexcept_t;
-
-/*    Definitions of floating-point exception macros                          */
-#define FE_INEXACT      0x02000000
-#define FE_DIVBYZERO    0x04000000
-#define FE_UNDERFLOW    0x08000000
-#define FE_OVERFLOW     0x10000000
-#define FE_INVALID      0x20000000
-#define FE_ALL_EXCEPT   0x3E000000
-
-/*    Definitions of rounding direction macros                                */
-#define FE_TONEAREST    0x00000000
-#define FE_TOWARDZERO   0x00000001
-#define FE_UPWARD       0x00000002
-#define FE_DOWNWARD     0x00000003
-
-/* default environment object        */
-extern const fenv_t _FE_DFL_ENV;
-#define FE_DFL_ENV &_FE_DFL_ENV          /* pointer to default environment    */
-
-/*******************************************************************************
-*     The following functions provide access to the exception flags.  The      *
-*     "int" input argument can be constructed by bitwise ORs of the exception  *
-*     macros: for example: FE_OVERFLOW | FE_INEXACT.                           *
-*******************************************************************************/
-
-/*******************************************************************************
-*     The function "feclearexcept" clears the supported exceptions represented *
-*     by its argument.                                                         *
-*******************************************************************************/
-
-extern int  feclearexcept(int);
-
-
-/*******************************************************************************
-*    The function "fegetexceptflag" stores a representation of the exception   *
-*     flags indicated by its integer argument through the fexcept_t pointer    *
-*     argument.                                                                *
-*******************************************************************************/
-
-extern int  fegetexceptflag(fexcept_t *, int);
-
-
-/*******************************************************************************
-*     The function "feraiseexcept" raises the supported exceptions             *
-*     represented by its argument.                                             *
-*******************************************************************************/
-
-extern int  feraiseexcept(int);
-
-
-/*******************************************************************************
-*     The function "fesetexceptflag" sets or clears the exception flags indicated  *
-*     by the its integer argument according to the representation in the       *
-*     object pointed to by the fexcept_t pointer argument.  The value of the   *
-*     object must have been set by a previous call to "fegetexceptflag".       *
-*     This function does not raise exceptions; it just sets the state of       *
-*     the flags.                                                               *
-*******************************************************************************/
-
-extern int  fesetexceptflag(const fexcept_t *, int);
-
-
-/*******************************************************************************
-*     The function "fetestexcept" determines which of the specified subset of  *
-*     the exception flags are currently set.  The integer argument specifies   *
-*     the exception flags to be queried as a bitwise OR of the exception       *
-*     macros.  This function returns the bitwise OR of the exception macros    *
-*     corresponding to the currently set exceptions included in "excepts".     *
-*******************************************************************************/
-
-extern int  fetestexcept(int);
-
-
-/*******************************************************************************
-*     The following functions provide control of rounding direction modes.     *
-*******************************************************************************/
-
-/*******************************************************************************
-*     The function "fegetround" returns the value of the rounding direction    *
-*     macro which represents the current rounding direction.                   *
-*******************************************************************************/
-
-extern int  fegetround(void);
-
-
-/*******************************************************************************
-*     The function "fesetround" establishes the rounding direction represented *
-*     by its argument.  It returns zero if and only if the argument matches    *
-*     a rounding direction macro.  If not, the rounding direction is not       *
-*     changed.                                                                 *
-*******************************************************************************/
-
-extern int  fesetround(int);
-
-
-/*******************************************************************************
-*    The following functions manage the floating-point environment, exception  *
-*    flags and dynamic modes, as one entity.                                   *
-*******************************************************************************/
-
-extern int  fegetenv(fenv_t *);
-extern int   feholdexcept(fenv_t *);
-extern int  fesetenv(const fenv_t *);
-extern int  feupdateenv(const fenv_t *);
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* __FENV__ */
-
diff -Nur cctools-855-ld64-236.3/include/foreign/architecture/ppc/fp_regs.h ../cctools-port.bak/cctools/include/foreign/architecture/ppc/fp_regs.h
--- cctools-855-ld64-236.3/include/foreign/architecture/ppc/fp_regs.h	2014-06-30 01:18:32.000000000 +0800
+++ ../cctools-port.bak/cctools/include/foreign/architecture/ppc/fp_regs.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,148 +0,0 @@
-/*
- * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
- *
- * @APPLE_LICENSE_HEADER_START@
- * 
- * This file contains Original Code and/or Modifications of Original Code
- * as defined in and that are subject to the Apple Public Source License
- * Version 2.0 (the 'License'). You may not use this file except in
- * compliance with the License. Please obtain a copy of the License at
- * http://www.opensource.apple.com/apsl/ and read it before using this
- * file.
- * 
- * The Original Code and all software distributed under the License are
- * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
- * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
- * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
- * Please see the License for the specific language governing rights and
- * limitations under the License.
- * 
- * @APPLE_LICENSE_HEADER_END@
- */
-/* Copyright (c) 1996 NeXT Software, Inc.  All rights reserved.
- *
- *	File:	architecture/ppc/fp_regs.h
- *	Author:	Doug Mitchell, NeXT Software, Inc.
- *
- *	ppc floating point registers.
- *
- * HISTORY
- * 29-Dec-96  Umesh Vaishampayan  (umeshv@NeXT.com)
- *	Ported from m98k.
- * 05-Nov-92  Doug Mitchell at NeXT
- *	Created.
- */
-
-#ifndef _ARCH_PPC_FP_REGS_H_
-#define _ARCH_PPC_FP_REGS_H_
-
-#include <architecture/ppc/reg_help.h>
-
-#if !defined(__ASSEMBLER__)
-/*
- * Floating point status and control register.
- *
- * This struct is aligned to an 8-byte boundary because 64-bit
- * load/store instructions (lfd/stfd) are used to access it. The
- * FPSCR can only be read/written through other FP registers.
- */
-typedef struct {
-        unsigned        unused[1] __attribute__(( aligned(8) ));
-	unsigned	fx:BIT_WIDTH(31),	// exception summary
-			fex:BIT_WIDTH(30),	// enabled exception summary
-			vx:BIT_WIDTH(29),	// invalid op exception
-						//    summary
-			ox:BIT_WIDTH(28),	// overflow exception
-			ux:BIT_WIDTH(27),	// underflow exception
-			zx:BIT_WIDTH(26),	// divide by zero exception
-			xx:BIT_WIDTH(25),	// inexact exception
-			vx_snan:BIT_WIDTH(24),	// not a number exception
-			vx_isi:BIT_WIDTH(23),	// exception
-			vx_idi:BIT_WIDTH(22),	// exception
-			vx_zdz:BIT_WIDTH(21),	// exception
-			vx_imz:BIT_WIDTH(20),	// exception
-			vx_xvc:BIT_WIDTH(19),	// exception
-			fr:BIT_WIDTH(18),	// fraction rounded
-			fi:BIT_WIDTH(17),	// fraction inexact
-			class:BIT_WIDTH(16),	// class descriptor
-			fl:BIT_WIDTH(15),	// negative
-			fg:BIT_WIDTH(14),	// positive
-			fe:BIT_WIDTH(13),	// equal or zero
-			fu:BIT_WIDTH(12),	// not a number
-			rsvd1:BIT_WIDTH(11),	// reserved
-			vx_soft:BIT_WIDTH(10),	// software request exception
-			rsvd2:BIT_WIDTH(9),	// reserved
-			vx_cvi:BIT_WIDTH(8),	// invalid integer convert
-						//    exception
-			ve:BIT_WIDTH(7),	// invalid op exception enable
-			oe:BIT_WIDTH(6),	// overflow exception enable
-			ue:BIT_WIDTH(5),	// underflow exception enable
-			ze:BIT_WIDTH(4),	// divide by zero exception
-						//    enable
-			xe:BIT_WIDTH(3),	// inexact exception enable
-			ni:BIT_WIDTH(2),	// non-IEEE exception enable
-			rn:BITS_WIDTH(1,0);	// rounding control
-} ppc_fp_scr_t;
-
-/*
- * Values for fp_scr_t.rn (rounding control).
- */
-typedef enum {
-	RN_NEAREST = 0,
-	RN_TOWARD_ZERO = 1,
-	RN_TOWARD_PLUS = 2,
-	RN_TOWARD_MINUS = 3
-} ppc_fp_rn_t;
-
-/*
- * ppc_fpf_t -- data types that MAY be in floating point register file
- * Actual data types supported is implementation dependent
- */
-typedef union {
-        float           f;              // 32 bit IEEE single
-        double          d;              // 64 bit IEEE double
-     
-        /* 
-	 * Insure compiler aligns struct appropriately 
-	 */
-        unsigned        x[2] __attribute__(( aligned(8) ));
-} ppc_fpf_t;
-
-/*
- * Number of FP registers.
- */
-#define PPC_NFP_REGS	32
-
-/*
- * Read/write FPSCR.
- * FIXME - these don't work, you need to go thru a fp register.
- */
-typedef union {
-	double 		__dbl;
-	ppc_fp_scr_t 	__scr;
-} __fp_un_t;
-
-static __inline__ ppc_fp_scr_t
-get_fp_scr()
-{
-	__fp_un_t 	__fp_un;
-	
-	__asm__ volatile ("mffs. %0           /* mffs */"	\
-	  	: "=f" (__fp_un.__dbl));
-	return (__fp_un.__scr);		
-}
-
-static __inline__ void
-set_fp_scr(ppc_fp_scr_t fp_scr)
-{
-	__fp_un_t 	__fp_un;
-
-	__fp_un.__scr = fp_scr;
-	__asm__ volatile ("mtfsf 0xff, %0;    /* mtfsf */ "	\
-	  : : "f" (__fp_un.__dbl));	
-}
-
-#endif /* ! __ASSEMBLER__ */
-
-#endif /* _ARCH_PPC_FP_REGS_H_ */
diff -Nur cctools-855-ld64-236.3/include/foreign/architecture/ppc/macro_help.h ../cctools-port.bak/cctools/include/foreign/architecture/ppc/macro_help.h
--- cctools-855-ld64-236.3/include/foreign/architecture/ppc/macro_help.h	2014-06-30 01:18:32.000000000 +0800
+++ ../cctools-port.bak/cctools/include/foreign/architecture/ppc/macro_help.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,59 +0,0 @@
-/*
- * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
- *
- * @APPLE_LICENSE_HEADER_START@
- * 
- * This file contains Original Code and/or Modifications of Original Code
- * as defined in and that are subject to the Apple Public Source License
- * Version 2.0 (the 'License'). You may not use this file except in
- * compliance with the License. Please obtain a copy of the License at
- * http://www.opensource.apple.com/apsl/ and read it before using this
- * file.
- * 
- * The Original Code and all software distributed under the License are
- * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
- * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
- * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
- * Please see the License for the specific language governing rights and
- * limitations under the License.
- * 
- * @APPLE_LICENSE_HEADER_END@
- */
-/*
- * Copyright (c) 1996 NeXT Software, Inc.
- */
-/* 
- * Mach Operating System
- * Copyright (c) 1989 Carnegie-Mellon University
- * Copyright (c) 1988 Carnegie-Mellon University
- * All rights reserved.  The CMU software License Agreement specifies
- * the terms and conditions for use and redistribution.
- *
- *	File:	architecture/ppc/macro_help.h
- *
- *	Provide help in making lint-free macro routines
- *
- * HISTORY
- *
- *	29-Dec-96  Umesh Vaishampayan  (umeshv@NeXT.com)
- *		Created from m98k version. 
- */
-
-#ifndef	_ARCH_PPC_MACRO_HELP_H_
-#define	_ARCH_PPC_MACRO_HELP_H_
-
-#ifndef	MACRO_BEGIN
-# define		MACRO_BEGIN	do {
-#endif	/* MACRO_BEGIN */
-
-#ifndef	MACRO_END
-# define		MACRO_END	} while (0)
-#endif	/* MACRO_END */
-
-#ifndef	MACRO_RETURN
-# define		MACRO_RETURN	if (1) return
-#endif	/* MACRO_RETURN */
-
-#endif	/* _ARCH_PPC_MACRO_HELP_H_ */
-
diff -Nur cctools-855-ld64-236.3/include/foreign/architecture/ppc/math.h ../cctools-port.bak/cctools/include/foreign/architecture/ppc/math.h
--- cctools-855-ld64-236.3/include/foreign/architecture/ppc/math.h	2014-06-30 01:18:32.000000000 +0800
+++ ../cctools-port.bak/cctools/include/foreign/architecture/ppc/math.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,883 +0,0 @@
-/*
- * Copyright (c) 2002 Apple Computer, Inc. All rights reserved.
- *
- * @APPLE_LICENSE_HEADER_START@
- * 
- * The contents of this file constitute Original Code as defined in and
- * are subject to the Apple Public Source License Version 1.1 (the
- * "License").  You may not use this file except in compliance with the
- * License.  Please obtain a copy of the License at
- * http://www.apple.com/publicsource and read it before using this file.
- * 
- * This Original Code and all software distributed under the License are
- * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
- * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
- * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
- * License for the specific language governing rights and limitations
- * under the License.
- * 
- * @APPLE_LICENSE_HEADER_END@
- */
- 
-/*******************************************************************************
-*                                                                              *
-*     File:  math.h	                                                       *
-*                                                                              *
-*     Contains: typedefs, prototypes, and macros germane to C99 floating point.*
-*                                                                              *
-*******************************************************************************/
-#ifndef __MATH__
-#define __MATH__
-
-#include "sys/cdefs.h" /* For definition of __DARWIN_UNIX03 et al */
-
-#if (!defined(__WANT_LONG_DOUBLE_FORMAT__))
-#if defined(__APPLE_CC__) && defined(__LONG_DOUBLE_128__)
-#define __WANT_LONG_DOUBLE_FORMAT__ 128
-#else
-#define __WANT_LONG_DOUBLE_FORMAT__ 64
-#endif
-#endif
-
-#if ( __WANT_LONG_DOUBLE_FORMAT__ - 0L == 128L )
-#define __LIBMLDBL_COMPAT(sym) __asm("_" __STRING(sym) "$LDBL128")
-#elif ( __WANT_LONG_DOUBLE_FORMAT__ - 0L == 64L )
-#define __LIBMLDBL_COMPAT(sym) /* NOTHING */
-#else
-#define __LIBMLDBL_COMPAT(sym) /* NOTHING */
-#endif
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/******************************************************************************
-*       Floating point data types                                             *
-******************************************************************************/
-
-/*	Define float_t and double_t per C standard, ISO/IEC 9899:1999 7.12 2,
-	taking advantage of GCC's __FLT_EVAL_METHOD__ (which a compiler may
-	define anytime and GCC does) that shadows FLT_EVAL_METHOD (which a compiler
-	must and may define only in float.h).
-*/
-#if __FLT_EVAL_METHOD__ == 0
-	typedef float float_t;
-	typedef double double_t;
-#elif __FLT_EVAL_METHOD__ == 1
-	typedef double float_t;
-	typedef double double_t;
-#elif __FLT_EVAL_METHOD__ == 2 || __FLT_EVAL_METHOD__ == -1
-	typedef long double float_t;
-	typedef long double double_t;
-#else /* __FLT_EVAL_METHOD__ */
-	#error "Unsupported value of __FLT_EVAL_METHOD__."
-#endif /* __FLT_EVAL_METHOD__ */
-
-
-#if defined(__GNUC__) && ! defined( __XLC__ )
-	#define	HUGE_VAL	__builtin_huge_val()
-	#define	HUGE_VALF	__builtin_huge_valf()
-	#define	HUGE_VALL	__builtin_huge_vall()
-	#define NAN			__builtin_nanf("0x7fc00000") /* Constant expression, can be used as initializer. */
-	#define __MATH_H_ALWAYS_INLINE__		__attribute__ ((always_inline))
-#else
-	#define	HUGE_VAL	1e500
-	#define	HUGE_VALF	1e50f
-	#define	HUGE_VALL	1e500L
-	#define NAN		__nan( )
-	#define __MATH_H_ALWAYS_INLINE__
-#endif
-
-#define INFINITY	HUGE_VALF
-
-/******************************************************************************
-*      Taxonomy of floating point data types                                  *
-******************************************************************************/
-
-#define FP_NAN          1
-#define FP_INFINITE     2
-#define FP_ZERO         3
-#define FP_NORMAL       4
-#define FP_SUBNORMAL    5
-#define FP_SUPERNORMAL  6
-
-/* fma() *function call* is more costly than equivalent (in-line) multiply and add operations */
-#undef FP_FAST_FMA
-#undef FP_FAST_FMAF
-#undef FP_FAST_FMAL
-
-/* The values returned by `ilogb' for 0 and NaN respectively.  */
-#define FP_ILOGB0	(-2147483647)
-#define FP_ILOGBNAN	(2147483647)
-
-/* Bitmasks for the math_errhandling macro.  */
-#define MATH_ERRNO		1	/* errno set by math functions.  */
-#define MATH_ERREXCEPT	2	/* Exceptions raised by math functions.  */
-
-#define math_errhandling (__math_errhandling())
-extern unsigned int __math_errhandling ( void );
-
-/********************************************************************************
-*                                                                               *
-*                              Inquiry macros                                   *
-*                                                                               *
-*   fpclassify      Returns one of the FP_≈ values.                             *
-*   isnormal        Non-zero if and only if the argument x is normalized.       *
-*   isfinite        Non-zero if and only if the argument x is finite.           *
-*   isnan           Non-zero if and only if the argument x is a NaN.            *
-*   signbit         Non-zero if and only if the sign of the argument x is       *
-*                   negative.  This includes, NaNs, infinities and zeros.       *
-*                                                                               *
-********************************************************************************/
-
-#if (__WANT_LONG_DOUBLE_FORMAT__ - 0L == 128L)
-	#define fpclassify(x)	\
-		(	sizeof (x) == sizeof(float )	?	__fpclassifyf((float)x)	\
-		:	sizeof (x) == sizeof(double)	?	__fpclassifyd((double)x)	\
-											:	__fpclassify ((long double)x))
-
-	extern int __fpclassifyf(float      );
-	extern int __fpclassifyd(double     );
-	extern int __fpclassify (long double);
-
-	#if defined( __GNUC__ ) && ! defined( __XLC__ ) && 0 == __FINITE_MATH_ONLY__
-    /*  Yes, that's right. You only get the fast iswhatever() macros if you do NOT turn on -ffast-math.  */
-    /*  These inline functions require the compiler to be compiling to standard in order to work.        */
-    /*  -ffast-math, among other things, implies that NaNs don't happen. The compiler can in that case   */
-    /*  optimize x != x to be false always, wheras it would be true for NaNs. That breaks __inline_isnan() */
-    /*  below.                                                                                           */
-
-		#define isnormal(x)	\
-			(	sizeof (x) == sizeof(float )	?	__inline_isnormalf((float)(x))	\
-			:	sizeof (x) == sizeof(double)	?	__inline_isnormald((double)(x))	\
-												:	__inline_isnormal ((long double)(x)))
-
-		#define isfinite(x)	\
-			(	sizeof (x) == sizeof(float )	?	__inline_isfinitef((float)(x))	\
-			:	sizeof (x) == sizeof(double)	?	__inline_isfinited((double)(x))	\
-												:	__inline_isfinite ((long double)(x)))
-
-		#define isinf(x)	\
-			(	sizeof (x) == sizeof(float )	?	__inline_isinff((float)(x))	\
-			:	sizeof (x) == sizeof(double)	?	__inline_isinfd((double)(x))	\
-												:	__inline_isinf ((long double)(x)))
-
-		#define isnan(x)	\
-			(	sizeof (x) == sizeof(float )	?	__inline_isnanf((float)(x))	\
-			:	sizeof (x) == sizeof(double)	?	__inline_isnand((double)(x))	\
-												:	__inline_isnan ((long double)(x)))
-
-		#define signbit(x)	\
-			(	sizeof (x) == sizeof(float )	?	__inline_signbitf((float)(x))	\
-			:	sizeof (x) == sizeof(double)	?	__inline_signbitd((double)(x))	\
-												:	__inline_signbit((long double)(x)))
-
-        /* Developers who are calling __isnan, __isnormal, __isinf, etc. and now encountering errors are calling private APIs       */ 
-        /* that are deprecated.  Please use the official C99 sanctioned macros listed above instead.                                */
-
-		static __inline__ int __inline_isfinitef	(float      ) __MATH_H_ALWAYS_INLINE__;
-		static __inline__ int __inline_isfinited	(double     ) __MATH_H_ALWAYS_INLINE__;
-		static __inline__ int __inline_isfinite		(long double) __MATH_H_ALWAYS_INLINE__;
-		static __inline__ int __inline_isinff		(float      ) __MATH_H_ALWAYS_INLINE__;
-		static __inline__ int __inline_isinfd		(double     ) __MATH_H_ALWAYS_INLINE__;
-		static __inline__ int __inline_isinf		(long double) __MATH_H_ALWAYS_INLINE__;
-		static __inline__ int __inline_isnanf		(float      ) __MATH_H_ALWAYS_INLINE__;
-		static __inline__ int __inline_isnand		(double     ) __MATH_H_ALWAYS_INLINE__;
-		static __inline__ int __inline_isnan		(long double) __MATH_H_ALWAYS_INLINE__;
-		static __inline__ int __inline_isnormalf    (float      ) __MATH_H_ALWAYS_INLINE__;
-		static __inline__ int __inline_isnormald    (double     ) __MATH_H_ALWAYS_INLINE__;
-		static __inline__ int __inline_isnormal     (long double) __MATH_H_ALWAYS_INLINE__;
-		static __inline__ int __inline_signbitf     (float      ) __MATH_H_ALWAYS_INLINE__;
-		static __inline__ int __inline_signbitd     (double     ) __MATH_H_ALWAYS_INLINE__;
-		static __inline__ int __inline_signbit      (long double) __MATH_H_ALWAYS_INLINE__;
-		
-		static __inline__ int __inline_isinff( float __x ) { return __builtin_fabsf(__x) == __builtin_inff(); }
-		static __inline__ int __inline_isinfd( double __x ) { return __builtin_fabs(__x) == __builtin_inf(); }
-		static __inline__ int __inline_isinf( long double __x ) { return __builtin_fabsl(__x) == __builtin_infl(); }
-		static __inline__ int __inline_isfinitef( float __x ) { return __x == __x && __builtin_fabsf(__x) != __builtin_inff(); }
-		static __inline__ int __inline_isfinited( double __x ) { return __x == __x && __builtin_fabs(__x) != __builtin_inf(); }
-		static __inline__ int __inline_isfinite( long double __x ) { return __x == __x && __builtin_fabsl(__x) != __builtin_infl(); }
-		static __inline__ int __inline_isnanf( float __x ) { return __x != __x; }
-		static __inline__ int __inline_isnand( double __x ) { return __x != __x; }
-		static __inline__ int __inline_isnan( long double __x ) { return __x != __x; }
-		static __inline__ int __inline_signbitf( float __x ) { union{ float __f; unsigned int __u; }__u; __u.__f = __x; return (int)(__u.__u >> 31); }
-		static __inline__ int __inline_signbitd( double __x ) { union{ double __f; unsigned long __u; }__u; __u.__f = __x; return (int)(__u.__u >> ( 8 * sizeof( __u.__u) - 1)); }
-		static __inline__ int __inline_signbit( long double __x ){ union{ long double __ld; unsigned long __p; }__u; __u.__ld = __x; return (int) (__u.__p >> ( 8 * sizeof( __u.__p) - 1)); } 
-		static __inline__ int __inline_isnormalf( float __x ) { float fabsf = __builtin_fabsf(__x); if( __x != __x ) return 0; return fabsf < __builtin_inff() && fabsf >= __FLT_MIN__; }  
-		static __inline__ int __inline_isnormald( double __x ) { double fabsf = __builtin_fabs(__x); if( __x != __x ) return 0; return fabsf < __builtin_inf() && fabsf >= __DBL_MIN__; }  
-		static __inline__ int __inline_isnormal( long double __x ) { long double fabsf = __builtin_fabsl(__x); if( __x != __x ) return 0; return fabsf < __builtin_infl() && fabsf >= __LDBL_MIN__; }  
-		
-	#else
-
-		#define isnormal(x)	\
-			(	sizeof (x) == sizeof(float )	?	__isnormalf((float)(x))	\
-			:	sizeof (x) == sizeof(double)	?	__isnormald((double)(x))	\
-												:	__isnormal ((long double)(x)))
-
-		#define isfinite(x)	\
-			(	sizeof (x) == sizeof(float )	?	__isfinitef((float)(x))	\
-			:	sizeof (x) == sizeof(double)	?	__isfinited((double)(x))	\
-												:	__isfinite ((long double)(x)))
-
-		#define isinf(x)	\
-			(	sizeof (x) == sizeof(float )	?	__isinff((float)(x))	\
-			:	sizeof (x) == sizeof(double)	?	__isinfd((double)(x))	\
-												:	__isinf ((long double)(x)))
-
-		#define isnan(x)	\
-			(	sizeof (x) == sizeof(float )	?	__isnanf((float)(x))	\
-			:	sizeof (x) == sizeof(double)	?	__isnand((double)(x))	\
-												:	__isnan ((long double)(x)))
-
-		#define signbit(x)	\
-			(	sizeof (x) == sizeof(float )	?	__signbitf((float)(x))	\
-			:	sizeof (x) == sizeof(double)	?	__signbitd((double)(x))	\
-												:	__signbitl((long double)(x)))
-
-
-		extern int __isnormalf  (float      );
-		extern int __isnormald  (double     );
-		extern int __isnormal   (long double);
-
-		extern int __isfinitef  (float      );
-		extern int __isfinited  (double     );
-		extern int __isfinite   (long double);
-
-		extern int __isinff     (float      );
-		extern int __isinfd     (double     );
-		extern int __isinf      (long double);
-
-		extern int __isnanf     (float      );
-		extern int __isnand     (double     );
-		extern int __isnan      (long double);
-
-		extern int __signbitf   (float      );
-		extern int __signbitd   (double     );
-		extern int __signbitl   (long double);
-
-	#endif
-
-#else
-	#define fpclassify(x)	\
-		(	sizeof (x) == sizeof(float )	?	__fpclassifyf((float)(x))	:	__fpclassifyd((double)(x))	)
-
-	extern int __fpclassifyf(float      );
-	extern int __fpclassifyd(double     );
-
-	#if defined( __GNUC__ ) && ! defined( __XLC__ ) && 0 == __FINITE_MATH_ONLY__
-    /*  Yes, that's right. You only get the fast iswhatever() macros if you do NOT turn on -ffast-math.  */
-    /*  These inline functions require the compiler to be compiling to standard in order to work.        */
-    /*  -ffast-math, among other things, implies that NaNs don't happen. The compiler can in that case   */
-    /*  optimize x != x to be false always, wheras it would be true for NaNs. That breaks __inline_isnan() */
-    /*  below.                                                                                           */
-		#define isnormal(x)	\
-			(	sizeof (x) == sizeof(float )	?	__inline_isnormalf((float)(x))	:	__inline_isnormald((double)(x))	)
-
-		#define isfinite(x)	\
-			(	sizeof (x) == sizeof(float )	?	__inline_isfinitef((float)(x))	:	__inline_isfinited((double)(x))	)
-
-		#define isinf(x)	\
-			(	sizeof (x) == sizeof(float )	?	__inline_isinff((float)(x))		:	__inline_isinfd((double)(x))	)
-
-		#define isnan(x)	\
-			(	sizeof (x) == sizeof(float )	?	__inline_isnanf((float)(x))		:	__inline_isnand((double)(x))	)
-
-		#define signbit(x)	\
-			(	sizeof (x) == sizeof(float )	?	__inline_signbitf((float)(x))	:	__inline_signbitd((double)(x))	)
-
-        /* Developers who are calling __isnan, __isnormal, __isinf, etc. and now encountering errors are calling private APIs           */ 
-        /* that are deprecated.  Please use the official C99 sanctioned macros listed above instead.                                    */
-
-		static __inline__ int __inline_isfinitef	(float      ) __MATH_H_ALWAYS_INLINE__;
-		static __inline__ int __inline_isfinited	(double     ) __MATH_H_ALWAYS_INLINE__;
-		static __inline__ int __inline_isfinite		(long double) __MATH_H_ALWAYS_INLINE__;
-		static __inline__ int __inline_isinff		(float      ) __MATH_H_ALWAYS_INLINE__;
-		static __inline__ int __inline_isinfd		(double     ) __MATH_H_ALWAYS_INLINE__;
-		static __inline__ int __inline_isinf		(long double) __MATH_H_ALWAYS_INLINE__;
-		static __inline__ int __inline_isnanf		(float      ) __MATH_H_ALWAYS_INLINE__;
-		static __inline__ int __inline_isnand		(double     ) __MATH_H_ALWAYS_INLINE__;
-		static __inline__ int __inline_isnan		(long double) __MATH_H_ALWAYS_INLINE__;
-		static __inline__ int __inline_isnormalf    (float      ) __MATH_H_ALWAYS_INLINE__;
-		static __inline__ int __inline_isnormald    (double     ) __MATH_H_ALWAYS_INLINE__;
-		static __inline__ int __inline_isnormal     (long double) __MATH_H_ALWAYS_INLINE__;
-		static __inline__ int __inline_signbitf     (float      ) __MATH_H_ALWAYS_INLINE__;
-		static __inline__ int __inline_signbitd     (double     ) __MATH_H_ALWAYS_INLINE__;
-		static __inline__ int __inline_signbit      (long double) __MATH_H_ALWAYS_INLINE__;
-		
-		static __inline__ int __inline_isinff( float __x ) { return __builtin_fabsf(__x) == __builtin_inff(); }
-		static __inline__ int __inline_isinfd( double __x ) { return __builtin_fabs(__x) == __builtin_inf(); }
-		static __inline__ int __inline_isinf( long double __x ) { return __builtin_fabsl(__x) == __builtin_infl(); }
-		static __inline__ int __inline_isfinitef( float __x ) { return __x == __x && __builtin_fabsf(__x) != __builtin_inff(); }
-		static __inline__ int __inline_isfinited( double __x ) { return __x == __x && __builtin_fabs(__x) != __builtin_inf(); }
-		static __inline__ int __inline_isfinite( long double __x ) { return __x == __x && __builtin_fabsl(__x) != __builtin_infl(); }
-		static __inline__ int __inline_isnanf( float __x ) { return __x != __x; }
-		static __inline__ int __inline_isnand( double __x ) { return __x != __x; }
-		static __inline__ int __inline_isnan( long double __x ) { return __x != __x; }
-		static __inline__ int __inline_signbitf( float __x ) { union{ float __f; unsigned int __u; }__u; __u.__f = __x; return (int)(__u.__u >> 31); }
-		static __inline__ int __inline_signbitd( double __x ) { union{ double __f; unsigned long __u; }__u; __u.__f = __x; return (int)(__u.__u >> ( 8 * sizeof( __u.__u) - 1)); }
-		static __inline__ int __inline_signbit( long double __x ){ union{ long double __ld; unsigned long __p; }__u; __u.__ld = __x; return (int) (__u.__p >> ( 8 * sizeof( __u.__p) - 1)); } 
-		static __inline__ int __inline_isnormalf( float __x ) { float fabsf = __builtin_fabsf(__x); if( __x != __x ) return 0; return fabsf < __builtin_inff() && fabsf >= __FLT_MIN__; }  
-		static __inline__ int __inline_isnormald( double __x ) { double fabsf = __builtin_fabs(__x); if( __x != __x ) return 0; return fabsf < __builtin_inf() && fabsf >= __DBL_MIN__; }  
-		static __inline__ int __inline_isnormal( long double __x ) { long double fabsf = __builtin_fabsl(__x); if( __x != __x ) return 0; return fabsf < __builtin_infl() && fabsf >= __LDBL_MIN__; }  
-		
-	#else
-
-		#define isnormal(x)	\
-			(	sizeof (x) == sizeof(float )	?	__isnormalf((float)(x))	:	__isnormald((double)(x))	)
-
-		#define isfinite(x)	\
-			(	sizeof (x) == sizeof(float )	?	__isfinitef((float)(x))	:	__isfinited((double)(x))	)
-
-		#define isinf(x)	\
-			(	sizeof (x) == sizeof(float )	?	__isinff((float)(x))	:	__isinfd((double)(x))		)
-
-		#define isnan(x)	\
-			(	sizeof (x) == sizeof(float )	?	__isnanf((float)(x))	:	__isnand((double)(x))		)
-
-		#define signbit(x)	\
-			(	sizeof (x) == sizeof(float )	?	__signbitf((float)(x))	:	__signbitd((double)(x))		)
-
-
-		extern int __isnormalf  (float      );
-		extern int __isnormald  (double     );
-
-		extern int __isfinitef  (float      );
-		extern int __isfinited  (double     );
-
-		extern int __isinff     (float      );
-		extern int __isinfd     (double     );
-
-		extern int __isnanf     (float      );
-		extern int __isnand     (double     );
-
-		extern int __signbitf   (float      );
-		extern int __signbitd   (double     );
-
-	#endif
-							  
-#endif /* __WANT_LONG_DOUBLE_FORMAT__ */
-                              
-
-/********************************************************************************
-*                                                                               *
-*                              Math Functions                                   *
-*                                                                               *
-********************************************************************************/
-
-extern double acos( double );
-extern float acosf( float );
-
-extern double asin( double );
-extern float asinf( float );
-
-extern double atan( double );
-extern float atanf( float );
-
-extern double atan2( double, double );
-extern float atan2f( float, float );
-
-extern double cos( double );
-extern float cosf( float );
-
-extern double sin( double );
-extern float sinf( float );
-
-extern double tan( double );
-extern float tanf( float );
-
-extern double acosh( double );
-extern float acoshf( float );
-
-extern double asinh( double );
-extern float asinhf( float );
-
-extern double atanh( double );
-extern float atanhf( float );
-
-extern double cosh( double );
-extern float coshf( float );
-
-extern double sinh( double );
-extern float sinhf( float );
-
-extern double tanh( double );
-extern float tanhf( float );
-
-extern double exp( double );
-extern float expf( float );
-
-extern double exp2( double );
-extern float exp2f( float );
-
-extern double expm1( double );
-extern float expm1f( float );
-
-extern double log( double );
-extern float logf( float );
-
-extern double log10( double );
-extern float log10f( float );
-
-extern double log2( double );
-extern float log2f( float );
-
-extern double log1p( double );
-extern float log1pf( float );
-
-extern double logb( double );
-extern float logbf( float );
-
-extern double modf( double, double * );
-extern float modff( float, float * );
-
-extern double ldexp( double, int );
-extern float ldexpf( float, int );
-
-extern double frexp( double, int * );
-extern float frexpf( float, int * );
-
-extern int ilogb( double );
-extern int ilogbf( float );
-
-extern double scalbn( double, int );
-extern float scalbnf( float, int );
-
-extern double scalbln( double, long int );
-extern float scalblnf( float, long int );
-
-extern double fabs( double );
-extern float fabsf( float );
-
-extern double cbrt( double );
-extern float cbrtf( float );
-
-extern double hypot( double, double );
-extern float hypotf( float, float );
-
-extern double pow( double, double );
-extern float powf( float, float );
-
-extern double sqrt( double );
-extern float sqrtf( float );
-
-extern double erf( double );
-extern float erff( float );
-
-extern double erfc( double );
-extern float erfcf( float );
-
-extern double lgamma( double );
-extern float lgammaf( float );
-
-extern double tgamma( double );
-extern float tgammaf( float );
-
-extern double ceil( double );
-extern float ceilf( float );
-
-extern double floor( double );
-extern float floorf( float );
-
-extern double nearbyint( double );
-extern float nearbyintf( float );
-
-extern double rint( double );
-extern float rintf( float );
-
-extern long int lrint( double );
-extern long int lrintf( float );
-
-extern double round( double );
-extern float roundf( float );
-
-extern long int lround( double );
-extern long int lroundf( float );
-
-#if ( defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L ) || ! defined( __STRICT_ANSI__ )  || ! defined( __GNUC__ )
-    /* C90 doesn't know about long long. Make sure you are passing -std=c99 or -std=gnu99 or better if you need this. */
-    extern long long int llrint( double );
-    extern long long int llrintf( float );
-
-    extern long long int llround( double );
-    extern long long int llroundf( float );
-#endif /*#if ( defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L ) || ! defined( __STRICT_ANSI__ )  || ! defined( __GNUC__ )  */
-
-extern double trunc( double );
-extern float truncf( float );
-
-extern double fmod( double, double );
-extern float fmodf( float, float );
-
-extern double remainder( double, double );
-extern float remainderf( float, float );
-
-extern double remquo( double, double, int * );
-extern float remquof( float, float, int * );
-
-extern double copysign( double, double );
-extern float copysignf( float, float );
-
-extern double nan( const char * );
-extern float nanf( const char * );
-
-extern double nextafter( double, double );
-extern float nextafterf( float, float );
-
-
-extern double fdim( double, double );
-extern float fdimf( float, float );
-
-extern double fmax( double, double );
-extern float fmaxf( float, float );
-
-extern double fmin( double, double );
-extern float fminf( float, float );
-
-extern double fma( double, double, double );
-extern float fmaf( float, float, float );
-
-#if ( __WANT_LONG_DOUBLE_FORMAT__ - 0L > 0L ) 
-extern long double acosl( long double ) __LIBMLDBL_COMPAT(acosl);
-extern long double asinl( long double ) __LIBMLDBL_COMPAT(asinl);
-extern long double atanl( long double ) __LIBMLDBL_COMPAT(atanl);
-extern long double atan2l( long double, long double ) __LIBMLDBL_COMPAT(atan2l);
-extern long double cosl( long double ) __LIBMLDBL_COMPAT(cosl);
-extern long double sinl( long double ) __LIBMLDBL_COMPAT(sinl);
-extern long double tanl( long double ) __LIBMLDBL_COMPAT(tanl);
-extern long double acoshl( long double ) __LIBMLDBL_COMPAT(acoshl);
-extern long double asinhl( long double ) __LIBMLDBL_COMPAT(asinhl);
-extern long double atanhl( long double ) __LIBMLDBL_COMPAT(atanhl);
-extern long double coshl( long double ) __LIBMLDBL_COMPAT(coshl);
-extern long double sinhl( long double ) __LIBMLDBL_COMPAT(sinhl);
-extern long double tanhl( long double ) __LIBMLDBL_COMPAT(tanhl);
-extern long double expl( long double ) __LIBMLDBL_COMPAT(expl);
-extern long double exp2l( long double ) __LIBMLDBL_COMPAT(exp2l);
-extern long double expm1l( long double ) __LIBMLDBL_COMPAT(expm1l);
-extern long double logl( long double ) __LIBMLDBL_COMPAT(logl);
-extern long double log10l( long double ) __LIBMLDBL_COMPAT(log10l);
-extern long double log2l( long double ) __LIBMLDBL_COMPAT(log2l);
-extern long double log1pl( long double ) __LIBMLDBL_COMPAT(log1pl);
-extern long double logbl( long double ) __LIBMLDBL_COMPAT(logbl);
-extern long double modfl( long double, long double * ) __LIBMLDBL_COMPAT(modfl);
-extern long double ldexpl( long double, int ) __LIBMLDBL_COMPAT(ldexpl);
-extern long double frexpl( long double, int * ) __LIBMLDBL_COMPAT(frexpl);
-extern int ilogbl( long double ) __LIBMLDBL_COMPAT(ilogbl);
-extern long double scalbnl( long double, int ) __LIBMLDBL_COMPAT(scalbnl);
-extern long double scalblnl( long double, long int ) __LIBMLDBL_COMPAT(scalblnl);
-extern long double fabsl( long double ) __LIBMLDBL_COMPAT(fabsl);
-extern long double cbrtl( long double ) __LIBMLDBL_COMPAT(cbrtl);
-extern long double hypotl( long double, long double ) __LIBMLDBL_COMPAT(hypotl);
-extern long double powl( long double, long double ) __LIBMLDBL_COMPAT(powl);
-extern long double sqrtl( long double ) __LIBMLDBL_COMPAT(sqrtl);
-extern long double erfl( long double ) __LIBMLDBL_COMPAT(erfl);
-extern long double erfcl( long double ) __LIBMLDBL_COMPAT(erfcl);
-extern long double lgammal( long double ) __LIBMLDBL_COMPAT(lgammal);
-extern long double tgammal( long double ) __LIBMLDBL_COMPAT(tgammal);
-extern long double ceill( long double ) __LIBMLDBL_COMPAT(ceill);
-extern long double floorl( long double ) __LIBMLDBL_COMPAT(floorl);
-extern long double nearbyintl( long double ) __LIBMLDBL_COMPAT(nearbyintl);
-extern long double rintl( long double ) __LIBMLDBL_COMPAT(rintl);
-extern long int lrintl( long double ) __LIBMLDBL_COMPAT(lrintl);
-extern long double roundl( long double ) __LIBMLDBL_COMPAT(roundl);
-extern long int lroundl( long double ) __LIBMLDBL_COMPAT(lroundl);
-
-#if ( defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L ) || ! defined( __STRICT_ANSI__ ) || ! defined( __GNUC__ )
-        /* C90 doesn't know about long long. Make sure you are passing -std=c99 or -std=gnu99 or better if you need this. */
-    extern long long int llrintl( long double ) __LIBMLDBL_COMPAT(llrintl);
-    extern long long int llroundl( long double ) __LIBMLDBL_COMPAT(llroundl);
-#endif /* #if ( defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L ) || ! defined( __STRICT_ANSI__ )  || ! defined( __GNUC__ ) */
-
-extern long double truncl( long double ) __LIBMLDBL_COMPAT(truncl);
-extern long double fmodl( long double, long double) __LIBMLDBL_COMPAT(fmodl);
-extern long double remainderl( long double, long double ) __LIBMLDBL_COMPAT(remainderl);
-extern long double remquol( long double, long double, int * ) __LIBMLDBL_COMPAT(remquol);
-extern long double copysignl( long double, long double ) __LIBMLDBL_COMPAT(copysignl);
-extern long double nanl( const char * ) __LIBMLDBL_COMPAT(nanl);
-extern long double nextafterl( long double, long double ) __LIBMLDBL_COMPAT(nextafterl);
-extern double nexttoward( double, long double ) __LIBMLDBL_COMPAT(nexttoward);
-extern float nexttowardf( float, long double ) __LIBMLDBL_COMPAT(nexttowardf);
-extern long double nexttowardl( long double, long double ) __LIBMLDBL_COMPAT(nexttowardl);
-extern long double fdiml( long double, long double ) __LIBMLDBL_COMPAT(fdiml);
-extern long double fmaxl( long double, long double ) __LIBMLDBL_COMPAT(fmaxl);
-extern long double fminl( long double, long double ) __LIBMLDBL_COMPAT(fminl);
-extern long double fmal( long double, long double, long double ) __LIBMLDBL_COMPAT(fmal);
-#endif /* __WANT_LONG_DOUBLE_FORMAT__ */
-
-#define isgreater(x, y) __builtin_isgreater ((x),(y))
-#define isgreaterequal(x, y) __builtin_isgreaterequal ((x),(y))
-#define isless(x, y) __builtin_isless ((x),(y))
-#define islessequal(x, y) __builtin_islessequal ((x),(y))
-#define islessgreater(x, y) __builtin_islessgreater ((x),(y))
-#define isunordered(x, y) __builtin_isunordered ((x),(y))
-
-extern double  __inf( void );
-extern float  __inff( void );
-extern float  __nan( void ); /* 10.3 (and later) must retain in ABI for backward compatability */
-
-#if !defined(_ANSI_SOURCE)
-extern double j0 ( double );
-extern double j1 ( double );
-extern double jn ( int, double );
-
-extern double y0 ( double );
-extern double y1 ( double );
-extern double yn ( int, double );
-
-/* 
- * Scalb Travellers' advisory:
- * ---------------------------
- *
- * Reduction of Information advisory -- This advisory may constitute "too much information". Readers who are easily panicked 
- *                                      or confused may be needlessly panicked or confused by this advisory.
- *
- * We are in the process of retiring the legacy scalb.  IEEE-754 did not specify what the argument types should be
- * for scalb.  We guessed scalb(double, int) -- ints are faster to use here -- but our guess and what later standards
- * standard eventually settled on did not agree. To be compliant with these standards, our scalb needs to be scalb(double, double).
- * Unfortunately, we have a commitment to be binary compatible with old software compiled against scalb(double, int)
- * for older operating systems, so the old symbol _scalb must live on in perpetuity in the __ppc__ binary interface to service 
- * this need. To deal with this problem, we have introduced a new binary symbol _scalb$UNIX2003 and did some magic below
- * so that when you now compile against scalb() on a __ppc__ application, you get linked to _scalb$UNIX2003 instead. Thus, 
- * this constitutes a source level *** API CHANGE *** from  scalb( double, int ) to scalb( double, double) on __ppc__ only 
- * that your source will need to contend with if you compile with this header.  On __ppc__, all ints are exactly representable 
- * as doubles so from an arithmetic standpoint, this should cause no changes arithmetically from parameters of int type, but there 
- * remains the danger of triggering various compiler warnings that might balloon to more serious problems under -Werror. 
- *
- * On __ppc64__, __i386__ and future archs, scalb has always been scalb( double, double) and will continue to be so. Thus, this change
- * will make scalb on all platforms behave identically, with the same parameter types. The change will also eliminate GCC warnings about 
- * the math.h scalb declaration not matching the gcc4 builtin version. 
- *
- * The intent is that you will "never know" that a change occurred, and your code should "just do the right thing" without modification.
- * However, if you would like to sidestep any problems associated with this move, it is suggested that you use the C99 scalbn or scalbln 
- * or single/long double variants as appropriate instead. Their behavior and type is rigorously defined. There should be no hidden arithmetic 
- * "gotchas" if you simply replace all legacy calls to scalb with scalbn, since they essentially do the same thing.  If you 
- * decide to take this step, you should exercise due diligence to make sure that scalbn is present in the oldest version of 
- * MacOS X that you support. Otherwise, your application may fail to load on older systems. C99 support was introduced in MacOS X.3.9. 
- *
- * Use of the symbol _scalb$UNIX2003 should not in itself be construed to mean that scalb$UNIX2003 necessarily is UNIX 2003 compliant. 
- * UNIX is a registered trademark of The Open Group. 
- */
- 
-/* maps to _scalb$UNIX2003 on __ppc__ and _scalb elsewhere */
-#if defined( __ppc__ )
-    #if defined( __GNUC__ ) && ! defined( __XLC__ ) && ( ! defined( __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__) || __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__-0 >= 1040 )
-        extern double scalb ( double, double )  __asm("_scalb$UNIX2003" ); 
-    #else
-        extern double scalb ( double , int );  
-    #endif
-#else
-	extern double scalb ( double, double );
-#endif
-
-#define M_E         2.71828182845904523536028747135266250   /* e */
-#define M_LOG2E     1.44269504088896340735992468100189214   /* log_2(e) */
-#define M_LOG10E    0.434294481903251827651128918916605082  /* log_10(e) */
-#define M_LN2       0.693147180559945309417232121458176568  /* log_e(2) */
-#define M_LN10      2.30258509299404568401799145468436421   /* log_e(10) */
-#define M_PI        3.14159265358979323846264338327950288   /* pi */
-#define M_PI_2      1.57079632679489661923132169163975144   /* pi/2 */
-#define M_PI_4      0.785398163397448309615660845819875721  /* pi/4 */
-#define M_1_PI      0.318309886183790671537767526745028724  /* 1/pi */
-#define M_2_PI      0.636619772367581343075535053490057448  /* 2/pi */
-#define M_2_SQRTPI  1.12837916709551257389615890312154517   /* 2/sqrt(pi) */
-#define M_SQRT2     1.41421356237309504880168872420969808   /* sqrt(2) */
-#define M_SQRT1_2   0.707106781186547524400844362104849039  /* 1/sqrt(2) */
-
-#define	MAXFLOAT	((float)3.40282346638528860e+38)
-extern int signgam;
-
-#endif /* !defined(_ANSI_SOURCE) */
-
-#if !defined(__NOEXTENSIONS__) && (!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE))
-#define __WANT_EXTENSIONS__
-#endif
-
-#ifdef __WANT_EXTENSIONS__
-
-#define FP_SNAN		FP_NAN
-#define FP_QNAN		FP_NAN
-
-extern long int rinttol ( double );
-
-extern long int roundtol ( double );
-
-typedef struct __complex_s {
-        double Real;
-        double Imag;
-} __complex_t;
-
-/*
- * XOPEN/SVID
- */
-#if !defined(_ANSI_SOURCE) && (!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE))
-
-#if (!defined(_XOPEN_SOURCE) || defined(_DARWIN_C_SOURCE))
-enum fdversion {_fdlibm_ieee = -1, _fdlibm_svid, _fdlibm_xopen, _fdlibm_posix}; /* Legacy fdlibm constructs */
-#define fdlibm_ieee _fdlibm_ieee
-#define fdlibm_svid _fdlibm_svid
-#define fdlibm_xopen _fdlibm_xopen
-#define fdlibm_posix _fdlibm_posix
-
-#define _LIB_VERSION_TYPE enum fdversion
-#define _LIB_VERSION _fdlib_version  
-
-/* if global variable _LIB_VERSION is not desirable, one may 
- * change the following to be a constant by: 
- *	#define _LIB_VERSION_TYPE const enum version
- * In that case, after one initializes the value _LIB_VERSION (see
- * s_lib_version.c) during compile time, it cannot be modified
- * in the middle of a program
- */ 
-extern  _LIB_VERSION_TYPE  _LIB_VERSION;
-
-#define _IEEE_  fdlibm_ieee
-#define _SVID_  fdlibm_svid
-#define _XOPEN_ fdlibm_xopen
-#define _POSIX_ fdlibm_posix
-
-#if !defined(__cplusplus)
-struct exception {
-	int type;
-	char *name;
-	double arg1;
-	double arg2;
-	double retval;
-};
-#endif
-
-#define	HUGE		MAXFLOAT
-
-/* 
- * set X_TLOSS = pi*2**52, which is possibly defined in <values.h>
- * (one may replace the following line by "#include <values.h>")
- */
-
-#define X_TLOSS		1.41484755040568800000e+16 
-
-#define	DOMAIN		1
-#define	SING		2
-#define	OVERFLOW	3
-#define	UNDERFLOW	4
-#define	TLOSS		5
-#define	PLOSS		6
-
-#endif /* (!_XOPEN_SOURCE || _DARWIN_C_SOURCE) */
-#endif /* !_ANSI_SOURCE && (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */
-
-#if !defined( __STRICT_ANSI__) && !defined(_ANSI_SOURCE) && (!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE))
-
-extern int finite ( double );
-
-extern double gamma ( double );
-
-#if (!defined(_XOPEN_SOURCE) || defined(_DARWIN_C_SOURCE))
-
-#if !defined(__cplusplus)
-extern int matherr ( struct exception * );
-#endif
-
-/*
- * IEEE Test Vector
- */
-extern double significand ( double );
-
-/*
- * BSD math library entry points
- */
-extern double drem ( double, double );
-
-/*
- * Reentrant version of gamma & lgamma; passes signgam back by reference
- * as the second argument; user must allocate space for signgam.
- */
-#ifdef _REENTRANT
-extern double gamma_r ( double, int * );
-extern double lgamma_r ( double, int * );
-#endif /* _REENTRANT */
-#endif /* (!_XOPEN_SOURCE || _DARWIN_C_SOURCE) */
-#endif /* !_ANSI_SOURCE && (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */
-
-#endif /* __WANT_EXTENSIONS__ */
-
-/*
- * The following replacements for libm's floor, floorf, ceil, and ceilf are activated
- * when the flag "-ffast-math" is passed to the gcc compiler. These functions do not
- * distinguish between -0.0 and 0.0, so are not IEC6509 compliant for argument -0.0.
- */
-#if defined(__FAST_MATH__) && !defined(__cplusplus)
-
-#define __FSELS(e,t,f) (((e) >= 0.0f) ? (t) : (f))
-#define __FSEL(e,t,f) (((e) >= 0.0) ? (t) : (f))
-
-static __inline__ float __fastmath_floorf( float f ) __attribute__((__always_inline__));
-static __inline__ float __fastmath_floorf( float f )
-{
-    float b, c, d, e, g, h, t;
-
-    c = __FSELS( f, -8388608.f, 8388608.f );          b = fabsf( f ); 
-    d = f - c;                                          e = b - 8388608.f;                        
-	__asm__("" : "+f" (d));	/* Tell compiler value of d cannot be optimized away. */
-	d = d + c;
-    g = f - d;
-    h = __FSELS( g, 0.0f, 1.0f );
-    t = d - h;
-    return __FSELS( e, f, t );
-}
-
-static __inline__ float __fastmath_ceilf( float f ) __attribute__((__always_inline__));
-static __inline__ float __fastmath_ceilf( float f )
-{
-    float b, c, d, e, g, h, t;
-
-    c = __FSELS( f, -8388608.f, 8388608.f );          b = fabsf( f ); 
-    d = f - c;                                          e = b - 8388608.f;                        
-	__asm__("" : "+f" (d));	/* Tell compiler value of d cannot be optimized away. */
-	d = d + c;
-    g = d - f;
-    h = __FSELS( g, 0.0f, 1.0f );
-    t = d + h;
-    return __FSELS( e, f, t );
-}
-
-static __inline__ double __fastmath_floor( double f ) __attribute__((__always_inline__));
-static __inline__ double __fastmath_floor( double f )
-{
-    double b, c, d, e, g, h, t;
-
-    c = __FSEL( f, -4503599627370496., 4503599627370496. );             b = fabs( f );      
-    d = f - c;                                          e = b - 4503599627370496.;                    
-	__asm__("" : "+f" (d));	/* Tell compiler value of d cannot be optimized away. */
-	d = d + c;
-    g = f - d;
-    h = __FSEL( g, 0.0, 1.0 );
-    t = d - h;
-    return __FSEL( e, f, t );
-}
-
-static __inline__ double __fastmath_ceil( double f ) __attribute__((__always_inline__));
-static __inline__ double __fastmath_ceil( double f )
-{
-    double b, c, d, e, g, h, t;
-
-    c = __FSEL( f, -4503599627370496., 4503599627370496. );             b = fabs( f );      
-    d = f - c;                                          e = b - 4503599627370496.;                    
-	__asm__("" : "+f" (d));	/* Tell compiler value of d cannot be optimized away. */
-	d = d + c;
-    g = d - f;
-    h = __FSEL( g, 0.0, 1.0 );
-    t = d + h;
-    return __FSEL( e, f, t );
-}
-
-#define floorf(x) __fastmath_floorf((x))
-#define ceilf(x) __fastmath_ceilf((x))
-#define floor(x) __fastmath_floor((x))
-#define ceil(x) __fastmath_ceil((x))
-
-#endif /* __FAST_MATH__ && !__cplusplus */
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* __MATH__ */
diff -Nur cctools-855-ld64-236.3/include/foreign/architecture/ppc/mode_independent_asm.h ../cctools-port.bak/cctools/include/foreign/architecture/ppc/mode_independent_asm.h
--- cctools-855-ld64-236.3/include/foreign/architecture/ppc/mode_independent_asm.h	2014-06-30 01:18:32.000000000 +0800
+++ ../cctools-port.bak/cctools/include/foreign/architecture/ppc/mode_independent_asm.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,187 +0,0 @@
-/*
- * Copyright (c) 2004 Apple Computer, Inc. All rights reserved.
- *
- * @APPLE_LICENSE_HEADER_START@
- * 
- * This file contains Original Code and/or Modifications of Original Code
- * as defined in and that are subject to the Apple Public Source License
- * Version 2.0 (the 'License'). You may not use this file except in
- * compliance with the License. Please obtain a copy of the License at
- * http://www.opensource.apple.com/apsl/ and read it before using this
- * file.
- * 
- * The Original Code and all software distributed under the License are
- * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
- * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
- * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
- * Please see the License for the specific language governing rights and
- * limitations under the License.
- * 
- * @APPLE_LICENSE_HEADER_END@
- */
-
-#ifndef _PPC_MODE_INDEPENDENT_ASM_H_
-#define _PPC_MODE_INDEPENDENT_ASM_H_
-
-
-/* This file facilitates writing mode-independent PPC assembler source, ie
- * source which can be built both for 32-bit mode (__ppc__) and 64-bit 
- * mode (__ppc64__.)
- *
- * It defines constants such as the number of bytes in a GPR (GPR_BYTES),
- * macros to address and call externals (MI_GET_ADDRESS), and a set of mode
- * independent PPC assembler pseudo-mnemonics.
- *
- * The assembler mnemonics map to word operations when building for __ppc__,
- * and to doubleword operations when building for __ppc64__.  They use "g" to
- * stand for either word or doubleword, depending on the target mode.  
- *
- * Although there are certainly other things to be aware of when writing code
- * targeted at both 32 and 64-bit mode, using these macros and psuedo-mnemonics
- * is surprisingly helpful.
- */
-
-#if defined(__ppc64__)
-#define MODE_CHOICE(x, y) y
-#elif defined(__ppc__)
-#define MODE_CHOICE(x, y) x
-#else
-#error undefined architecture
-#endif
-
-
-/* The mode-independent "g" mnemonics.  */
-
-#define cmpg    MODE_CHOICE(cmpw, cmpd)
-#define cmplg   MODE_CHOICE(cmplw, cmpld)
-#define cmpgi   MODE_CHOICE(cmpwi, cmpdi)
-#define cmplgi  MODE_CHOICE(cmplwi, cmpldi)
-#define srgi    MODE_CHOICE(srwi, srdi)
-#define srg     MODE_CHOICE(srw, srd)
-#define sragi   MODE_CHOICE(srawi, sradi)
-#define slgi    MODE_CHOICE(slwi, sldi)
-#define rotlgi  MODE_CHOICE(rotlwi, rotldi)
-#define clrrgi  MODE_CHOICE(clrrwi, clrrdi)
-#define cntlzg  MODE_CHOICE(cntlzw, cntlzd)
-#define lg      MODE_CHOICE(lwz, ld)
-#define stg     MODE_CHOICE(stw, std)
-#define lgx     MODE_CHOICE(lwzx, ldx)
-#define stgx    MODE_CHOICE(stwx, stdx)
-#define lgu     MODE_CHOICE(lwzu, ldu)
-#define stgu    MODE_CHOICE(stwu, stdu)
-#define lgux    MODE_CHOICE(lwzux, ldux)
-#define stgux   MODE_CHOICE(stwux, stdux)
-#define lgwa    MODE_CHOICE(lwz, lwa)
-
-#define g_long  MODE_CHOICE(long, quad)         // usage is ".g_long"
-
-
-/* Architectural constants.  */
-
-#define GPR_BYTES       MODE_CHOICE(4,8)        // size of a GPR in bytes
-#define LOG2_GPR_BYTES  MODE_CHOICE(2,3)        // log2(GPR_BYTES)
-
-
-/* Stack frame definitions.  To keep things simple, we are limited
- * to eight arguments and two locals.
- */
-#define SF_CRSAVE       MODE_CHOICE(4,8)
-#define SF_RETURN       MODE_CHOICE(8,16)
-#define SF_ARG1         MODE_CHOICE(24,48)
-#define SF_ARG2         MODE_CHOICE(28,56)
-#define SF_ARG3         MODE_CHOICE(32,64)
-#define SF_ARG4         MODE_CHOICE(36,72)
-#define SF_ARG5         MODE_CHOICE(40,80)
-#define SF_ARG6         MODE_CHOICE(44,88)
-#define SF_ARG7         MODE_CHOICE(48,96)
-#define SF_ARG8         MODE_CHOICE(52,104)
-#define SF_LOCAL1       MODE_CHOICE(56,112)
-#define SF_LOCAL2       MODE_CHOICE(60,120)
-#define SF_SIZE         MODE_CHOICE(64,128)
-
-#define SF_ALIGNMENT    MODE_CHOICE(16,32)
-#define SF_REDZONE      MODE_CHOICE(224,320)
-
-#define SF_ROUND(x)     (((x)+SF_ALIGNMENT-1)&(-SF_ALIGNMENT))
-
-#define SF_MINSIZE      MODE_CHOICE(64,128)
- 
- 
-/* WARNING: some clients fall through this macro, so do not attempt
- * to optimize by doing an ".align 5" in the macro.  Do the 32-byte
- * alignment in the .s file, before invoking the macro.
- */
-#define MI_ENTRY_POINT(name)     \
-    .globl  name                @\
-    .text                       @\
-    .align  2                   @\
-name:
-
-#define MI_PUSH_STACK_FRAME      \
-    mflr    r0                  @\
-    stg     r0,SF_RETURN(r1)    @\
-    stgu    r1,-SF_SIZE(r1)
-    
-#define MI_POP_STACK_FRAME_AND_RETURN    \
-    lg      r0,SF_RETURN+SF_SIZE(r1)    @\
-    addi    r1,r1,SF_SIZE               @\
-    mtlr    r0                          @\
-    blr
-    
-
-/* MI_GET_ADDRESS(reg,var) is the basic primitive to address data or code.
- * It works both in 32 and 64-bit mode, and with static and dynamic
- * code generation.  Note however that it can be invoked at most once per
- * symbol, since it always creates a non_lazy_ptr in dynamic mode.
- * Save the address for re-use, rather than invoking the macro again.
- */
-#if defined(__DYNAMIC__)
-#define MI_GET_ADDRESS(reg,var)  \
-    mflr    r0                  @\
-    bcl     20,31,1f            @\
-1:  mflr    reg                 @\
-    mtlr    r0                  @\
-    addis   reg,reg,ha16(L ## var ## __non_lazy_ptr - 1b) @\
-    lg      reg,lo16(L ## var ## __non_lazy_ptr - 1b)(reg) @\
-    .non_lazy_symbol_pointer    @\
-    .align  LOG2_GPR_BYTES      @\
-    .indirect_symbol var        @\
-L ## var ## __non_lazy_ptr:      @\
-    .g_long 0                   @\
-    .text                       @\
-    .align  2
-#else /* ! __DYNAMIC__ */
-#define MI_GET_ADDRESS(reg,var)  \
-    lis     reg,hi16(var)       @\
-    ori     reg,reg,lo16(var)
-#endif
-
-
-/* MI_CALL_EXTERNAL(var)  */
-
-#if defined(__DYNAMIC__)
-#define MI_CALL_EXTERNAL(var)    \
-    MI_GET_ADDRESS(r12,var)     @\
-    mtctr   r12                 @\
-    bctrl
-#else /* ! __DYNAMIC__ */
-#define MI_CALL_EXTERNAL(var)    \
-    bl      var
-#endif
-
-
-/* MI_BRANCH_EXTERNAL(var)  */
-
-#if defined(__DYNAMIC__)
-#define MI_BRANCH_EXTERNAL(var)  \
-    MI_GET_ADDRESS(r12,var)     @\
-    mtctr   r12                 @\
-    bctr
-#else /* ! __DYNAMIC__ */
-#define MI_BRANCH_EXTERNAL(var)  \
-    b       var
-#endif
-
-    
-#endif  /* _PPC_MODE_INDEPENDENT_ASM_H_ */
diff -Nur cctools-855-ld64-236.3/include/foreign/architecture/ppc/pseudo_inst.h ../cctools-port.bak/cctools/include/foreign/architecture/ppc/pseudo_inst.h
--- cctools-855-ld64-236.3/include/foreign/architecture/ppc/pseudo_inst.h	2014-06-30 01:18:32.000000000 +0800
+++ ../cctools-port.bak/cctools/include/foreign/architecture/ppc/pseudo_inst.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,447 +0,0 @@
-/*
- * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
- *
- * @APPLE_LICENSE_HEADER_START@
- * 
- * This file contains Original Code and/or Modifications of Original Code
- * as defined in and that are subject to the Apple Public Source License
- * Version 2.0 (the 'License'). You may not use this file except in
- * compliance with the License. Please obtain a copy of the License at
- * http://www.opensource.apple.com/apsl/ and read it before using this
- * file.
- * 
- * The Original Code and all software distributed under the License are
- * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
- * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
- * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
- * Please see the License for the specific language governing rights and
- * limitations under the License.
- * 
- * @APPLE_LICENSE_HEADER_END@
- */
-/* Copyright (c) 1996 NeXT Software, Inc.  All rights reserved.
- *
- *	File:	architecture/ppc/pseudo_inst.h
- *	Author:	Mike DeMoney
- *
- *	This header file defines assembler pseudo-instruction macros for
- *	for the ppc.
- *
- *	NOTE: This is obviously only useful to include in assembly
- *	code source.
- *
- *	ALSO NOTE: These macros don't attempt to be 64-bit compatable
- *
- * HISTORY
- * 29-Dec-96  Umesh Vaishampayan  (umeshv@NeXT.com)
- *	Ported from m98k.
- * 05-Nov-92  Mike DeMoney (mike@next.com)
- *	Created.
- */
-
-#ifndef	_ARCH_PPC_PSEUDO_INST_H_
-#define	_ARCH_PPC_PSEUDO_INST_H_
-
-#include <architecture/ppc/reg_help.h>
-#include <architecture/ppc/asm_help.h>
-
-#ifdef	__ASSEMBLER__
-
-/*
- * Pseudo instruction definitions
- */
-
-/*
- * Macro package initialization
- */
-	.set	__no_at,0		/* allow at by default */
-
-/*
- * .at_off -- disable use of at by macros
- * .at_on -- enable use of at by macros
- */
-.macro	.at_off
-	.set	__no_at,1
-.endmacro
-
-.macro	.at_on
-	.set	__no_at,0
-.endmacro
-
-/*
- * li32	rD,IMMED
- *
- * Load 32-bit immediate into rD
- * FIXME: Need a way to undefine built-in macro for this.
- */
-.macro	li32				// li32	rD,immed
-.if	$n != 2
-	.abort	"invalid operands of li32"
-.endif
-.abs	__is_abs,$1
-.if	!__is_abs
-	addis	$0,0,hi16($1)
-	ori	$0,$0,lo16($1)
-.elseif	$1 == 0
-	addi	$0,0,0
-.elseif	($1 & 0xffff) == 0
-	addis	$0,0,hi16($1)
-.elseif	($1 & 0xffff8000) == 0
-	addi	$0,0,$1
-.elseif ($1 & 0xffff8000) == 0xffff8000
-	addi	$0,0,$1
-.else
-	addis	$0,0,hi16($1)
-	ori	$0,$0,lo16($1)
-.endif
-.endmacro
- 
-
-/*
- * andi32. rD,rS1,IMMED
- *
- * Perform "andi." with (possibly) 32-bit immediate
- */
-.macro	andi32.				// andi32. rD,rS1,IMMED
-.if	$n != 3
-	.abort	"invalid operands of andi."
-.endif
-	.set	__used_at,0
-.abs	__is_abs,$2
-.if	!__is_abs
-	.set	__used_at,1
-	li32	at,$2
-	and.	$0,$1,at
-.elseif	($2 & 0xffff0000) == 0
-	andi.	$0,$1,$2
-.elseif	($2 & 0xffff) == 0
-	andis.	$0,$1,hi16($2)
-.else
-	.set	__used_at,1
-	li32	at,$2
-	and.	$0,$1,at
-.endif
-.if	__no_at & __used_at
-	.abort	"Macro uses at while .no_at in effect"
-.endif
-.endmacro
- 
-/*
- * ori32	rD,rS1,IMMED
- *
- * Perform "ori" with (possibly) 32-bit immediate
- */
-.macro	ori32				// ori32	rD,rS1,IMMED
-.if	$n != 3
-	.abort	"invalid operands of ori"
-.endif
-.abs	__is_abs,$2
-.if	!__is_abs
-	oris	$0,$1,hi16($2)
-	ori	$0,$1,lo16($2)
-.elseif	($2 & 0xffff0000) == 0
-	ori	$0,$1,$2
-.elseif	($2 & 0xffff) == 0
-	oris	$0,$1,hi16($2)
-.else
-	oris	$0,$1,hi16($2)
-	ori	$0,$1,lo16($2)
-.endif
-.endmacro
- 
-/*
- * xori32	rD,rS1,IMMED
- *
- * Perform "xor" with (possibly) 32-bit immediate
- */
-.macro	xori32				// xori32	rD,rS1,IMMED
-.if	$n != 3
-	.abort	"invalid operands of xori"
-.endif
-.abs	__is_abs,$2
-.if	!__is_abs
-	xoris	$0,$1,hi16($2)
-	xori	$0,$1,lo16($2)
-.elseif	($2 & 0xffff0000) == 0
-	xori	$0,$1,$2
-.elseif	($2 & 0xffff) == 0
-	xoris	$0,$1,hi16($2)
-.else
-	xoris	$0,$1,hi16($2)
-	xori	$0,$1,lo16($2)
-.endif
-.endmacro
-
-
-/*
- * MEMREF_INST -- macros to memory referencing instructions
- * "capable" of dealing with 32 bit offsets.
- *
- * NOTE: Because the assembler doesn't have any mechanism for easily
- * parsing the d(rS) syntax of register-displacement form instructions,
- * these instructions do NOT mirror the normal memory reference
- * instructions.  The following "transformation" is used:
- *	lbz	rD,d(rS)
- * becomes:
- *	lbz32	rD,rS,d
- * I.e.: "32" is appended to the instruction name and the base register
- * and displacement become the 2'nd and 3'rd comma-separated operands.
- *
- * The forms:
- *	lbz32	rD,d
- * and:
- *	lbz32	rD,rS
- * are also recognized and the missing operand is assumed 0.
- *
- * ALSO NOTE: r0 or zt should never be used as rS in these instructions.
- * Use "0" as rS in this case.
- */
-#define	MEMREF_INST(op)						\
-.macro	op ## 32						@\
-.set	__used_at,0						@\
-.if	$n == 3							@\
- .greg	__is_greg,$1						@\
- .abs	__is_abs,$2						@\
- .if	__is_abs						@\
-  .if	($2 & 0xffff8000) == 0					@\
-	op	$0,$2($1)					@\
-  .elseif ($2 & 0xffff8000) == 0xffff8000			@\
-	op	$0,$2($1)					@\
-  .else								@\
-   .if	!__is_greg						@\
-	.set	__used_at,1					@\
-	lis	at,ha16($2)					@\
-	op	$0,lo16($2)(at)					@\
-   .else							@\
-  	.set	__used_at,1					@\
-	lis	at,ha16($2)					@\
-	add	at,at,$1					@\
-	op	$0,lo16($2)(at)					@\
-   .endif							@\
-  .endif							@\
- .else								@\
-  .if	!__is_greg						@\
-	.set	__used_at,1					@\
-	lis	at,ha16($2)					@\
-	op	$0,lo16($2)(at)					@\
-  .else								@\
-  	.set	__used_at,1					@\
-	lis	at,ha16($2)					@\
-	add	at,at,$1					@\
-	op	$0,lo16($2)(at)					@\
-  .endif							@\
- .endif								@\
-.elseif	$n == 2							@\
- .greg	__is_greg,$1						@\
- .if	!__is_greg						@\
-  .abs	__is_abs,$1						@\
-  .if	__is_abs						@\
-   .if	($1 & 0xffff8000) == 0					@\
-	op	$0,$1(0)					@\
-   .elseif ($1 & 0xffff8000) == 0xffff8000			@\
-	op	$0,$1(0)					@\
-   .else							@\
-	.set	__used_at,1					@\
-	lis	at,ha16($1)					@\
-	op	$0,lo16($1)(at)					@\
-   .endif							@\
-  .else								@\
-	.set	__used_at,1					@\
-	lis	at,ha16($1)					@\
-	op	$0,lo16($1)(at)					@\
-  .endif							@\
- .else								@\
-	op	$0,0($1)					@\
- .endif								@\
-.else								@\
-	.abort "Invalid operands of " #op "32"			@\
-.endif								@\
-.if	__no_at &  __used_at					@\
-	.abort	"Macro uses at while .no_at in effect"		@\
-.endif								@\
-.endmacro
-
-MEMREF_INST(lbz)
-MEMREF_INST(lhz)
-MEMREF_INST(lha)
-MEMREF_INST(lwz)
-MEMREF_INST(lwa)
-MEMREF_INST(ld)
-
-MEMREF_INST(stb)
-MEMREF_INST(sth)
-MEMREF_INST(stw)
-MEMREF_INST(std)
-
-MEMREF_INST(lmw)
-MEMREF_INST(lmd)
-MEMREF_INST(stmw)
-MEMREF_INST(stmd)
-
-/*
- * ARITH_INST -- define 32-bit immediate forms of arithmetic
- * instructions
- *
- *	E.g.	addi32	rD,rS,IMMED
- */
-#define	ARITH_INST(op, op3)					\
-.macro	op ## 32						@\
-.if	$n != 3							@\
-	.abort	"invalid operands to " #op "32"			@\
-.endif								@\
-.abs	__is_abs,$2						@\
-.if	__is_abs						@\
- .if	($2 & 0xffff8000) == 0					@\
-	op	$0,$1,$2					@\
- .elseif	($2 & 0xffff8000) == 0xffff8000			@\
-	op	$0,$1,$2					@\
- .elseif	__no_at						@\
-	.abort	"Macro uses at while .no_at in effect"		@\
- .else								@\
-	li32	at,$2						@\
-	op3	$0,$1,at					@\
- .endif								@\
-.elseif	__no_at							@\
-	.abort	"Macro uses at while .no_at in effect"		@\
-.else								@\
-	li32	at,$2						@\
-	op3	$0,$1,at					@\
-.endif								@\
-.endmacro
-
-ARITH_INST(addi, add)
-ARITH_INST(subi, sub)
-ARITH_INST(addic, addc)
-ARITH_INST(subic, subc)
-ARITH_INST(mulli, mull)
-
-/*
- * COND_ARITH_INST -- define 32-bit immediate forms of arithmetic
- * instructions that set bits in the condition register
- *
- *	E.g.	addic32.	rD,rS,IMMED
- */
-#define	COND_ARITH_INST(name, op, op3)					\
-.macro	name						@\
-.if	$n != 3							@\
-	.abort	"invalid operands to " #name			@\
-.endif								@\
-.abs	__is_abs,$2						@\
-.if	__is_abs						@\
- .if	($2 & 0xffff8000) == 0					@\
-	op	$0,$1,$2					@\
- .elseif	($2 & 0xffff8000) == 0xffff8000			@\
-	op	$0,$1,$2					@\
- .elseif	__no_at						@\
-	.abort	"Macro uses at while .no_at in effect"		@\
- .else								@\
-	li32	at,$2						@\
-	op3	$0,$1,at					@\
- .endif								@\
-.elseif	__no_at							@\
-	.abort	"Macro uses at while .no_at in effect"		@\
-.else								@\
-	li32	at,$2						@\
-	op3	$0,$1,at					@\
-.endif								@\
-.endmacro
-
-COND_ARITH_INST(addic32., addic., addc.)
-COND_ARITH_INST(subic32., subic., subc.)
-
-/*
- * CMPEX_INST -- define 32-bit immediate forms of extended compare
- * instructions
- *
- *	E.g.	cmpwi32	cr3,rS,IMMED
- *		cmpwi32	rS,IMMED
- */
-#define	CMPEX_INST(op, op3)					\
-.macro	op ## 32						@\
-.if	$n == 3							@\
- .abs	__is_abs,$2						@\
- .if	__is_abs						@\
-  .if	($2 & 0xffff8000) == 0					@\
-	op	$0,$1,$2					@\
-  .elseif	($2 & 0xffff8000) == 0xffff8000			@\
-	op	$0,$1,$2					@\
-  .elseif	__no_at						@\
-	.abort	"Macro uses at while .no_at in effect"		@\
-  .else								@\
-	li32	at,$2						@\
-	op3	$0,$1,at					@\
-  .endif							@\
- .elseif	__no_at						@\
-	.abort	"Macro uses at while .no_at in effect"		@\
- .else								@\
-	li32	at,$2						@\
-	op3	$0,$1,at					@\
- .endif								@\
-.elseif	$n == 2							@\
- .abs	__is_abs,$1						@\
- .if	__is_abs						@\
-  .if	($1 & 0xffff8000) == 0					@\
-	op	$0,$1						@\
-  .elseif	($1 & 0xffff8000) == 0xffff8000			@\
-	op	$0,$1						@\
-  .elseif	__no_at						@\
-	.abort	"Macro uses at while .no_at in effect"		@\
-  .else								@\
-	li32	at,$1						@\
-	op3	$0,at						@\
-  .endif							@\
- .elseif	__no_at						@\
-	.abort	"Macro uses at while .no_at in effect"		@\
- .else								@\
-	li32	at,$1						@\
-	op3	$0,at						@\
- .endif								@\
-.else								@\
-	.abort	"invalid operands to " #op "32"			@\
-.endif								@\
-.endmacro
-
-CMPEX_INST(cmpdi, cmpd)
-CMPEX_INST(cmpwi, cmpw)
-CMPEX_INST(cmpldi, cmpld)
-CMPEX_INST(cmplwi, cmplw)
-
-/*
- * CMP_INST -- define 32-bit immediate forms of standard compare
- * instructions
- *
- *	E.g.	cmpi32	cr3,0,rS,IMMED
- */
-#define	CMP_INST(op, op3)					\
-.macro	op ## 32						@\
-.if	$n == 4							@\
- .abs	__is_abs,$3						@\
- .if	__is_abs						@\
-  .if	($3 & 0xffff8000) == 0					@\
-	op	$0,$1,$2,$3					@\
-  .elseif	($3 & 0xffff8000) == 0xffff8000			@\
-	op	$0,$1,$2,$3					@\
-  .elseif	__no_at						@\
-	.abort	"Macro uses at while .no_at in effect"		@\
-  .else								@\
-	li32	at,$3						@\
-	op3	$0,$1,$2,at					@\
-  .endif							@\
- .elseif	__no_at						@\
-	.abort	"Macro uses at while .no_at in effect"		@\
- .else								@\
-	li32	at,$3						@\
-	op3	$0,$1,$2,at					@\
- .endif								@\
-.else								@\
-	.abort	"invalid operands to " #op "32"			@\
-.endif								@\
-.endmacro
-
-CMP_INST(cmpi, cmp)
-CMP_INST(cmpli, cmpl)
-
-#endif	/* __ASSEMBLER__ */
-
-#endif	/* _ARCH_PPC_PSEUDO_INST_H_ */
diff -Nur cctools-855-ld64-236.3/include/foreign/architecture/ppc/reg_help.h ../cctools-port.bak/cctools/include/foreign/architecture/ppc/reg_help.h
--- cctools-855-ld64-236.3/include/foreign/architecture/ppc/reg_help.h	2014-06-30 01:18:32.000000000 +0800
+++ ../cctools-port.bak/cctools/include/foreign/architecture/ppc/reg_help.h	1970-01-01 08:00:00.000000000 +0800
@@ -1,225 +0,0 @@
-/*
- * Copyright (c) 1999 Apple Computer, Inc. All rights reserved.
- *
- * @APPLE_LICENSE_HEADER_START@
- * 
- * This file contains Original Code and/or Modifications of Original Code
- * as defined in and that are subject to the Apple Public Source License
- * Version 2.0 (the 'License'). You may not use this file except in
- * compliance with the License. Please obtain a copy of the License at
- * http://www.opensource.apple.com/apsl/ and read it before using this
- * file.
- * 
- * The Original Code and all software distributed under the License are
- * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
- * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
- * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
- * Please see the License for the specific language governing rights and
- * limitations under the License.
- * 
- * @APPLE_LICENSE_HEADER_END@
- */
-/* Copyright (c) 1996 NeXT Software, Inc.  All rights reserved.
- *
- *	File:	architecture/ppc/reg_help.h
- *	Author:	Doug Mitchell, NeXT Computer, Inc.
- *
- *	m98k-specific macros and inlines for defining machine registers.
- *
- * HISTORY
- * 05-Nov-92  Doug Mitchell at NeXT
- *	Created.
- *
- * 29-Dec-96  Umesh Vaishampayan  (umeshv@NeXT.com)
- *	Ported from m98k. Removed dependency on nrw directory.
- *	Merged code from architecture/nrw/reg_help.h.
- *	Moved Register Usage #defines from asm_help.h in here.
- */
-
-#ifndef _ARCH_PPC_REG_HELP_H_
-#define _ARCH_PPC_REG_HELP_H_
-
-#if defined(__ASSEMBLER__)
-/*
- * GRF Register Usage Aliases
- */
-#define	zt		r0		// architecturally 0 for mem refs only!
-					// real reg other inst, caller-saved
-#define	sp		r1		// stack pointer, callee-saved
-#define	toc		r2		// tbl of contents, callee-saved
-#define	a0		r3		// arg 0, return value 0, caller saved
-#define	a1		r4		// arg 1, return value 1, caller saved
-#define	a2		r5		// ....
-#define	a3		r6
-#define	a4		r7
-#define	a5		r8
-#define	a6		r9
-#define	a7		r10		// arg 7, return value 7, caller saved
-#define	ep		r11		// environment ptr, caller saved
-#define	at		r12		// assembler temp, caller saved
-#define	s17		r13		// callee-saved 17
-#define	s16		r14
-#define	s15		r15
-#define	s14		r16
-#define	s13		r17
-#define	s12		r18
-#define	s11		r19
-#define	s10		r20
-#define	s9		r21
-#define	s8		r22
-#define	s7		r23
-#define	s6		r24
-#define	s5		r25
-#define	s4		r26
-#define	s3		r27
-#define	s2		r28
-#define	s1		r29		// ....
-#define	s0		r30		// callee-saved 0
-#define	fp		r31		// frame-pointer, callee-saved
-
-/*
- * Conversion of GRF aliases to register numbers
- */
-#define	GRF_ZT		0		// architecturally 0 for mem refs only!
-					// real reg other inst, caller-saved
-#define	GRF_SP		1		// stack pointer, callee-saved
-#define	GRF_TOC		2		// tbl of contents, callee-saved
-#define	GRF_A0		3		// arg 0, return value 0, caller saved
-#define	GRF_A1		4		// arg 1, return value 1, caller saved
-#define	GRF_A2		5		// ....
-#define	GRF_A3		6
-#define	GRF_A4		7
-#define	GRF_A5		8
-#define	GRF_A6		9
-#define	GRF_A7		10		// arg 7, return value 7, caller saved
-#define	GRF_EP		11		// environment ptr, caller saved
-#define	GRF_AT		12		// assembler temp, caller saved
-#define	GRF_S17		13		// callee-saved 17
-#define	GRF_S16		14
-#define	GRF_S15		15
-#define	GRF_S14		16
-#define	GRF_S13		17
-#define	GRF_S12		18
-#define	GRF_S11		19
-#define	GRF_S10		20
-#define	GRF_S9		21
-#define	GRF_S8		22
-#define	GRF_S7		23
-#define	GRF_S6		24
-#define	GRF_S5		25
-#define	GRF_S4		26
-#define	GRF_S3		27
-#define	GRF_S2		28
-#define	GRF_S1		29		// ....
-#define	GRF_S0		30		// callee-saved 0
-#define	GRF_FP		31		// frame pointer, callee-saved
-
-/*
- * FPF Register names
- */
-#define	ft0		f0		// scratch reg, caller-saved
-#define	fa0		f1		// fp arg 0, return 0, caller-saved
-#define	fa1		f2		// fp arg 1, caller-saved
-#define	fa2		f3		// fp arg 2, caller-saved
-#define	fa3		f4
-#define	fa4		f5
-#define	fa5		f6
-#define	fa6		f7
-#define	fa7		f8
-#define	fa8		f9
-#define	fa9		f10
-#define	fa10		f11
-#define	fa11		f12
-#define	fa12		f13		// fp arg 12, caller-saved
-#define	fs17		f14		// callee-saved 17
-#define	fs16		f15
-#define	fs15		f16
-#define	fs14		f17
-#define	fs13		f18
-#define	fs12		f19
-#define	fs11		f20
-#define	fs10		f21
-#define	fs9		f22
-#define	fs8		f23
-#define	fs7		f24
-#define	fs6		f25
-#define	fs5		f26
-#define	fs4		f27
-#define	fs3		f28
-#define	fs2		f29
-#define	fs1		f30
-#define	fs0		f31		// callee-saved 0
-
-/*
- * Conversion of FPF aliases to register numbers
- */
-#define	FPF_FT0		0		// scratch reg, caller-saved
-#define	FPF_FA0		1		// fp arg 0, return 0, caller-saved
-#define	FPF_FA1		2		// fp arg 1, caller-saved
-#define	FPF_FA2		3		// fp arg 2, caller-saved
-#define	FPF_FA3		4
-#define	FPF_FA4		5
-#define	FPF_FA5		6
-#define	FPF_FA6		7
-#define	FPF_FA7		8
-#define	FPF_FA8		9
-#define	FPF_FA9		10
-#define	FPF_FA10	11
-#define	FPF_FA11	12
-#define	FPF_FA12	13		// fp arg 12, caller-saved
-#define	FPF_FS17	14		// callee-saved 17
-#define	FPF_FS16	15
-#define	FPF_FS15	16
-#define	FPF_FS14	17
-#define	FPF_FS13	18
-#define	FPF_FS12	19
-#define	FPF_FS11	20
-#define	FPF_FS10	21
-#define	FPF_FS9		22
-#define	FPF_FS8		23
-#define	FPF_FS7		24
-#define	FPF_FS6		25
-#define	FPF_FS5		26
-#define	FPF_FS4		27
-#define	FPF_FS3		28
-#define	FPF_FS2		29
-#define	FPF_FS1		30
-#define	FPF_FS0		31		// callee-saved 0
-
-#endif	/* __ASSEMBLER__ */
-
-
-/* Bitfield definition aid */
-#define	BITS_WIDTH(msb, lsb)	((msb)-(lsb)+1)
-#define	BIT_WIDTH(pos)		(1)	/* mostly to record the position */
-
-/* Mask creation */
-#define	MKMASK(width, offset)	(((unsigned)-1)>>(32-(width))<<(offset))
-#define	BITSMASK(msb, lsb)	MKMASK(BITS_WIDTH(msb, lsb), lsb & 0x1f)
-#define	BITMASK(pos)		MKMASK(BIT_WIDTH(pos), pos & 0x1f)
-
-/* Register addresses */
-#if	__ASSEMBLER__
-# define	REG_ADDR(type, addr)	(addr)
-#else	/* ! __ASSEMBLER__ */
-# define	REG_ADDR(type, addr)	(*(volatile type *)(addr))
-#endif	/* __ASSEMBLER__ */
-
-/* Cast a register to be an unsigned */
-/* CAUTION :	non naturally aligned foo can result into alignment traps
- *		use at own risk.
- */
-#define	CONTENTS(foo)	(*(unsigned *) &(foo))
-
-/* STRINGIFY -- perform all possible substitutions, then stringify */
-#define	__STR(x)	#x		/* just a helper macro */
-#define	STRINGIFY(x)	__STR(x)
-
-/* 
- * Stack pointer must always be a multiple of 16
- */
-#define	STACK_INCR	16
-#define	ROUND_FRAME(x)	((((unsigned)(x)) + STACK_INCR - 1) & ~(STACK_INCR-1))
-
-#endif /* _ARCH_PPC_REG_HELP_H_ */
diff -Nur cctools-855-ld64-236.3/include/foreign/Availability.h ../cctools-port.bak/cctools/include/foreign/Availability.h
--- cctools-855-ld64-236.3/include/foreign/Availability.h	2014-06-30 01:18:32.000000000 +0800
+++ ../cctools-port.bak/cctools/include/foreign/Availability.h	2014-06-30 02:06:45.566154528 +0800
@@ -1 +1,4 @@
 //fake headers
+#ifdef __APPLE__
+#include_next <Availability.h>
+#endif /* __APPLE__ */
diff -Nur cctools-855-ld64-236.3/include/foreign/AvailabilityMacros.h ../cctools-port.bak/cctools/include/foreign/AvailabilityMacros.h
--- cctools-855-ld64-236.3/include/foreign/AvailabilityMacros.h	2014-06-30 01:18:32.000000000 +0800
+++ ../cctools-port.bak/cctools/include/foreign/AvailabilityMacros.h	2014-06-30 02:06:45.563154528 +0800
@@ -0,0 +1,3 @@
+#ifdef __APPLE__
+#include_next <AvailabilityMacros.h>
+#endif /* __APPLE__ */
diff -Nur cctools-855-ld64-236.3/include/foreign/i386/endian.h ../cctools-port.bak/cctools/include/foreign/i386/endian.h
--- cctools-855-ld64-236.3/include/foreign/i386/endian.h	2014-06-30 01:18:32.000000000 +0800
+++ ../cctools-port.bak/cctools/include/foreign/i386/endian.h	2014-06-30 02:06:45.565154528 +0800
@@ -90,13 +90,20 @@
 
 #if	defined(KERNEL) || (!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE))
 
+#undef LITTLE_ENDIAN
+#undef BIG_ENDIAN
+#undef PDP_ENDIAN
+#undef BYTE_ORDER
+
 #define	LITTLE_ENDIAN	__DARWIN_LITTLE_ENDIAN
 #define	BIG_ENDIAN	__DARWIN_BIG_ENDIAN
 #define	PDP_ENDIAN	__DARWIN_PDP_ENDIAN
 
 #define	BYTE_ORDER	__DARWIN_BYTE_ORDER
 
+#if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__)
 #include <sys/_endian.h>
+#endif /* __FreeBSD__ || __NetBSD__ || __OpenBSD__ */
 
 #endif /* defined(KERNEL) || (!defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)) */
 #endif /* !_I386__ENDIAN_H_ */
diff -Nur cctools-855-ld64-236.3/include/foreign/i386/signal.h ../cctools-port.bak/cctools/include/foreign/i386/signal.h
--- cctools-855-ld64-236.3/include/foreign/i386/signal.h	2014-06-30 01:18:32.000000000 +0800
+++ ../cctools-port.bak/cctools/include/foreign/i386/signal.h	2014-06-30 02:06:45.565154528 +0800
@@ -40,7 +40,9 @@
 
 #if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
 
+#if !defined(__FreeBSD__) && !defined(__NetBSD__) && !defined(__OpenBSD__)
 #include <sys/appleapiopts.h>
+#endif /* !__FreeBSD__ && !__NetBSD__ && !__OpenBSD__ */
 
 #ifdef __APPLE_API_OBSOLETE
 
diff -Nur cctools-855-ld64-236.3/include/foreign/i386/_types.h ../cctools-port.bak/cctools/include/foreign/i386/_types.h
--- cctools-855-ld64-236.3/include/foreign/i386/_types.h	2014-06-30 01:18:32.000000000 +0800
+++ ../cctools-port.bak/cctools/include/foreign/i386/_types.h	2014-06-30 02:06:45.565154528 +0800
@@ -43,9 +43,13 @@
 typedef	unsigned short		__uint16_t;
 typedef int			__int32_t;
 typedef unsigned int		__uint32_t;
-typedef long int		__int64_t;
-typedef unsigned long int	__uint64_t;
-
+#if __SIZEOF_POINTER__ < 8
+typedef long long int		__int64_t;
+typedef unsigned long long  int	__uint64_t;
+#else
+typedef long int       __int64_t;
+typedef unsigned long  int __uint64_t;
+#endif
 typedef long			__darwin_intptr_t;
 typedef unsigned int		__darwin_natural_t;
 
diff -Nur cctools-855-ld64-236.3/include/foreign/i386/types.h ../cctools-port.bak/cctools/include/foreign/i386/types.h
--- cctools-855-ld64-236.3/include/foreign/i386/types.h	2014-06-30 01:18:32.000000000 +0800
+++ ../cctools-port.bak/cctools/include/foreign/i386/types.h	2014-06-30 02:06:45.565154528 +0800
@@ -67,6 +67,9 @@
 #define	_MACHTYPES_H_
 
 #ifndef __ASSEMBLER__
+#if defined(__NetBSD__) || defined(__OpenBSD__)
+#include_next <machine/types.h> /* __cpu_simple_lock_t */
+#endif /* __NetBSD__ || __OpenBSD__ */
 #include <i386/_types.h>
 #include <sys/cdefs.h>
 /*
@@ -90,9 +93,17 @@
 typedef	unsigned int		u_int32_t;
 #ifndef _INT64_T
 #define _INT64_T
+#if !defined(__NetBSD__) && !defined(__OpenBSD__)
 typedef	long long		int64_t;
+#else
+typedef long            int64_t;
+#endif /* ! __NetBSD__ && !__OpenBSD__  */
 #endif
+#if !defined(__NetBSD__) && !defined(__OpenBSD__)
 typedef	unsigned long long	u_int64_t;
+#else
+typedef unsigned long       u_int64_t;
+#endif /* ! __NetBSD__ && !__OpenBSD__  */
 
 #if __LP64__
 typedef int64_t			register_t;
diff -Nur cctools-855-ld64-236.3/include/foreign/mach/mach_init.h ../cctools-port.bak/cctools/include/foreign/mach/mach_init.h
--- cctools-855-ld64-236.3/include/foreign/mach/mach_init.h	2014-06-30 01:18:32.000000000 +0800
+++ ../cctools-port.bak/cctools/include/foreign/mach/mach_init.h	2014-06-30 02:06:45.570154528 +0800
@@ -110,6 +110,9 @@
 extern	vm_size_t	vm_page_mask;
 extern	int		vm_page_shift;
 
+#undef trunc_page
+#undef round_page
+
 #define trunc_page(x)	((x) & (~(vm_page_size - 1)))
 #define round_page(x)	trunc_page((x) + (vm_page_size - 1))
 
diff -Nur cctools-855-ld64-236.3/include/foreign/mach/vm_inherit.h ../cctools-port.bak/cctools/include/foreign/mach/vm_inherit.h
--- cctools-855-ld64-236.3/include/foreign/mach/vm_inherit.h	2014-06-30 01:18:32.000000000 +0800
+++ ../cctools-port.bak/cctools/include/foreign/mach/vm_inherit.h	2014-06-30 02:06:45.569154528 +0800
@@ -72,7 +72,11 @@
  *	vm_inherit_t	inheritance codes.
  */
 
-typedef unsigned int		vm_inherit_t;	/* might want to change this */
+#if defined(__NetBSD__) || defined(__OpenBSD__)
+typedef  int                vm_inherit_t;   /* might want to change this */
+#else
+typedef unsigned int        vm_inherit_t;   /* might want to change this */
+#endif /* __NetBSD__ || __OpenBSD__ */
 
 /*
  *	Enumeration of valid values for vm_inherit_t.
diff -Nur cctools-855-ld64-236.3/include/foreign/mach/vm_prot.h ../cctools-port.bak/cctools/include/foreign/mach/vm_prot.h
--- cctools-855-ld64-236.3/include/foreign/mach/vm_prot.h	2014-06-30 01:18:32.000000000 +0800
+++ ../cctools-port.bak/cctools/include/foreign/mach/vm_prot.h	2014-06-30 02:06:45.571154528 +0800
@@ -88,6 +88,7 @@
  *	The default protection for newly-created virtual memory
  */
 
+#undef VM_PROT_DEFAULT
 #define VM_PROT_DEFAULT	(VM_PROT_READ|VM_PROT_WRITE)
 
 /*
diff -Nur cctools-855-ld64-236.3/include/foreign/machine/endian.h ../cctools-port.bak/cctools/include/foreign/machine/endian.h
--- cctools-855-ld64-236.3/include/foreign/machine/endian.h	2014-06-30 01:18:32.000000000 +0800
+++ ../cctools-port.bak/cctools/include/foreign/machine/endian.h	2014-06-30 02:06:45.565154528 +0800
@@ -28,6 +28,9 @@
 /*
  * Copyright 1995 NeXT Computer, Inc. All rights reserved.
  */
+#if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__)
+#include_next <machine/endian.h>
+#else
 #ifndef _BSD_MACHINE_ENDIAN_H_
 #define _BSD_MACHINE_ENDIAN_H_
 
@@ -42,3 +45,4 @@
 #endif
 
 #endif /* _BSD_MACHINE_ENDIAN_H_ */
+#endif /* __FreeBSD__ || __NetBSD__ || __OpenBSD__ */
diff -Nur cctools-855-ld64-236.3/include/foreign/machine/_limits.h ../cctools-port.bak/cctools/include/foreign/machine/_limits.h
--- cctools-855-ld64-236.3/include/foreign/machine/_limits.h	2014-06-30 01:18:32.000000000 +0800
+++ ../cctools-port.bak/cctools/include/foreign/machine/_limits.h	2014-06-30 02:06:45.565154528 +0800
@@ -25,6 +25,9 @@
  * 
  * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
  */
+#if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__)
+#include_next <machine/_limits.h>
+#else
 #ifndef _BSD_MACHINE__LIMITS_H_
 #define _BSD_MACHINE__LIMITS_H_
 
@@ -39,3 +42,4 @@
 #endif
 
 #endif /* _BSD_MACHINE__LIMITS_H_ */
+#endif /* __FreeBSD__ || __NetBSD__ || __OpenBSD__ */
diff -Nur cctools-855-ld64-236.3/include/foreign/machine/_types.h ../cctools-port.bak/cctools/include/foreign/machine/_types.h
--- cctools-855-ld64-236.3/include/foreign/machine/_types.h	2014-06-30 01:18:32.000000000 +0800
+++ ../cctools-port.bak/cctools/include/foreign/machine/_types.h	2014-06-30 02:06:45.565154528 +0800
@@ -25,6 +25,9 @@
  * 
  * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
  */
+#if defined(__FreeBSD__)
+#include_next <machine/_types.h>
+#else
 #ifndef _BSD_MACHINE__TYPES_H_
 #define _BSD_MACHINE__TYPES_H_
 
@@ -37,5 +40,5 @@
 #else
 #error architecture not supported
 #endif
-
 #endif /* _BSD_MACHINE__TYPES_H_ */
+#endif /* __FreeBSD__ */
diff -Nur cctools-855-ld64-236.3/include/foreign/sys/attr.h ../cctools-port.bak/cctools/include/foreign/sys/attr.h
--- cctools-855-ld64-236.3/include/foreign/sys/attr.h	2014-06-30 01:18:32.000000000 +0800
+++ ../cctools-port.bak/cctools/include/foreign/sys/attr.h	2014-06-30 02:06:45.566154528 +0800
@@ -1,3 +1,6 @@
+#ifdef __APPLE__
+#include_next <sys/attr.h>
+#else
 #ifndef _SYS_ATTR_H_
 #define _SYS_ATTR_H_
 
@@ -23,3 +26,5 @@
 int    getattrlist(const char*,void*,void*,size_t,unsigned int);
 
 #endif
+
+#endif /* __APPLE__ */
diff -Nur cctools-855-ld64-236.3/include/foreign/sys/_types.h ../cctools-port.bak/cctools/include/foreign/sys/_types.h
--- cctools-855-ld64-236.3/include/foreign/sys/_types.h	2014-06-30 01:18:32.000000000 +0800
+++ ../cctools-port.bak/cctools/include/foreign/sys/_types.h	2014-06-30 02:06:45.566154528 +0800
@@ -26,6 +26,9 @@
  * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
  */
 
+#if defined(__FreeBSD__) || defined(__APPLE__)
+#include_next <sys/_types.h>
+#else
 #ifndef _SYS__TYPES_H_
 #define _SYS__TYPES_H_
 
@@ -140,3 +143,4 @@
 #endif /* offsetof */
 #endif /* KERNEL */
 #endif	/* _SYS__TYPES_H_ */
+#endif /* __FreeBSD__ || __APPLE__ */
diff -Nur cctools-855-ld64-236.3/include/Makefile ../cctools-port.bak/cctools/include/Makefile
--- cctools-855-ld64-236.3/include/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ ../cctools-port.bak/cctools/include/Makefile	2014-06-30 02:06:45.571154528 +0800
@@ -0,0 +1,195 @@
+# Note that the macros are not used for the install target any more with the
+# change to the install(1) program.  Edit the install commands.
+
+ifneq "" "$(wildcard /bin/mkdirs)"
+  MKDIRS = /bin/mkdirs
+else
+  MKDIRS = /bin/mkdir -p
+endif
+
+FILES = mach-o/ldsyms.h mach-o/reloc.h \
+	mach-o/nlist.h mach-o/stab.h mach-o/loader.h mach-o/fat.h \
+	mach-o/dyld_debug.h mach-o/arch.h mach-o/gmon.h mach-o/ranlib.h \
+	mach-o/swap.h mach-o/getsect.h mach-o/i386/swap.h \
+	mach-o/ppc/swap.h mach-o/ppc/reloc.h mach-o/x86_64/reloc.h \
+	mach-o/dyld.h mach-o/dyld_gdb.h mach-o/arm/reloc.h mach-o/arm64/reloc.h
+
+LOCFILES = mach-o/rld_state.h mach-o/rld.h mach-o/sarld.h mach-o/kld.h \
+	   mach-o/redo_prebinding.h \
+	   mach-o/i860/swap.h mach-o/i860/reloc.h \
+	   mach-o/hppa/swap.h mach-o/hppa/reloc.h \
+	   mach-o/m88k/swap.h mach-o/m88k/reloc.h \
+	   mach-o/m68k/swap.h \
+	   mach-o/sparc/swap.h mach-o/sparc/reloc.h \
+	   cbt/libsyminfo.h mach-o/dyld_priv.h
+
+# Note that OTHER_SRCS do NOT get installed
+GAS_OTHER_SRCS = stuff/bytesex.h stuff/bool.h stuff/rnd.h stuff/errors.h \
+		 stuff/openstep_mach.h opcode/arm.h
+OTHER_SRCS = notes gnu/symseg.h \
+	     stuff/allocate.h stuff/arch.h stuff/execute.h \
+	     stuff/ofile.h stuff/lto.h stuff/llvm.h \
+	     stuff/hash_string.h stuff/breakout.h stuff/best_arch.h \
+	     stuff/hppa.h stuff/reloc.h stuff/vm_flush_cache.h \
+	     stuff/print.h stuff/version_number.h stuff/crc32.h sys/gmon.h \
+	     stuff/seg_addr_table.h stuff/dylib_table.h \
+	     stuff/SymLoc.h stuff/dylib_roots.h stuff/guess_short_name.h \
+	     stuff/macosx_deployment_target.h stuff/symbol_list.h \
+	     stuff/symbol.h stuff/unix_standard_mode.h \
+	     coff/base_relocs.h coff/bytesex.h coff/ms_dos_stub.h \
+	     coff/filehdr.h coff/aouthdr.h coff/scnhdr.h coff/syment.h \
+	     coff/debug_directory.h elf/dwarf2.h llvm-c/Disassembler.h \
+	     $(GAS_OTHER_SRCS)
+
+ENCUMBERED_SRCS = gnu/a.out.h gnu/exec.h
+
+# Note that MISSING_SRCS are those may not be on all build machines
+GAS_MISSING_SRCS = mach/m68k/thread_status.h \
+		   mach/i860/thread_status.h \
+		   mach/m88k/thread_status.h \
+		   architecture/m88k/fp_regs.h \
+		   architecture/m88k/reg_help.h \
+		   architecture/nrw/reg_help.h \
+		   architecture/nrw/macro_help.h \
+		   mach/hppa/thread_status.h \
+		   mach/sparc/thread_status.h \
+		   architecture/sparc/reg.h \
+		   mach/arm/thread_status.h \
+		   mach/arm/thread_state.h \
+		   mach/arm/_structs.h \
+		   mach/ppc/thread_status.h \
+		   mach/ppc/_structs.h
+
+MISSING_SRCS = mach/machine.h \
+	       architecture/i386/fpu.h architecture/i386/frame.h \
+	       i386/eflags.h mach/i386/_structs.h mach/i386/fp_reg.h \
+	       mach/i386/thread_state.h mach/i386/thread_status.h \
+	       standalone/libsa.h \
+	       $(GAS_MISSING_SRCS)
+		
+nextstep_INCDIR = /NextDeveloper/Headers
+nextstep_LOCINCDIR = /LocalDeveloper/Headers
+
+teflon_INCDIR = /System/Library/Frameworks/System.framework/Versions/B/Headers
+teflon_LOCINCDIR = /System/Library/Frameworks/System.framework/Versions/B/PrivateHeaders
+
+ifeq "macos" "$(RC_OS)"
+ macos_INCDIR := $(shell if [ "$(RC_RELEASE)" = "Beaker" ] ||    \
+			    [ "$(RC_RELEASE)" = "Bunsen" ] ||    \
+			    [ "$(RC_RELEASE)" = "Gonzo"  ] ||    \
+			    [ "$(RC_RELEASE)" = "Kodiak" ]; then \
+	 echo /System/Library/Frameworks/System.framework/Versions/B/Headers; \
+	 else echo /usr/include; \
+	 fi; )
+ macos_LOCINCDIR := $(shell if [ "$(RC_RELEASE)" = "Beaker" ] ||    \
+			       [ "$(RC_RELEASE)" = "Bunsen" ] ||    \
+			       [ "$(RC_RELEASE)" = "Gonzo"  ] ||    \
+			       [ "$(RC_RELEASE)" = "Kodiak" ]; then \
+ echo /System/Library/Frameworks/System.framework/Versions/B/PrivateHeaders; \
+ else echo /usr/local/include; \
+ fi; )
+else
+  macos_INCDIR = /System/Library/Frameworks/System.framework/Versions/B/Headers
+  macos_LOCINCDIR = /System/Library/Frameworks/System.framework/Versions/B/PrivateHeaders
+endif
+
+SRC_FILES = Makefile $(FILES) $(LOCFILES) $(OTHER_SRCS) $(MISSING_SRCS)
+GAS_SRC_FILES = Makefile $(GAS_OTHER_SRCS) $(GAS_MISSING_SRCS)
+ENCUMBERED_SRC_FILES = $(SRC_FILES) $(ENCUMBERED_SRCS)
+
+installsrc:
+	$(MKDIRS) $(SRCROOT)
+	chmod 755 $(SRCROOT)
+	gnutar cf - $(ENCUMBERED_SRC_FILES) | (cd $(SRCROOT); gnutar xf -)
+
+installGASsrc:
+	$(MKDIRS) $(SRCROOT)
+	chmod 755 $(SRCROOT)
+	gnutar cf - $(GAS_SRC_FILES) | (cd $(SRCROOT); gnutar xf -)
+
+install: dirs $(RC_OS)_install
+
+teflon_install macos_install: common_install
+
+nextstep_install: common_install
+	cd mach-o; \
+	    install -c -m 444 ${IFLAGS} gmon.h \
+	    ${DSTROOT}${$(RC_OS)_INCDIR}/mach-o
+
+common_install:
+	cd mach-o; \
+	    install -c -m 444 ${IFLAGS} arch.h ldsyms.h reloc.h \
+	    stab.h loader.h fat.h swap.h getsect.h nlist.h \
+	    ranlib.h ${DSTROOT}${$(RC_OS)_INCDIR}/mach-o
+	if [ $(OLD_DYLD_STUFF) ];				\
+	then							\
+	    cd mach-o; install -c -m 444 ${IFLAGS} dyld.h dyld_debug.h	\
+		${DSTROOT}${$(RC_OS)_INCDIR}/mach-o ;		\
+	fi
+	cd mach-o/i386; \
+	    install -c -m 444 ${IFLAGS} swap.h \
+	    ${DSTROOT}${$(RC_OS)_INCDIR}/mach-o/i386
+	cd mach-o/ppc; \
+	    install -c -m 444 ${IFLAGS} reloc.h swap.h \
+	    ${DSTROOT}${$(RC_OS)_INCDIR}/mach-o/ppc
+	cd mach-o/x86_64; \
+	    install -c -m 444 ${IFLAGS} reloc.h \
+	    ${DSTROOT}${$(RC_OS)_INCDIR}/mach-o/x86_64
+	cd mach-o/arm; \
+	    install -c -m 444 ${IFLAGS} reloc.h \
+	    ${DSTROOT}${$(RC_OS)_INCDIR}/mach-o/arm
+	cd mach-o/arm64; \
+	    install -c -m 444 ${IFLAGS} reloc.h \
+	    ${DSTROOT}${$(RC_OS)_INCDIR}/mach-o/arm64
+	cd mach-o/m68k; \
+	    install -c -m 444 ${IFLAGS} swap.h \
+	    ${DSTROOT}${$(RC_OS)_LOCINCDIR}/mach-o/m68k
+	cd mach-o/sparc; \
+	    install -c -m 444 ${IFLAGS} reloc.h swap.h \
+	    ${DSTROOT}${$(RC_OS)_LOCINCDIR}/mach-o/sparc
+	cd mach-o/hppa; \
+	    install -c -m 444 ${IFLAGS} reloc.h swap.h \
+	    ${DSTROOT}${$(RC_OS)_LOCINCDIR}/mach-o/hppa
+	cd mach-o/i860; \
+	    install -c -m 444 ${IFLAGS} reloc.h swap.h \
+	    ${DSTROOT}${$(RC_OS)_LOCINCDIR}/mach-o/i860
+	cd mach-o/m88k; \
+	    install -c -m 444 ${IFLAGS} reloc.h swap.h \
+	    ${DSTROOT}${$(RC_OS)_LOCINCDIR}/mach-o/m88k
+	cd mach-o; \
+	    install -c -m 444 ${IFLAGS} rld.h rld_state.h \
+	    ${DSTROOT}${$(RC_OS)_LOCINCDIR}/mach-o
+	if [ $(OLD_DYLD_STUFF) ];					  \
+	then								  \
+	    cd mach-o; install -c -m 444 ${IFLAGS} dyld_gdb.h dyld_priv.h \
+		${DSTROOT}${$(RC_OS)_LOCINCDIR}/mach-o ;		  \
+	fi
+	cd mach-o; \
+	    install -c -m 444 ${IFLAGS} sarld.h kld.h redo_prebinding.h \
+	    ${DSTROOT}${$(RC_OS)_LOCINCDIR}/mach-o
+	cd stuff; \
+	    install -c -m 444 ${IFLAGS} bool.h \
+	    ${DSTROOT}${$(RC_OS)_LOCINCDIR}/dyld
+	cd cbt; \
+	    install -c -m 444 ${IFLAGS} libsyminfo.h \
+	    ${DSTROOT}${$(RC_OS)_LOCINCDIR}/cbt
+
+dirs:
+	$(MKDIRS) ${DSTROOT}${$(RC_OS)_INCDIR}/mach-o/i386
+	$(MKDIRS) ${DSTROOT}${$(RC_OS)_INCDIR}/mach-o/ppc
+	$(MKDIRS) ${DSTROOT}${$(RC_OS)_INCDIR}/mach-o/x86_64
+	$(MKDIRS) ${DSTROOT}${$(RC_OS)_INCDIR}/mach-o/arm
+	$(MKDIRS) ${DSTROOT}${$(RC_OS)_INCDIR}/mach-o/arm64
+	$(MKDIRS) ${DSTROOT}${$(RC_OS)_LOCINCDIR}/mach-o/m68k
+	$(MKDIRS) ${DSTROOT}${$(RC_OS)_LOCINCDIR}/mach-o/sparc
+	$(MKDIRS) ${DSTROOT}${$(RC_OS)_LOCINCDIR}/mach-o/hppa
+	$(MKDIRS) ${DSTROOT}${$(RC_OS)_LOCINCDIR}/mach-o/i860
+	$(MKDIRS) ${DSTROOT}${$(RC_OS)_LOCINCDIR}/mach-o/m88k
+	$(MKDIRS) ${DSTROOT}${$(RC_OS)_LOCINCDIR}/dyld
+	$(MKDIRS) ${DSTROOT}${$(RC_OS)_LOCINCDIR}/cbt
+
+depend:
+
+clean shlib_clean:
+
+all:
diff -Nur cctools-855-ld64-236.3/include/stuff/bytesex.h ../cctools-port.bak/cctools/include/stuff/bytesex.h
--- cctools-855-ld64-236.3/include/stuff/bytesex.h	2014-06-30 02:37:05.623089469 +0800
+++ ../cctools-port.bak/cctools/include/stuff/bytesex.h	2014-06-30 02:06:45.563154528 +0800
@@ -307,11 +307,11 @@
     arm_thread_state_t *cpu,
     enum byte_sex target_byte_sex);
 
-extern void swap_arm_thread_state64_t(
+void swap_arm_thread_state64_t(
     arm_thread_state64_t *cpu,
     enum byte_sex target_byte_sex);
 
-extern void swap_ident_command(
+void swap_ident_command(
     struct ident_command *id_cmd,
     enum byte_sex target_byte_sex);
 
@@ -355,7 +355,7 @@
     struct encryption_info_command_64 *ec,
     enum byte_sex target_byte_sex);
 
-extern void swap_linker_option_command(
+void swap_linker_option_command(
     struct linker_option_command *lo,
     enum byte_sex target_byte_sex);
 
diff -Nur cctools-855-ld64-236.3/include/stuff/errors.h ../cctools-port.bak/cctools/include/stuff/errors.h
--- cctools-855-ld64-236.3/include/stuff/errors.h	2014-06-30 02:37:05.627089469 +0800
+++ ../cctools-port.bak/cctools/include/stuff/errors.h	2014-06-30 02:06:45.563154528 +0800
@@ -1,18 +1,18 @@
 /*
  * Copyright (c) 2004, Apple Computer, Inc. All rights reserved.
- * 
+ *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1.  Redistributions of source code must retain the above copyright
- *     notice, this list of conditions and the following disclaimer. 
+ *     notice, this list of conditions and the following disclaimer.
  * 2.  Redistributions in binary form must reproduce the above copyright
  *     notice, this list of conditions and the following disclaimer in the
- *     documentation and/or other materials provided with the distribution. 
+ *     documentation and/or other materials provided with the distribution.
  * 3.  Neither the name of Apple Computer, Inc. ("Apple") nor the names of
  *     its contributors may be used to endorse or promote products derived
- *     from this software without specific prior written permission. 
- * 
+ *     from this software without specific prior written permission.
+ *
  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS "AS IS" AND
  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
@@ -25,7 +25,7 @@
  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
-#include "mach/mach.h"
+#import "mach/mach.h"
 
 /* user defined (imported) */
 extern char *progname __attribute__((visibility("hidden")));
diff -Nur cctools-855-ld64-236.3/include/stuff/llvm.h ../cctools-port.bak/cctools/include/stuff/llvm.h
--- cctools-855-ld64-236.3/include/stuff/llvm.h	2014-06-30 02:37:05.621089469 +0800
+++ ../cctools-port.bak/cctools/include/stuff/llvm.h	2014-06-30 02:06:45.563154528 +0800
@@ -22,7 +22,7 @@
     char *OutString,
     size_t OutStringSize);
 
-extern int llvm_disasm_set_options(
+__private_extern__ int llvm_disasm_set_options(
     LLVMDisasmContextRef DC,
     uint64_t Options);
 
diff -Nur cctools-855-ld64-236.3/ld64/configure.ac ../cctools-port.bak/cctools/ld64/configure.ac
--- cctools-855-ld64-236.3/ld64/configure.ac	2014-06-30 01:18:32.000000000 +0800
+++ ../cctools-port.bak/cctools/ld64/configure.ac	1970-01-01 08:00:00.000000000 +0800
@@ -1,207 +0,0 @@
-#                                               -*- Autoconf -*-
-# Process this file with autoconf to produce a configure script.
-
-AC_PREREQ([2.68])
-AC_INIT(ld64, 134.9, http://www.i-soft.com.cn)
-AC_CANONICAL_BUILD
-AC_CANONICAL_HOST
-AC_CANONICAL_TARGET
-
-AC_ARG_PROGRAM
-
-AM_INIT_AUTOMAKE([1.10 no-define no-dist-gzip dist-bzip2 tar-ustar])
-AC_CONFIG_MACRO_DIR([m4])
-AM_MAINTAINER_MODE
-
-CC=clang
-CXX=clang++
-
-# Checks for programs.
-AC_CHECK_PROG([CC], [clang],[clang],[clang not found])
-if test "$CC" = "clang not found"; then
-AC_MSG_ERROR("Couldn't find clang.")
-fi
-
-AC_CHECK_PROG([CXX], [clang++],[clang++],[clang++ not found])
-if test "$CXX" = "clang++ not found"; then
-AC_MSG_ERROR("Couldn't find clang++.")
-fi
-
-AC_PROG_CC
-AC_PROG_CXX
-AM_PROG_CC_C_O
-
-if test "$CC" != "clang"; then
-AC_MSG_ERROR("You must use clang to compile it")
-fi
-
-if test "$CXX" != "clang++"; then
-AC_MSG_ERROR("You must use clang to compile it")
-fi
-
-WARNINGS=""
-
-ORIGCFLAGS=$CFLAGS
-CFLAGS="$CFLAGS -Wall"
-AC_MSG_CHECKING([if -Wall is supported])
-AC_COMPILE_IFELSE(
-   [AC_LANG_SOURCE([[const char hw[] = "Hello, World\n";]])],
-   [WARNINGS="$WARNINGS -Wall"
-    AC_MSG_RESULT([yes])],
-   [AC_MSG_RESULT([no])]
-)
-CFLAGS=$ORIGCFLAGS
-
-ORIGCFLAGS=$CFLAGS
-CFLAGS="$CFLAGS -Wno-long-long"
-AC_MSG_CHECKING([if -Wno-long-long is supported])
-AC_COMPILE_IFELSE(
-   [AC_LANG_SOURCE([[const char hw[] = "Hello, World\n";]])],
-   [WARNINGS="$WARNINGS -Wno-long-long"
-    AC_MSG_RESULT([yes])],
-   [AC_MSG_RESULT([no])]
-)
-CFLAGS=$ORIGCFLAGS
-
-ORIGCFLAGS=$CFLAGS
-CFLAGS="$CFLAGS -Wno-import"
-AC_MSG_CHECKING([if -Wno-import is supported])
-AC_COMPILE_IFELSE(
-   [AC_LANG_SOURCE([[const char hw[] = "Hello, World\n";]])],
-   [WARNINGS="$WARNINGS -Wno-import"
-    AC_MSG_RESULT([yes])],
-   [AC_MSG_RESULT([no])]
-)
-CFLAGS=$ORIGCFLAGS
-
-ORIGCFLAGS=$CFLAGS
-CFLAGS="$CFLAGS -Wno-format"
-AC_MSG_CHECKING([if -Wno-format is supported])
-AC_COMPILE_IFELSE(
-   [AC_LANG_SOURCE([[const char hw[] = "Hello, World\n";]])],
-   [WARNINGS="$WARNINGS -Wno-format"
-    AC_MSG_RESULT([yes])],
-   [AC_MSG_RESULT([no])]
-)
-CFLAGS=$ORIGCFLAGS
-
-ORIGCFLAGS=$CFLAGS
-CFLAGS="$CFLAGS -Wno-deprecated"
-AC_MSG_CHECKING([if -Wno-deprecated is supported])
-AC_COMPILE_IFELSE(
-   [AC_LANG_SOURCE([[const char hw[] = "Hello, World\n";]])],
-   [WARNINGS="$WARNINGS -Wno-deprecated"
-    AC_MSG_RESULT([yes])],
-   [AC_MSG_RESULT([no])]
-)
-CFLAGS=$ORIGCFLAGS
-
-ORIGCFLAGS=$CFLAGS
-CFLAGS="$CFLAGS -Wno-unused-variable"
-AC_MSG_CHECKING([if -Wno-unused-variable is supported])
-AC_COMPILE_IFELSE(
-   [AC_LANG_SOURCE([[const char hw[] = "Hello, World\n";]])],
-   [WARNINGS="$WARNINGS -Wno-unused-variable"
-    AC_MSG_RESULT([yes])],
-   [AC_MSG_RESULT([no])]
-)
-CFLAGS=$ORIGCFLAGS
-
-ORIGCFLAGS=$CFLAGS
-CFLAGS="$CFLAGS -Wno-invalid-offsetof"
-AC_MSG_CHECKING([if -Wno-invalid-offsetof is supported])
-AC_COMPILE_IFELSE(
-   [AC_LANG_SOURCE([[const char hw[] = "Hello, World\n";]])],
-   [WARNINGS="$WARNINGS -Wno-invalid-offsetof"
-    AC_MSG_RESULT([yes])],
-   [AC_MSG_RESULT([no])]
-)
-CFLAGS=$ORIGCFLAGS
-
-
-ORIGCFLAGS=$CFLAGS
-CFLAGS="$CFLAGS -Wno-unused-private-field"
-AC_MSG_CHECKING([if -Wno-unused-private-field is supported])
-AC_COMPILE_IFELSE(
-   [AC_LANG_SOURCE([[const char hw[] = "Hello, World\n";]])],
-   [WARNINGS="$WARNINGS -Wno-unused-private-field"
-    AC_MSG_RESULT([yes])],
-   [AC_MSG_RESULT([no])]
-)
-CFLAGS=$ORIGCFLAGS
-
-AC_SUBST([WARNINGS], [$WARNINGS])
-
-# Checks for header files.
-AC_CHECK_HEADERS([stddef.h stdint.h stdlib.h])
-
-LT_PREREQ([2.2.6])
-LT_INIT(disable-static)
-
-# Checks for typedefs, structures, and compiler characteristics.
-#AC_CHECK_HEADER_STDBOOL
-AC_TYPE_INT16_T
-AC_TYPE_INT32_T
-AC_TYPE_PID_T
-AC_TYPE_SIZE_T
-AC_TYPE_UINT16_T
-AC_TYPE_UINT32_T
-AC_TYPE_UINT8_T
-
-# Checks for library functions.
-AC_FUNC_CHOWN
-AC_FUNC_FORK
-AC_CHECK_FUNCS([memset strdup strrchr strtoul])
-
-AC_CHECK_LIB([dl],[dlopen],[
-         DL_LIBS=-ldl
-         ])
-AC_SUBST(DL_LIBS)
-
-AC_CHECK_LIB([pthread],[pthread_create],[
-         PTHREAD_LDFLAG=-pthread
-         ])
-AC_SUBST(PTHREAD_LDFLAG)
-
-AC_CHECK_LIB([uuid],[uuid_generate_random],[
-         UUID_LIBS=-luuid
-         ])
-AC_SUBST(UUID_LIBS)
-
-AC_CHECK_LIB([crypto],[MD5_Init],[
-         CRYPT_LIBS=-lcrypto
-         ])
-AC_SUBST(CRYPT_LIBS)
-
-
-# Check LTO
-AC_CHECK_PROG([llvm_config], [llvm-config],[yes],[no])
-if test "x$llvm-config" = "xno"; then
-        AC_MSG_ERROR("Could not find llvm-config.")
-else
-        LLVM_LIBDIR=`llvm-config --libdir`
-        if test -f $LLVM_LIBDIR/libLTO.so;then
-                LTO_LIBS="-L`llvm-config --libdir` -lLTO"
-                LTO_DEFS="-DLTO_SUPPORT=1"
-        fi
-fi
-
-AC_SUBST(LTO_LIBS)
-AC_SUBST(LTO_DEFS)
-
-
-AC_C_BIGENDIAN([AC_SUBST([ENDIAN_FLAG],[-D__BIG_ENDIAN__=1])],
-           [AC_SUBST([ENDIAN_FLAG],[-D__LITTLE_ENDIAN__=1])])
-
-
-
-AC_OUTPUT([
-	   Makefile
-	   src/Makefile
-	   src/3rd/Makefile
-	   src/3rd/BlocksRuntime/Makefile
-	   src/ld/Makefile
-	   src/ld/parsers/Makefile
-	   src/ld/passes/Makefile
-       src/other/Makefile
-])
diff -Nur cctools-855-ld64-236.3/ld64/src/3rd/helper.c ../cctools-port.bak/cctools/ld64/src/3rd/helper.c
--- cctools-855-ld64-236.3/ld64/src/3rd/helper.c	2014-06-30 02:37:05.687089467 +0800
+++ ../cctools-port.bak/cctools/ld64/src/3rd/helper.c	2014-06-30 02:06:45.575154528 +0800
@@ -13,32 +13,53 @@
 #include <mach/host_info.h>
 #include <sys/time.h>
 #include <assert.h>
+ 
+#if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__)
+#include <sys/sysctl.h>
+#endif
+
 #include "helper.h"
 
-const char ldVersionString[] = "134.9\n";
+const char ldVersionString[] = "236.3\n";
 
 
 void __assert_rtn(const char *func, const char *file, int line, const char *msg)
 {
+#ifdef __FreeBSD__
+    __assert(msg, file, line, func);
+#elif defined(__NetBSD__) || defined(__OpenBSD__)
+    __assert(msg, line, file);
+#else
     __assert(msg, file, line);
+#endif /* __FreeBSD__ */
 }
 
-
 int _NSGetExecutablePath(char *path, unsigned int *size)
 {
+#ifdef __FreeBSD__
+   int mib[4];
+   mib[0] = CTL_KERN;
+   mib[1] = KERN_PROC;
+   mib[2] = KERN_PROC_PATHNAME;
+   mib[3] = -1;
+   size_t cb = *size;
+   if (sysctl(mib, 4, path, &cb, NULL, 0) != 0)
+    return -1;
+   *size = cb;
+   return 0;
+#else
    int bufsize = *size;
    int ret_size;
-   char *localpath = (char*)malloc(bufsize);
-   bzero(localpath,bufsize);
-   ret_size = readlink("/proc/self/exe", localpath, bufsize);
+   ret_size = readlink("/proc/self/exe", path, bufsize-1);
    if (ret_size != -1)
    {
         *size = ret_size;
-        strcpy(path,localpath);
+        path[ret_size]=0;
         return 0;
    }
    else
     return -1;
+#endif
 }
 
 int _dyld_find_unwind_sections(void* i, struct dyld_unwind_sections* sec)
diff -Nur cctools-855-ld64-236.3/ld64/src/3rd/qsort_r.c ../cctools-port.bak/cctools/ld64/src/3rd/qsort_r.c
--- cctools-855-ld64-236.3/ld64/src/3rd/qsort_r.c	2014-06-30 02:37:05.687089467 +0800
+++ ../cctools-port.bak/cctools/ld64/src/3rd/qsort_r.c	2014-06-30 02:06:45.575154528 +0800
@@ -1,23 +1,429 @@
-#include "qsort_r.h"
+/*-
+ * Copyright (c) 1992, 1993
+ *  The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#define I_AM_QSORT_R
+#define qsort_r qsort_r_local
+
+#include <sys/cdefs.h>
+
+#include <errno.h>
+#include <stddef.h>
 #include <stdlib.h>
+#include <string.h>
 
-void *_qsort_thunk = NULL;
-int (*_qsort_saved_func)(void *, const void *, const void *) = NULL;
+#ifndef __FreeBSD__
+/* flsl.c */
+int
+flsl(long mask)
+{
+    int bit;
 
-static int _qsort_comparator(const void *a, const void *b);
+    if (mask == 0)
+        return (0);
+    for (bit = 1; mask != 1; bit++)
+        mask = (unsigned long)mask >> 1;
+    return (bit);
+}
 
-static int _qsort_comparator(const void *a, const void *b)
+/* fsl.c */
+int
+fls(int mask)
 {
-  return _qsort_saved_func(_qsort_thunk, a, b);
+    int bit;
+    if (mask == 0)
+        return (0);
+    for (bit = 1; mask != 1; bit++)
+        mask = (unsigned int)mask >> 1;
+    return (bit);
 }
+#endif
 
-void
-qsort_r_local(void *base, size_t nmemb, size_t size, void *thunk,
-    int (*compar)(void *, const void *, const void *))
+/*
+ * Swap two areas of size number of bytes.  Although qsort(3) permits random
+ * blocks of memory to be sorted, sorting pointers is almost certainly the
+ * common case (and, were it not, could easily be made so).  Regardless, it
+ * isn't worth optimizing; the SWAP's get sped up by the cache, and pointer
+ * arithmetic gets lost in the time required for comparison function calls.
+ */
+#define SWAP(a, b, count, size, tmp) { \
+    count = size; \
+    do { \
+        tmp = *a; \
+        *a++ = *b; \
+        *b++ = tmp; \
+    } while (--count); \
+}
+
+/* Copy one block of size size to another. */
+#define COPY(a, b, count, size, tmp1, tmp2) { \
+    count = size; \
+    tmp1 = a; \
+    tmp2 = b; \
+    do { \
+        *tmp1++ = *tmp2++; \
+    } while (--count); \
+}
+
+/*
+ * Build the list into a heap, where a heap is defined such that for
+ * the records K1 ... KN, Kj/2 >= Kj for 1 <= j/2 <= j <= N.
+ *
+ * There two cases.  If j == nmemb, select largest of Ki and Kj.  If
+ * j < nmemb, select largest of Ki, Kj and Kj+1.
+ */
+#define CREATE(initval, nmemb, par_i, child_i, par, child, size, count, tmp) { \
+    for (par_i = initval; (child_i = par_i * 2) <= nmemb; \
+        par_i = child_i) { \
+        child = base + child_i * size; \
+        if (child_i < nmemb && compar(thunk, child, child + size) < 0) { \
+            child += size; \
+            ++child_i; \
+        } \
+        par = base + par_i * size; \
+        if (compar(thunk, child, par) <= 0) \
+            break; \
+        SWAP(par, child, count, size, tmp); \
+    } \
+}
+
+/*
+ * Select the top of the heap and 'heapify'.  Since by far the most expensive
+ * action is the call to the compar function, a considerable optimization
+ * in the average case can be achieved due to the fact that k, the displaced
+ * elememt, is ususally quite small, so it would be preferable to first
+ * heapify, always maintaining the invariant that the larger child is copied
+ * over its parent's record.
+ *
+ * Then, starting from the *bottom* of the heap, finding k's correct place,
+ * again maintianing the invariant.  As a result of the invariant no element
+ * is 'lost' when k is assigned its correct place in the heap.
+ *
+ * The time savings from this optimization are on the order of 15-20% for the
+ * average case. See Knuth, Vol. 3, page 158, problem 18.
+ *
+ * XXX Don't break the #define SELECT line, below.  Reiser cpp gets upset.
+ */
+#define SELECT(par_i, child_i, nmemb, par, child, size, k, count, tmp1, tmp2) { \
+    for (par_i = 1; (child_i = par_i * 2) <= nmemb; par_i = child_i) { \
+        child = base + child_i * size; \
+        if (child_i < nmemb && compar(thunk, child, child + size) < 0) { \
+            child += size; \
+            ++child_i; \
+        } \
+        par = base + par_i * size; \
+        COPY(par, child, count, size, tmp1, tmp2); \
+    } \
+    for (;;) { \
+        child_i = par_i; \
+        par_i = child_i / 2; \
+        child = base + child_i * size; \
+        par = base + par_i * size; \
+        if (child_i == 1 || compar(thunk, k, par) < 0) { \
+            COPY(child, k, count, size, tmp1, tmp2); \
+            break; \
+        } \
+        COPY(child, par, count, size, tmp1, tmp2); \
+    } \
+}
+
+/*
+ * Heapsort -- Knuth, Vol. 3, page 145.  Runs in O (N lg N), both average
+ * and worst.  While heapsort is faster than the worst case of quicksort,
+ * the BSD quicksort does median selection so that the chance of finding
+ * a data set that will trigger the worst case is nonexistent.  Heapsort's
+ * only advantage over quicksort is that it requires little additional memory.
+ */
+__private_extern__ int
+__heapsort_r(vbase, nmemb, size, thunk, compar)
+    void *vbase;
+    size_t nmemb, size;
+    void *thunk;
+    int (*compar)(void *, const void *, const void *);
+{
+    size_t cnt, i, j, l;
+    char tmp, *tmp1, *tmp2;
+    char *base, *k, *p, *t;
+
+    if (nmemb <= 1)
+        return (0);
+
+    if (!size) {
+        errno = EINVAL;
+        return (-1);
+    }
+
+    if ((k = malloc(size)) == NULL)
+        return (-1);
+
+    /*
+     * Items are numbered from 1 to nmemb, so offset from size bytes
+     * below the starting address.
+     */
+    base = (char *)vbase - size;
+
+    for (l = nmemb / 2 + 1; --l;)
+        CREATE(l, nmemb, i, j, t, p, size, cnt, tmp);
+
+    /*
+     * For each element of the heap, save the largest element into its
+     * final slot, save the displaced element (k), then recreate the
+     * heap.
+     */
+    while (nmemb > 1) {
+        COPY(k, base + nmemb * size, cnt, size, tmp1, tmp2);
+        COPY(base + nmemb * size, base + size, cnt, size, tmp1, tmp2);
+        --nmemb;
+        SELECT(i, j, nmemb, t, p, size, k, cnt, tmp1, tmp2);
+    }
+    free(k);
+    return (0);
+}
+
+/* qsort.c */
+
+#include <string.h>
+
+#ifdef I_AM_QSORT_R
+typedef int      cmp_t(void *, const void *, const void *);
+#else
+typedef int      cmp_t(const void *, const void *);
+#endif
+#ifdef I_AM_QSORT_B
+static inline char  *med3(char *, char *, char *, cmp_t ^, void *) __attribute__((always_inline));
+#else
+static inline char  *med3(char *, char *, char *, cmp_t *, void *) __attribute__((always_inline));
+#endif
+static inline void   swapfunc(char *, char *, int, int) __attribute__((always_inline));
+
+#define min(a, b)   (a) < (b) ? a : b
+
+/*
+ * Qsort routine from Bentley & McIlroy's "Engineering a Sort Function".
+ */
+#define swapcode(TYPE, parmi, parmj, n) {       \
+    long i = (n) / sizeof (TYPE);           \
+    TYPE *pi = (TYPE *) (parmi);        \
+    TYPE *pj = (TYPE *) (parmj);        \
+    do {                        \
+        TYPE    t = *pi;        \
+        *pi++ = *pj;                \
+        *pj++ = t;              \
+        } while (--i > 0);              \
+}
+
+#define SWAPINIT(a, es) swaptype = ((char *)a - (char *)0) % sizeof(long) || \
+    es % sizeof(long) ? 2 : es == sizeof(long)? 0 : 1;
+
+static inline void
+swapfunc(a, b, n, swaptype)
+    char *a, *b;
+    int n, swaptype;
 {
-  _qsort_thunk = thunk;
-  _qsort_saved_func = compar;
+    if(swaptype <= 1)
+        swapcode(long, a, b, n)
+    else
+        swapcode(char, a, b, n)
+}
+
+#define swap(a, b)                  \
+    if (swaptype == 0) {                \
+        long t = *(long *)(a);          \
+        *(long *)(a) = *(long *)(b);        \
+        *(long *)(b) = t;           \
+    } else                      \
+        swapfunc(a, b, es, swaptype)
 
-  qsort(base, nmemb, size, _qsort_comparator);
+#define vecswap(a, b, n)    if ((n) > 0) swapfunc(a, b, n, swaptype)
+
+#ifdef I_AM_QSORT_R
+#define CMP(t, x, y) (cmp((t), (x), (y)))
+#else
+#define CMP(t, x, y) (cmp((x), (y)))
+#endif
+
+static inline char *
+med3(char *a, char *b, char *c,
+#ifdef I_AM_QSORT_B
+cmp_t ^cmp,
+#else
+cmp_t *cmp,
+#endif
+void *thunk
+#ifndef I_AM_QSORT_R
+__unused
+#endif
+)
+{
+    return CMP(thunk, a, b) < 0 ?
+           (CMP(thunk, b, c) < 0 ? b : (CMP(thunk, a, c) < 0 ? c : a ))
+              :(CMP(thunk, b, c) > 0 ? b : (CMP(thunk, a, c) < 0 ? a : c ));
 }
 
+#ifdef __LP64__
+#define DEPTH(x)    (2 * (flsl((long)(x)) - 1))
+#else /* !__LP64__ */
+#define DEPTH(x)    (2 * (fls((int)(x)) - 1))
+#endif /* __LP64__ */
+
+#ifdef I_AM_QSORT_R
+int __heapsort_r(void *, size_t, size_t, void *, int (*)(void *, const void *, const void *));
+#endif
+
+static void
+_qsort(void *a, size_t n, size_t es,
+#ifdef I_AM_QSORT_R
+void *thunk,
+#else
+#define thunk   NULL
+#endif
+#ifdef I_AM_QSORT_B
+cmp_t ^cmp,
+#else
+cmp_t *cmp,
+#endif
+int depth_limit)
+{
+    char *pa, *pb, *pc, *pd, *pl, *pm, *pn;
+    size_t d, r;
+    int cmp_result;
+    int swaptype, swap_cnt;
+
+loop:
+    if (depth_limit-- <= 0) {
+#ifdef I_AM_QSORT_B
+        heapsort_b(a, n, es, cmp);
+#elif defined(I_AM_QSORT_R)
+        __heapsort_r(a, n, es, thunk, cmp);
+#else
+        heapsort(a, n, es, cmp);
+#endif
+        return;
+    }
+    SWAPINIT(a, es);
+    swap_cnt = 0;
+    if (n < 7) {
+        for (pm = (char *)a + es; pm < (char *)a + n * es; pm += es)
+            for (pl = pm; 
+                 pl > (char *)a && CMP(thunk, pl - es, pl) > 0;
+                 pl -= es)
+                swap(pl, pl - es);
+        return;
+    }
+    pm = (char *)a + (n / 2) * es;
+    if (n > 7) {
+        pl = a;
+        pn = (char *)a + (n - 1) * es;
+        if (n > 40) {
+            d = (n / 8) * es;
+            pl = med3(pl, pl + d, pl + 2 * d, cmp, thunk);
+            pm = med3(pm - d, pm, pm + d, cmp, thunk);
+            pn = med3(pn - 2 * d, pn - d, pn, cmp, thunk);
+        }
+        pm = med3(pl, pm, pn, cmp, thunk);
+    }
+    swap(a, pm);
+    pa = pb = (char *)a + es;
+
+    pc = pd = (char *)a + (n - 1) * es;
+    for (;;) {
+        while (pb <= pc && (cmp_result = CMP(thunk, pb, a)) <= 0) {
+            if (cmp_result == 0) {
+                swap_cnt = 1;
+                swap(pa, pb);
+                pa += es;
+            }
+            pb += es;
+        }
+        while (pb <= pc && (cmp_result = CMP(thunk, pc, a)) >= 0) {
+            if (cmp_result == 0) {
+                swap_cnt = 1;
+                swap(pc, pd);
+                pd -= es;
+            }
+            pc -= es;
+        }
+        if (pb > pc)
+            break;
+        swap(pb, pc);
+        swap_cnt = 1;
+        pb += es;
+        pc -= es;
+    }
+
+    pn = (char *)a + n * es;
+    r = min(pa - (char *)a, pb - pa);
+    vecswap(a, pb - r, r);
+    r = min(pd - pc, pn - pd - es);
+    vecswap(pb, pn - r, r);
+
+    if (swap_cnt == 0) {  /* Switch to insertion sort */
+        r = 1 + n / 4; /* n >= 7, so r >= 2 */
+        for (pm = (char *)a + es; pm < (char *)a + n * es; pm += es)
+            for (pl = pm; 
+                 pl > (char *)a && CMP(thunk, pl - es, pl) > 0;
+                 pl -= es) {
+                swap(pl, pl - es);
+                if (++swap_cnt > r) goto nevermind;
+            }
+        return;
+    }
+
+nevermind:
+    if ((r = pb - pa) > es)
+#ifdef I_AM_QSORT_R
+        _qsort(a, r / es, es, thunk, cmp, depth_limit);
+#else
+        _qsort(a, r / es, es, cmp, depth_limit);
+#endif
+    if ((r = pd - pc) > es) {
+        /* Iterate rather than recurse to save stack space */
+        a = pn - r;
+        n = r / es;
+        goto loop;
+    }
+/*      qsort(pn - r, r / es, es, cmp);*/
+}
+
+void
+#ifdef I_AM_QSORT_R
+qsort_r(void *a, size_t n, size_t es, void *thunk, cmp_t *cmp)
+#elif defined(I_AM_QSORT_B)
+qsort_b(void *a, size_t n, size_t es, cmp_t ^cmp)
+#else
+qsort(void *a, size_t n, size_t es, cmp_t *cmp)
+#endif
+{
+    _qsort(a, n, es,
+#ifdef I_AM_QSORT_R
+        thunk,
+#endif
+        cmp, DEPTH(n));
+}
+
+
diff -Nur cctools-855-ld64-236.3/ld64/src/3rd/strlcat.c ../cctools-port.bak/cctools/ld64/src/3rd/strlcat.c
--- cctools-855-ld64-236.3/ld64/src/3rd/strlcat.c	2014-06-30 02:37:05.688089467 +0800
+++ ../cctools-port.bak/cctools/ld64/src/3rd/strlcat.c	2014-06-30 02:06:45.575154528 +0800
@@ -1,30 +1,38 @@
-#include <sys/types.h>
-#include <string.h>
-
-size_t strlcat(char *dst, const char *src, size_t siz)
-{
-   char *d = dst;
-   const char *s = src;
-   size_t n = siz;
-   size_t dlen;
-
-   /* Find the end of dst and adjust bytes left but don't go past end */
-   while (n-- != 0 && *d != '\0')
-       d++;
-   dlen = d - dst;
-   n = siz - dlen;
+/*
+ * Copyright (c) 2011 Apple, Inc. All rights reserved.
+ *
+ * @APPLE_LICENSE_HEADER_START@
+ * 
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this
+ * file.
+ * 
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ * 
+ * @APPLE_LICENSE_HEADER_END@
+ */
 
-   if (n == 0)
-       return(dlen + strlen(s));
-   while (*s != '\0') {
-       if (n != 1) {
-           *d++ = *s;
-           n--;
-       }
-       s++;
-   }
-   *d = '\0';
+#include <string.h>
 
-   return(dlen + (s - src));   /* count does not include NUL */
+size_t
+strlcat(char * restrict dst, const char * restrict src, size_t maxlen) {
+    const size_t srclen = strlen(src);
+    const size_t dstlen = strnlen(dst, maxlen);
+    if (dstlen == maxlen) return maxlen+srclen;
+    if (srclen < maxlen-dstlen) {
+        memcpy(dst+dstlen, src, srclen+1);
+    } else {
+        memcpy(dst+dstlen, src, maxlen-dstlen-1);
+        dst[maxlen-1] = '\0';
+    }
+    return dstlen + srclen;
 }
-
diff -Nur cctools-855-ld64-236.3/ld64/src/3rd/strlcpy.c ../cctools-port.bak/cctools/ld64/src/3rd/strlcpy.c
--- cctools-855-ld64-236.3/ld64/src/3rd/strlcpy.c	2014-06-30 02:37:05.688089467 +0800
+++ ../cctools-port.bak/cctools/ld64/src/3rd/strlcpy.c	2014-06-30 02:06:45.575154528 +0800
@@ -1,56 +1,37 @@
-/*      $OpenBSD: strlcpy.c,v 1.11 2006/05/05 15:27:38 millert Exp $        */
-
 /*
- * Copyright (c) 1998 Todd C. Miller <Todd.Miller@courtesan.com>
- *
- * Permission to use, copy, modify, and distribute this software for any
- * purpose with or without fee is hereby granted, provided that the above
- * copyright notice and this permission notice appear in all copies.
+ * Copyright (c) 2011 Apple, Inc. All rights reserved.
  *
- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
- * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
- * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
- * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ * @APPLE_LICENSE_HEADER_START@
+ * 
+ * This file contains Original Code and/or Modifications of Original Code
+ * as defined in and that are subject to the Apple Public Source License
+ * Version 2.0 (the 'License'). You may not use this file except in
+ * compliance with the License. Please obtain a copy of the License at
+ * http://www.opensource.apple.com/apsl/ and read it before using this
+ * file.
+ * 
+ * The Original Code and all software distributed under the License are
+ * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
+ * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
+ * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
+ * Please see the License for the specific language governing rights and
+ * limitations under the License.
+ * 
+ * @APPLE_LICENSE_HEADER_END@
  */
 
-#include <sys/types.h>
 #include <string.h>
 
-#ifndef HAVE_STRLCPY
-
-/*
- * Copy src to string dst of size siz.  At most siz-1 characters
- * will be copied.  Always NUL terminates (unless siz == 0).
- * Returns strlen(src); if retval >= siz, truncation occurred.
- */
 size_t
-strlcpy(char *dst, const char *src, size_t siz)
-{
-        char *d = dst;
-        const char *s = src;
-        size_t n = siz;
-
-        /* Copy as many bytes as will fit */
-        if (n != 0) {
-                while (--n != 0) {
-                        if ((*d++ = *s++) == '\0')
-                                break;
-                }
-        }
-
-        /* Not enough room in dst, add NUL and traverse rest of src */
-        if (n == 0) {
-                if (siz != 0)
-                        *d = '\0';                /* NUL-terminate dst */
-                while (*s++)
-                        ;
-        }
-
-        return(s - src - 1);        /* count does not include NUL */
+strlcpy(char * restrict dst, const char * restrict src, size_t maxlen) {
+    const size_t srclen = strlen(src);
+    if (srclen < maxlen) {
+        memcpy(dst, src, srclen+1);
+    } else if (maxlen != 0) {
+        memcpy(dst, src, maxlen-1);
+        dst[maxlen-1] = '\0';
+    }
+    return srclen;
 }
 
-#endif
-
diff -Nur cctools-855-ld64-236.3/ld64/src/abstraction/MachOFileAbstraction.hpp ../cctools-port.bak/cctools/ld64/src/abstraction/MachOFileAbstraction.hpp
--- cctools-855-ld64-236.3/ld64/src/abstraction/MachOFileAbstraction.hpp	2014-04-05 06:42:29.000000000 +0800
+++ ../cctools-port.bak/cctools/ld64/src/abstraction/MachOFileAbstraction.hpp	2014-06-30 02:06:45.575154528 +0800
@@ -244,6 +244,10 @@
 
 
 // hack until arm64 headers are worked out
+#undef CPU_TYPE_ARM64
+#undef CPU_SUBTYPE_ARM64_ALL
+#undef CPU_SUBTYPE_ARM64_V8
+
 #define CPU_TYPE_ARM64			(CPU_TYPE_ARM | CPU_ARCH_ABI64)
 #define CPU_SUBTYPE_ARM64_ALL	0
 #define CPU_SUBTYPE_ARM64_V8    1
diff -Nur cctools-855-ld64-236.3/ld64/src/configure.h ../cctools-port.bak/cctools/ld64/src/configure.h
--- cctools-855-ld64-236.3/ld64/src/configure.h	2014-06-30 02:37:05.689089467 +0800
+++ ../cctools-port.bak/cctools/ld64/src/configure.h	2014-06-30 02:06:45.575154528 +0800
@@ -12,24 +12,39 @@
 
 #include "strlcat.h"
 #include "strlcpy.h"
+extern "C" {
 #include "helper.h"
+}
+
+#ifdef __GLIBCXX__
+#include <algorithm>
+#endif
 
 #define CPU_SUBTYPE_X86_ALL     ((cpu_subtype_t)3)
 
+#define SUPPORT_ARCH_armv4t 1
+#define SUPPORT_ARCH_armv5 1
+#define SUPPORT_ARCH_armv6 1
+#define SUPPORT_ARCH_armv7 1
+#define SUPPORT_ARCH_armv7f 1
+#define SUPPORT_ARCH_armv7k 1
+#define SUPPORT_ARCH_armv7s 1
+#define SUPPORT_ARCH_armv6m 1
+#define SUPPORT_ARCH_armv7m 1
+#define SUPPORT_ARCH_armv7em 1
+#define SUPPORT_ARCH_armv8 1
+#define SUPPORT_ARCH_arm64 1
+#define SUPPORT_ARCH_arm64v8 1
+#define SUPPORT_ARCH_i386 1
+#define SUPPORT_ARCH_x86_64 1
+#define SUPPORT_ARCH_x86_64h 1
 
-#define SUPPORT_ARCH_i386  1
-#define SUPPORT_ARCH_x86_64  1
-#define SUPPORT_ARCH_armv4t  1
-#define SUPPORT_ARCH_armv5  1
-#define SUPPORT_ARCH_armv6  1
-#define SUPPORT_ARCH_armv7  1
-#define SUPPORT_ARCH_armv7f  1
-#define SUPPORT_ARCH_armv7k  1
-#define SUPPORT_ARCH_armv7s  1
-#define ALL_SUPPORTED_ARCHS  "i386 x86_64 armv4t armv5 armv6 armv7 armv7f armv7k armv7s"
+#define ALL_SUPPORTED_ARCHS  "armv4t armv5 armv6 armv7 armv7f armv7k armv7s armv6m armv7m armv7em armv8 arm64 arm64v8 i386 x86_64 x86_64h"
 
 #define HW_NCPU      3
 #define CTL_HW      6
+
+#undef ARG_MAX
 #define ARG_MAX       131072
 
 #endif
diff -Nur cctools-855-ld64-236.3/ld64/src/ld/code-sign-blobs/blob.h ../cctools-port.bak/cctools/ld64/src/ld/code-sign-blobs/blob.h
--- cctools-855-ld64-236.3/ld64/src/ld/code-sign-blobs/blob.h	2014-06-30 02:37:05.689089467 +0800
+++ ../cctools-port.bak/cctools/ld64/src/ld/code-sign-blobs/blob.h	2014-06-30 02:06:45.576154528 +0800
@@ -45,7 +45,6 @@
 #include "endian.h"
 #include "memutils.h"
 #include <errno.h>
-#include <cstdio>
 #include <stdio.h>
 #include <string.h>
 #include <unistd.h>
diff -Nur cctools-855-ld64-236.3/ld64/src/ld/code-sign-blobs/memutils.h ../cctools-port.bak/cctools/ld64/src/ld/code-sign-blobs/memutils.h
--- cctools-855-ld64-236.3/ld64/src/ld/code-sign-blobs/memutils.h	2014-06-30 02:37:05.642089469 +0800
+++ ../cctools-port.bak/cctools/ld64/src/ld/code-sign-blobs/memutils.h	2014-06-30 02:06:45.576154528 +0800
@@ -33,6 +33,9 @@
 #include <stdlib.h>
 #include <algorithm>
 
+#ifdef __GLIBCXX__
+using namespace __gnu_cxx;
+#endif
 
 //
 // Encapsulate these very sharp tools in a separate (ugly-named) namespace
@@ -46,12 +49,13 @@
 //
 static const size_t systemAlignment = 4;
 
-
+#ifndef __GXX_EXPERIMENTAL_CXX0X__
 //
 // Get the local alignment for a type, as used by the acting compiler.
 //
 template <class T>
 inline size_t alignof() { struct { char c; T t; } s; return sizeof(s) - sizeof(T); }
+#endif
 
 
 //
diff -Nur cctools-855-ld64-236.3/ld64/src/ld/InputFiles.cpp ../cctools-port.bak/cctools/ld64/src/ld/InputFiles.cpp
--- cctools-855-ld64-236.3/ld64/src/ld/InputFiles.cpp	2014-06-30 02:37:05.690089467 +0800
+++ ../cctools-port.bak/cctools/ld64/src/ld/InputFiles.cpp	2014-06-30 02:06:45.577154528 +0800
@@ -187,9 +187,11 @@
     if ( result != NULL  )
 		return result;
 
+#ifdef LTO_SUPPORT
 	result = lto::archName(p, len);
 	if ( result != NULL  )
 		 return result;
+#endif /* LTO_SUPPORT */
 	
 	if ( strncmp((const char*)p, "!<arch>\n", 8) == 0 )
 		return "archive";
@@ -292,6 +294,7 @@
 		return objResult;
 	}
 
+#ifdef LTO_SUPPORT
 	// see if it is an llvm object file
 	objResult = lto::parse(p, len, info.path, info.modTime, info.ordinal, _options.architecture(), _options.subArchitecture(), _options.logAllFiles(), _options.verboseOptimizationHints());
 	if ( objResult != NULL ) {
@@ -299,6 +302,7 @@
 		OSAtomicIncrement32(&_totalObjectLoaded);
 		return objResult;
 	}
+#endif /* LTO_SUPPORT */
 	
 	// see if it is a dynamic library
 	ld::dylib::File* dylibResult = mach_o::dylib::parse(p, len, info.path, info.modTime, _options, info.ordinal, info.options.fBundleLoader, indirectDylib);
@@ -322,6 +326,7 @@
 		return archiveResult;
 	}
 	
+#ifdef LTO_SUPPORT
 	// does not seem to be any valid linker input file, check LTO misconfiguration problems
 	if ( lto::archName((uint8_t*)p, len) != NULL ) {
 		if ( lto::libLTOisLoaded() ) {
@@ -349,6 +354,7 @@
 			throwf("could not process llvm bitcode object file, because %s could not be loaded", libLTO);
 		}
 	}
+#endif /* LTO_SUPPORT */
 
 	// error handling
 	if ( ((fat_header*)p)->magic == OSSwapBigToHostInt32(FAT_MAGIC) ) {
diff -Nur cctools-855-ld64-236.3/ld64/src/ld/ld.cpp ../cctools-port.bak/cctools/ld64/src/ld/ld.cpp
--- cctools-855-ld64-236.3/ld64/src/ld/ld.cpp	2014-06-30 02:37:05.691089467 +0800
+++ ../cctools-port.bak/cctools/ld64/src/ld/ld.cpp	2014-06-30 02:06:45.576154528 +0800
@@ -37,7 +37,9 @@
 #include <errno.h>
 #include <limits.h>
 #include <unistd.h>
+#if !defined(__FreeBSD__) && !defined(__NetBSD__) && !defined(__OpenBSD__)
 #include <execinfo.h>
+#endif /* !__FreeBSD__ && !__NetBSD__ && !__OpenBSD__ */
 #include <mach/mach_time.h>
 #include <mach/vm_statistics.h>
 #include <mach/mach_init.h>
@@ -1069,6 +1071,7 @@
 // implement assert() function to print out a backtrace before aborting
 void __assert_rtn(const char* func, const char* file, int line, const char* failedexpr)
 {
+#if !defined(__FreeBSD__) && !defined(__NetBSD__) && !defined(__OpenBSD__)
     Snapshot *snapshot = Snapshot::globalSnapshot;
     
     snapshot->setSnapshotMode(Snapshot::SNAPSHOT_DEBUG);
@@ -1094,6 +1097,7 @@
 		snapshot->recordAssertionMessage("%d  %p  %s + %ld\n", i, callStack[i], symboName, offset);
 	}
     fprintf(stderr, "A linker snapshot was created at:\n\t%s\n", snapshot->rootDir());
+#endif /* !__FreeBSD__ && !__NetBSD__ && !__OpenBSD__ */
 	fprintf(stderr, "ld: Assertion failed: (%s), function %s, file %s, line %d.\n", failedexpr, func, file, line);
 	exit(1);
 }
diff -Nur cctools-855-ld64-236.3/ld64/src/ld/Options.cpp ../cctools-port.bak/cctools/ld64/src/ld/Options.cpp
--- cctools-855-ld64-236.3/ld64/src/ld/Options.cpp	2014-06-30 02:37:05.701089467 +0800
+++ ../cctools-port.bak/cctools/ld64/src/ld/Options.cpp	2014-06-30 02:06:45.577154528 +0800
@@ -42,6 +42,8 @@
 #include "MachOFileAbstraction.hpp"
 #include "Snapshot.h"
 
+#include <ctype.h>
+
 // upward dependency on lto::version()
 namespace lto {
 	extern const char* version();
@@ -1728,7 +1730,7 @@
 	::close(fd);
 
 	// record section to create
-	ExtraSection info = { segment, section, path, (uint8_t*)p, stat_buf.st_size };
+	ExtraSection info = { segment, section, path, (uint8_t*)p, static_cast<uint64_t>(stat_buf.st_size) };
 	fExtraSections.push_back(info);
 }
 
@@ -3086,9 +3088,11 @@
 			fprintf(stderr, "configured to support archs: %s\n", ALL_SUPPORTED_ARCHS);
 			 // if only -v specified, exit cleanly
 			 if ( argc == 2 ) {
+#ifdef LTO_SUPPORT
 				const char* ltoVers = lto::version();
 				if ( ltoVers != NULL )
 					fprintf(stderr, "LTO support using: %s\n", ltoVers);
+#endif /* LTO_SUPPORT */
 				exit(0);
 			}
 		}
@@ -4334,7 +4338,7 @@
 
 	// make sure all required exported symbols exist
 	std::vector<const char*> impliedExports;
-	for (NameSet::iterator it=fExportSymbols.regularBegin(); it != fExportSymbols.regularEnd(); ++it) {
+	for (NameSet::const_iterator it=fExportSymbols.regularBegin(); it != fExportSymbols.regularEnd(); ++it) {
 		const char* name = *it;
 		const int len = strlen(name);
 		if ( (strcmp(&name[len-3], ".eh") == 0) || (strncmp(name, ".objc_category_name_", 20) == 0) ) {
@@ -4366,7 +4370,7 @@
 	}
 
 	// make sure all required re-exported symbols exist
-	for (NameSet::iterator it=fReExportSymbols.regularBegin(); it != fReExportSymbols.regularEnd(); ++it) {
+	for (NameSet::const_iterator it=fReExportSymbols.regularBegin(); it != fReExportSymbols.regularEnd(); ++it) {
 		fInitialUndefines.push_back(*it);
 	}
 	
diff -Nur cctools-855-ld64-236.3/ld64/src/ld/Options.h ../cctools-port.bak/cctools/ld64/src/ld/Options.h
--- cctools-855-ld64-236.3/ld64/src/ld/Options.h	2014-06-30 02:37:05.649089468 +0800
+++ ../cctools-port.bak/cctools/ld64/src/ld/Options.h	2014-06-30 02:06:45.579154528 +0800
@@ -389,8 +389,8 @@
 		bool					containsNonWildcard(const char*) const;
 		bool					empty() const			{ return fRegular.empty() && fWildCard.empty(); }
 		bool					hasWildCards() const	{ return !fWildCard.empty(); }
-		NameSet::iterator		regularBegin() const	{ return fRegular.begin(); }
-		NameSet::iterator		regularEnd() const		{ return fRegular.end(); }
+		NameSet::const_iterator		regularBegin() const	{ return fRegular.begin(); }
+		NameSet::const_iterator		regularEnd() const		{ return fRegular.end(); }
 		void					remove(const NameSet&); 
 	private:
 		static bool				hasWildCards(const char*);
diff -Nur cctools-855-ld64-236.3/ld64/src/ld/OutputFile.cpp ../cctools-port.bak/cctools/ld64/src/ld/OutputFile.cpp
--- cctools-855-ld64-236.3/ld64/src/ld/OutputFile.cpp	2014-04-05 06:42:29.000000000 +0800
+++ ../cctools-port.bak/cctools/ld64/src/ld/OutputFile.cpp	2014-06-30 02:06:45.578154528 +0800
@@ -38,7 +38,11 @@
 #include <mach/vm_statistics.h>
 #include <mach/mach_init.h>
 #include <mach/mach_host.h>
+#ifdef __FreeBSD__
+#include </usr/local/include/uuid/uuid.h>
+#else
 #include <uuid/uuid.h>
+#endif
 #include <dlfcn.h>
 #include <mach-o/dyld.h>
 #include <mach-o/fat.h>
@@ -2647,6 +2651,7 @@
 		if (stat_buf.st_mode & S_IFREG) {
 			outputIsRegularFile = true;
 			// <rdar://problem/12264302> Don't use mmap on non-hfs volumes
+#if 0
 			struct statfs fsInfo;
 			if ( statfs(_options.outputFilePath(), &fsInfo) != -1 ) {
 				if ( strcmp(fsInfo.f_fstypename, "hfs") == 0) {
@@ -2655,8 +2660,11 @@
 				}
 			}
 			else {
+#endif
 				outputIsMappableFile = false;
+#if 0
 			}
+#endif
 		} 
 		else {
 			outputIsRegularFile = false;
@@ -2671,12 +2679,14 @@
 		char* end = strrchr(dirPath, '/');
 		if ( end != NULL ) {
 			end[1] = '\0';
+#if 0
 			struct statfs fsInfo;
 			if ( statfs(dirPath, &fsInfo) != -1 ) {
 				if ( strcmp(fsInfo.f_fstypename, "hfs") == 0) {
 					outputIsMappableFile = true;
 				}
 			}
+#endif
 		}
 	}
 	
diff -Nur cctools-855-ld64-236.3/ld64/src/ld/parsers/archive_file.cpp ../cctools-port.bak/cctools/ld64/src/ld/parsers/archive_file.cpp
--- cctools-855-ld64-236.3/ld64/src/ld/parsers/archive_file.cpp	2014-04-05 06:42:29.000000000 +0800
+++ ../cctools-port.bak/cctools/ld64/src/ld/parsers/archive_file.cpp	2014-06-30 02:06:45.579154528 +0800
@@ -91,8 +91,10 @@
 private:
 	static bool										validMachOFile(const uint8_t* fileContent, uint64_t fileLength, 
 																	const mach_o::relocatable::ParserOptions& opts);
+#ifdef LTO_SUPPORT
 	static bool										validLTOFile(const uint8_t* fileContent, uint64_t fileLength, 
 																	const mach_o::relocatable::ParserOptions& opts);
+#endif /* LTO_SUPPORT */
 	static cpu_type_t								architecture();
 
 	class Entry : ar_hdr
@@ -232,11 +234,13 @@
 	return mach_o::relocatable::isObjectFile(fileContent, fileLength, opts);
 }
 
+#ifdef LTO_SUPPORT
 template <typename A>
 bool File<A>::validLTOFile(const uint8_t* fileContent, uint64_t fileLength, const mach_o::relocatable::ParserOptions& opts)
 {
 	return lto::isObjectFile(fileContent, fileLength, opts.architecture, opts.subType);
 }
+#endif /* LTO_SUPPORT */
 
 
 
@@ -257,7 +261,11 @@
 		if ( (p==start) && ((strcmp(memberName, SYMDEF_SORTED) == 0) || (strcmp(memberName, SYMDEF) == 0)) )
 			continue;
 		// archive is valid if first .o file is valid
-		return (validMachOFile(p->content(), p->contentSize(), opts) || validLTOFile(p->content(), p->contentSize(), opts));
+		return (validMachOFile(p->content(), p->contentSize(), opts)
+#ifdef LTO_SUPPORT
+             || validLTOFile(p->content(), p->contentSize(), opts)
+#endif /* LTO_SUPPORT */
+        );
 	}	
 	// empty archive
 	return true;
@@ -378,6 +386,7 @@
 			_instantiatedEntries[member] = state;
 			return _instantiatedEntries[member];
 		}
+#ifdef LTO_SUPPORT
 		// see if member is llvm bitcode file
 		result = lto::parse(member->content(), member->contentSize(), 
 								mPath, member->modificationTime(), ordinal, 
@@ -387,6 +396,7 @@
 			_instantiatedEntries[member] = state;
 			return _instantiatedEntries[member];
 		}
+#endif /* LTO_SUPPORT */
 			
 		throwf("archive member '%s' with length %d is not mach-o or llvm bitcode", memberName, member->contentSize());
 	}
diff -Nur cctools-855-ld64-236.3/ld64/src/ld/parsers/lto_file.cpp ../cctools-port.bak/cctools/ld64/src/ld/parsers/lto_file.cpp
--- cctools-855-ld64-236.3/ld64/src/ld/parsers/lto_file.cpp	2014-04-05 06:42:29.000000000 +0800
+++ ../cctools-port.bak/cctools/ld64/src/ld/parsers/lto_file.cpp	2014-06-30 02:06:45.579154528 +0800
@@ -22,10 +22,13 @@
  * @APPLE_LICENSE_HEADER_END@
  */
 
+#ifdef LTO_SUPPORT
+
 #ifndef __LTO_READER_H__
 #define __LTO_READER_H__
 
 #include <stdlib.h>
+#include <pthread.h>
 #include <sys/param.h>
 #include <sys/fcntl.h>
 #include <sys/stat.h>
@@ -43,6 +46,8 @@
 #include "lto_file.h"
 
 // #defines are a work around for <rdar://problem/8760268>
+#undef __STDC_LIMIT_MACROS
+#undef __STDC_CONSTANT_MACROS
 #define __STDC_LIMIT_MACROS 1
 #define __STDC_CONSTANT_MACROS 1
 #include "llvm-c/lto.h"
@@ -932,3 +937,4 @@
 
 #endif
 
+#endif /* LTO SUPPORT */
diff -Nur cctools-855-ld64-236.3/ld64/src/ld/parsers/macho_dylib_file.cpp ../cctools-port.bak/cctools/ld64/src/ld/parsers/macho_dylib_file.cpp
--- cctools-855-ld64-236.3/ld64/src/ld/parsers/macho_dylib_file.cpp	2014-04-05 06:42:29.000000000 +0800
+++ ../cctools-port.bak/cctools/ld64/src/ld/parsers/macho_dylib_file.cpp	2014-06-30 02:06:45.579154528 +0800
@@ -1074,6 +1074,8 @@
 		*subResult = CPU_SUBTYPE_ARM64_ALL;
 		return true;
 	}
+#if 0
+/* PORT FIXME (may not even be porting bug) */
 	if ( Parser<ppc>::validFile(fileContent, false) ) {
 		*result = CPU_TYPE_POWERPC;
 		const macho_header<Pointer32<BigEndian> >* header = (const macho_header<Pointer32<BigEndian> >*)fileContent;
@@ -1085,6 +1087,7 @@
 		*subResult = CPU_SUBTYPE_POWERPC_ALL;
 		return true;
 	}
+#endif
 	return false;
 }
 
diff -Nur cctools-855-ld64-236.3/ld64/src/ld/parsers/macho_relocatable_file.cpp ../cctools-port.bak/cctools/ld64/src/ld/parsers/macho_relocatable_file.cpp
--- cctools-855-ld64-236.3/ld64/src/ld/parsers/macho_relocatable_file.cpp	2014-06-30 02:37:05.695089467 +0800
+++ ../cctools-port.bak/cctools/ld64/src/ld/parsers/macho_relocatable_file.cpp	2014-06-30 02:06:45.578154528 +0800
@@ -2124,9 +2124,9 @@
 	
 	// sort by symbol table address
 	ParserAndSectionsArray extra = { this, sectionArray };
-    ::qsort_r_local(array, _symbolsInSections, sizeof(uint32_t), &extra, &symbolIndexSorter);
-
+	::qsort_r_local(array, _symbolsInSections, sizeof(uint32_t), &extra, &symbolIndexSorter);
 	
+
 	// look for two symbols at same address
 	_overlappingSymbols = false;
 	for (unsigned int i=1; i < _symbolsInSections; ++i) {
diff -Nur cctools-855-ld64-236.3/ld64/src/ld/passes/branch_island.cpp ../cctools-port.bak/cctools/ld64/src/ld/passes/branch_island.cpp
--- cctools-855-ld64-236.3/ld64/src/ld/passes/branch_island.cpp	2014-04-05 06:42:29.000000000 +0800
+++ ../cctools-port.bak/cctools/ld64/src/ld/passes/branch_island.cpp	2014-06-30 02:06:45.578154528 +0800
@@ -498,7 +498,7 @@
 				if ( target->section().type() == ld::Section::typeStub )
 					dstAddr = totalTextSize;
 				int64_t displacement = dstAddr - srcAddr;
-				TargetAndOffset finalTargetAndOffset = { target, addend };
+				TargetAndOffset finalTargetAndOffset = { target, static_cast<uint32_t>(addend) };
 				const int64_t kBranchLimit = kBetweenRegions;
 				if ( crossSectionBranch && ((displacement > kBranchLimit) || (displacement < (-kBranchLimit))) ) {
 					const ld::Atom* island;
diff -Nur cctools-855-ld64-236.3/ld64/src/ld/Resolver.cpp ../cctools-port.bak/cctools/ld64/src/ld/Resolver.cpp
--- cctools-855-ld64-236.3/ld64/src/ld/Resolver.cpp	2014-04-05 06:42:29.000000000 +0800
+++ ../cctools-port.bak/cctools/ld64/src/ld/Resolver.cpp	2014-06-30 02:06:45.577154528 +0800
@@ -1440,6 +1440,7 @@
 	if ( ! _haveLLVMObjs )
 		return;
 
+#ifdef LTO_SUPPORT
 	// <rdar://problem/15314161> LTO: Symbol multiply defined error should specify exactly where the symbol is found
     _symbolTable.checkDuplicateSymbols();
 
@@ -1533,6 +1534,9 @@
 		// check new code does not override some dylib
 		this->checkDylibSymbolCollisions();
 	}
+#else
+    throw "";
+#endif /* LTO_SUPPORT */
 }
 
 
diff -Nur cctools-855-ld64-236.3/ld64/src/other/machochecker.cpp ../cctools-port.bak/cctools/ld64/src/other/machochecker.cpp
--- cctools-855-ld64-236.3/ld64/src/other/machochecker.cpp	2014-04-05 06:42:29.000000000 +0800
+++ ../cctools-port.bak/cctools/ld64/src/other/machochecker.cpp	2014-06-30 02:06:45.579154528 +0800
@@ -533,7 +533,7 @@
 				else {
 					throw "overlapping segment vm addresses";
 				}
-				segmentAddressRanges.push_back(std::make_pair<pint_t, pint_t>(startAddr, endAddr));
+				segmentAddressRanges.push_back(std::make_pair<pint_t, pint_t>(static_cast<pint_t>(startAddr), static_cast<pint_t>(endAddr)));
 			}
 			// see if this overlaps another segment file offset range
 			uint64_t startOffset = segCmd->fileoff();
@@ -550,7 +550,7 @@
 				else {
 					throw "overlapping segment file data";
 				}
-				segmentFileOffsetRanges.push_back(std::make_pair<pint_t, pint_t>(startOffset, endOffset));
+				segmentFileOffsetRanges.push_back(std::make_pair<pint_t, pint_t>(static_cast<pint_t>(startOffset), static_cast<pint_t>(endOffset)));
 				// check is within file bounds
 				if ( (startOffset > fLength) || (endOffset > fLength) )
 					throw "segment file data is past end of file";
diff -Nur cctools-855-ld64-236.3/ld64/src/other/Makefile.am ../cctools-port.bak/cctools/ld64/src/other/Makefile.am
--- cctools-855-ld64-236.3/ld64/src/other/Makefile.am	2014-06-30 01:18:32.000000000 +0800
+++ ../cctools-port.bak/cctools/ld64/src/other/Makefile.am	2014-06-30 02:06:45.579154528 +0800
@@ -8,6 +8,7 @@
 	-fblocks \
 	-D__DARWIN_UNIX03 \
 	$(WARNINGS) \
+	-Wno-switch \
 	$(LTO_DEFS) \
 	$(ENDIAN_FLAGS) \
 	-I$(top_srcdir)/include \
diff -Nur cctools-855-ld64-236.3/ld64/src/other/ObjectDump.cpp ../cctools-port.bak/cctools/ld64/src/other/ObjectDump.cpp
--- cctools-855-ld64-236.3/ld64/src/other/ObjectDump.cpp	2014-04-05 06:42:29.000000000 +0800
+++ ../cctools-port.bak/cctools/ld64/src/other/ObjectDump.cpp	2014-06-30 02:06:45.579154528 +0800
@@ -35,6 +35,10 @@
 #include "parsers/macho_relocatable_file.h"
 #include "parsers/lto_file.h"
 
+#ifdef __GLIBCXX__
+#include <algorithm>
+#endif
+
 static bool			sDumpContent= true;
 static bool			sDumpStabs	= false;
 static bool			sSort		= true;
@@ -990,12 +994,15 @@
 		case ld::Fixup::kindStoreTargetAddressARM64PageOff12:
 			printf("ARM64 store 12-bit page offset of %s", referenceTargetAtomName(ref));
 			break;
+#if 0
+/* PORT FIXME (may not even be porting bug) */
 		case ld::Fixup::kindStoreTargetAddressARM64TLVPage21:
 			printf("ARM64 store 21-bit pcrel ADRP to TLV for %s", referenceTargetAtomName(ref));
 			break;
 		case ld::Fixup::kindStoreTargetAddressARM64TLVPageOff12:
 			printf("ARM64 store 12-bit page offset of TLV of %s", referenceTargetAtomName(ref));
 			break;
+#endif
 		case ld::Fixup::kindStoreTargetAddressARM64GOTLoadPage21:
 			printf("ARM64 store 21-bit pcrel ADRP to GOT for %s", referenceTargetAtomName(ref));
 			break;
@@ -1245,10 +1252,12 @@
 	if ( objResult != NULL )
 		return objResult;
 
+#ifdef LTO_SUPPORT
 	// see if it is an llvm object file
 	objResult = lto::parse(p, fileLen, path, stat_buf.st_mtime, ld::File::Ordinal::NullOrdinal(), sPreferredArch, sPreferredSubArch, false, true);
 	if ( objResult != NULL ) 
 		return objResult;
+#endif /* LTO_SUPPORT */
 
 	throwf("not a mach-o object file: %s", path);
 #else
diff -Nur cctools-855-ld64-236.3/libobjc2/block_to_imp.c ../cctools-port.bak/cctools/libobjc2/block_to_imp.c
--- cctools-855-ld64-236.3/libobjc2/block_to_imp.c	2014-06-30 02:37:05.357089479 +0800
+++ ../cctools-port.bak/cctools/libobjc2/block_to_imp.c	2014-06-30 02:06:45.580154528 +0800
@@ -12,6 +12,7 @@
 #include "lock.h"
 #include "visibility.h"
 
+int asprintf(char **strp, const char *fmt, ...); /* port hack */
 
 /* QNX needs a special header for asprintf() */
 #ifdef __QNXNTO__
diff -Nur cctools-855-ld64-236.3/libobjc2/lock.h ../cctools-port.bak/cctools/libobjc2/lock.h
--- cctools-855-ld64-236.3/libobjc2/lock.h	2014-06-30 02:37:05.660089468 +0800
+++ ../cctools-port.bak/cctools/libobjc2/lock.h	2014-06-30 02:06:45.582154528 +0800
@@ -3,7 +3,6 @@
  * threading implementation.  This file contains a VERY thin wrapper over the
  * Windows and POSIX mutex APIs.
  */
-
 #ifndef __LIBOBJC_LOCK_H_INCLUDED__
 #define __LIBOBJC_LOCK_H_INCLUDED__
 #ifdef WIN32
@@ -22,11 +21,19 @@
 typedef pthread_mutex_t mutex_t;
 // If this pthread implementation has a static initializer for recursive
 // mutexes, use that, otherwise fall back to the portable version
+#ifdef __APPLE__
+/* evil portability hack */
+/*
+#endif
 #	ifdef PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP
 #		define INIT_LOCK(x) x = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP
 #	elif defined(PTHREAD_RECURSIVE_MUTEX_INITIALIZER)
 #		define INIT_LOCK(x) x = PTHREAD_RECURSIVE_MUTEX_INITIALIZER
 #	else
+#ifdef __APPLE__
+*/
+#endif /* __APPLE__ */
+#if 1
 #		define INIT_LOCK(x) init_recursive_mutex(&(x))
 
 static inline void init_recursive_mutex(pthread_mutex_t *x)
diff -Nur cctools-855-ld64-236.3/libobjc2/opts/Makefile ../cctools-port.bak/cctools/libobjc2/opts/Makefile
--- cctools-855-ld64-236.3/libobjc2/opts/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ ../cctools-port.bak/cctools/libobjc2/opts/Makefile	2014-06-30 02:06:45.583154528 +0800
@@ -0,0 +1,8 @@
+LEVEL = ../../../
+LIBRARYNAME = libGNUObjCRuntime
+LOADABLE_MODULE = 1
+USEDLIBS =
+CPPFLAGS += `llvm-config --version | sed 's/\([0-9]*\).\([0-9]*\).*/-DLLVM_MAJOR=\1 -DLLVM_MINOR=\2/'`
+CPPFLAGS += -Wno-variadic-macros
+
+include $(LEVEL)/Makefile.common
diff -Nur cctools-855-ld64-236.3/libstuff/dylib_roots.c ../cctools-port.bak/cctools/libstuff/dylib_roots.c
--- cctools-855-ld64-236.3/libstuff/dylib_roots.c	2014-06-30 02:37:05.419089477 +0800
+++ ../cctools-port.bak/cctools/libstuff/dylib_roots.c	2014-06-30 02:06:45.584154528 +0800
@@ -32,6 +32,7 @@
 #include <fts.h>
 #endif
 #include <sys/errno.h>
+#include <errno.h>
 #include "stuff/bool.h"
 #include "stuff/SymLoc.h"
 #include "stuff/ofile.h"
diff -Nur cctools-855-ld64-236.3/libstuff/emulated.c ../cctools-port.bak/cctools/libstuff/emulated.c
--- cctools-855-ld64-236.3/libstuff/emulated.c	2014-06-30 02:37:05.675089467 +0800
+++ ../cctools-port.bak/cctools/libstuff/emulated.c	2014-06-30 02:06:45.585154527 +0800
@@ -1,3 +1,4 @@
+#ifndef __APPLE__
 #include <mach/mach.h>
 #include <mach/mach_error.h>
 #include <stdlib.h>
@@ -5,7 +6,7 @@
 #include <unistd.h>
 #include <sys/types.h>
 #include <sys/mman.h>
-#include <sys/attr.h>
+//#include <sys/attr.h>
 #include <errno.h>
 #include <inttypes.h>
 #include <mach/mach_time.h>
@@ -13,11 +14,27 @@
 #include <mach/host_info.h>
 #include <sys/time.h>
 
+#ifdef __FreeBSD__
+#include <sys/sysctl.h>
+#endif
+
 int _NSGetExecutablePath(char *path, unsigned int *size)
 {
+#ifdef __FreeBSD__
+   int mib[4];
+   mib[0] = CTL_KERN;
+   mib[1] = KERN_PROC;
+   mib[2] = KERN_PROC_PATHNAME;
+   mib[3] = -1;
+   size_t cb = *size;
+   if (sysctl(mib, 4, path, &cb, NULL, 0) != 0)
+    return -1;
+   *size = cb;
+   return 0;
+#else
    int bufsize = *size;
    int ret_size;
-   ret_size = readlink("/proc/self/exe", path, bufsize);
+   ret_size = readlink("/proc/self/exe", path, bufsize-1);
    if (ret_size != -1)
    {
         *size = ret_size;
@@ -26,6 +43,7 @@
    }
    else
     return -1;
+#endif
 }
 
 kern_return_t mach_timebase_info( mach_timebase_info_t info) {
@@ -316,3 +334,4 @@
         return(s - src - 1);        /* count does not include NUL */
 }
 
+#endif /* __APPLE__ */
diff -Nur cctools-855-ld64-236.3/libstuff/execute.c ../cctools-port.bak/cctools/libstuff/execute.c
--- cctools-855-ld64-236.3/libstuff/execute.c	2014-06-30 02:37:05.675089467 +0800
+++ ../cctools-port.bak/cctools/libstuff/execute.c	2014-06-30 02:06:45.585154527 +0800
@@ -161,11 +161,19 @@
 	    p = allocate(bufsize);
 	    _NSGetExecutablePath(p, &bufsize);
 	}
-	prefix = realpath(p, resolved_name);
-	p = rindex(prefix, '/');
-	if(p != NULL)
-	    p[1] = '\0';
-
+	if (*p){
+		prefix = realpath(p, resolved_name);
+		if (prefix){
+			p = rindex(prefix, '/');
+			if(p != NULL)
+				p[1] = '\0';
+		} else{
+			goto invalid;
+		}
+	} else{
+		invalid:;
+		prefix = "";
+	}
     //NOTE, here we add a target alias to command str;
 	return(makestr(prefix, PROGRAM_PREFIX, str, NULL));
 }
diff -Nur cctools-855-ld64-236.3/libstuff/lto.c ../cctools-port.bak/cctools/libstuff/lto.c
--- cctools-855-ld64-236.3/libstuff/lto.c	2014-06-30 02:37:05.676089467 +0800
+++ ../cctools-port.bak/cctools/libstuff/lto.c	2014-06-30 02:06:45.584154528 +0800
@@ -26,6 +26,79 @@
 static lto_symbol_attributes (*lto_get_sym_attr)(void *mod, uint32_t n) = NULL;
 static char * (*lto_get_sym_name)(void *mod, uint32_t n) = NULL;
 
+#ifndef __APPLE__
+static char *liblto_dirs[] = {
+    "/usr/lib/llvm/lib",
+    "/usr/lib/llvm-3.5/lib",
+    "/usr/lib/llvm-3.4/lib",
+    "/usr/lib/llvm-3.3/lib",
+    "/usr/lib/llvm-3.2/lib",
+    "/usr/lib",
+    NULL
+};
+
+static void *load_liblto()
+{
+    /*
+     * Try to load it normally first,
+     * maybe libLTO.so is even in a known place.
+     */
+
+    void *h = dlopen("libLTO.so", RTLD_NOW);
+    char *p, *path;
+    int i;
+
+    if(h)
+        return h;
+
+    /*
+     * Now try the hardcoded paths from above.
+     */
+
+    for(i = 0; liblto_dirs[i] != NULL; i++){
+        char liblto[MAXPATHLEN];
+        snprintf(liblto, sizeof(liblto), "%s/libLTO.so", liblto_dirs);
+
+        if((h = dlopen(liblto, RTLD_NOW)))
+            return h;
+    }
+
+    /*
+     * Locate the path of the clang binary and try to load
+     * <clangpath>/../lib/libLTO.so.
+     */
+
+    path = getenv("PATH");
+
+    if(!path) return NULL;
+    path = strdup(path);
+    if(!path) return NULL;
+
+    p = strtok(path, ":");
+
+    while(p != NULL){
+        char clangbin[MAXPATHLEN];
+        struct stat st;
+        snprintf(clangbin, sizeof(clangbin), "%s/clang", p);
+
+        if(stat(clangbin, &st) == 0 && access(clangbin, F_OK|X_OK) == 0){
+            char liblto[MAXPATHLEN];
+            snprintf(liblto, sizeof(liblto), "%s/../lib/libLTO.so", p);
+
+            if((h = dlopen(liblto, RTLD_NOW))){
+                free(path);
+                return h;
+            }
+        }
+
+        p = strtok(NULL, ":");
+    }
+
+    free(path);
+    return NULL;
+}
+#endif /* ! __APPLE__ */
+
 /*
  * is_llvm_bitcode() is passed an ofile struct pointer and a pointer and size
  * of some part of the ofile.  If it is an llvm bit code it returns 1 and
@@ -106,19 +179,32 @@
 		_NSGetExecutablePath(p, &bufsize);
 	    }
 	    prefix = realpath(p, resolved_name);
-	    p = rindex(prefix, '/');
+	    p = (prefix ? rindex(prefix, '/') : NULL);
 	    if(p != NULL)
 		p[1] = '\0';
-	    lto_path = makestr(prefix, "../lib/libLTO.so", NULL);
+#ifdef __APPLE__
+           lto_path = makestr(prefix, "../lib/libLTO.dylib", NULL);
 
 	    lto_handle = dlopen(lto_path, RTLD_NOW);
 	    if(lto_handle == NULL){
 		free(lto_path);
 		lto_path = NULL;
-		lto_handle = dlopen("/usr/lib/llvm/libLTO.so", RTLD_NOW);
+		lto_handle = dlopen("/Applications/Xcode.app/Contents/"
+				    "Developer/Toolchains/XcodeDefault."
+				    "xctoolchain/usr/lib/libLTO.dylib",
+				    RTLD_NOW);
 	    }
 	    if(lto_handle == NULL)
 		return(0);
+#else
+	    lto_path = NULL;
+	    lto_handle = load_liblto();
+	    if(lto_handle == NULL)
+	    {
+		fprintf(stderr, "cannot find or load libLTO.so\n");
+		return(0);
+	    }
+#endif /* __APPLE__ */
 
 	    lto_is_object = dlsym(lto_handle,
 				  "lto_module_is_object_file_in_memory");
diff -Nur cctools-855-ld64-236.3/man/Makefile ../cctools-port.bak/cctools/man/Makefile
--- cctools-855-ld64-236.3/man/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ ../cctools-port.bak/cctools/man/Makefile	2014-06-30 02:06:45.557154528 +0800
@@ -0,0 +1,79 @@
+ifneq "" "$(wildcard /bin/mkdirs)"
+  MKDIRS = /bin/mkdirs
+else
+  MKDIRS = /bin/mkdir -p
+endif
+
+DYLD_MAN1 = dyld.1
+OS_MAN1 = strings.1 lipo.1
+COMMON_MAN1 = as.1 nm.1 otool.1 ranlib.1 segedit.1 size.1 \
+	      strip.1 libtool.1 cmpdylib.1 pagestuff.1 \
+	      redo_prebinding.1 nmedit.1 install_name_tool.1 \
+	      codesign_allocate.1 ctf_insert.1
+DEAD = gprof.1
+
+DYLD_MAN3 = dyld.3 NSModule.3 NSObjectFileImage.3 dyld_debug.3
+MAN3 = kld.3 arch.3 get_end.3 end.3 getsectbyname.3 \
+       getsectbynamefromheader.3 getsectdata.3 getsectdatafromheader.3 \
+       getsegbyname.3
+
+MAN5 = Mach-O.5 a.out.5 ranlib.5 stab.5
+
+MANL = indr.1 checksyms.1 seg_addr_table.1 check_dylib.1
+
+EFI1 = mtoc.1
+
+DYLD_MANL3 = NSObjectFileImage_priv.3
+MANL3 = libsyminfo.3 redo_prebinding.3
+
+INSTALL_FILES = Makefile $(OS_MAN1) $(COMMON_MAN1) $(MAN3) $(MAN5) $(MANL) \
+		$(MANL3) $(DYLD_MAN1) $(DYLD_MAN3) $(DYLD_MANL3) $(EFI1) notes
+
+MANDIR = /usr/share/man
+LOCMANDIR = /usr/local/man
+EFIMANDIR = /usr/local/efi/share/man
+DSTDIRS_MAN1 = $(DSTROOT)$(MANDIR)/man1
+DSTDIRS = $(DSTROOT)$(MANDIR)/man3 \
+	  $(DSTROOT)$(MANDIR)/man5 $(DSTROOT)$(LOCMANDIR)/man1 \
+	  $(DSTROOT)$(LOCMANDIR)/man3 $(DSTROOT)$(EFIMANDIR)/man1
+
+install_os_tools: $(DSTDIRS_MAN1) $(OS_MAN1)
+	install -c -m 444 $(OS_MAN1) $(DSTROOT)$(MANDIR)/man1
+
+install: $(DSTDIRS) $(DSTDIRS_MAN1) $(COMMON_MAN1) $(MAN3) $(MAN5) $(MANL) \
+	 $(RC_OS) $(MANL3) install_os_tools
+	install -c -m 444 $(COMMON_MAN1) $(DSTROOT)$(MANDIR)/man1
+	if [ $(OLD_DYLD_STUFF) ];					\
+	then								\
+	    install -c -m 444 $(DYLD_MAN1) $(DSTROOT)$(MANDIR)/man1 ;	\
+	fi
+	install -c -m 444 $(MAN3) $(DSTROOT)$(MANDIR)/man3
+	if [ $(OLD_DYLD_STUFF) ];					\
+	then								\
+	    install -c -m 444 $(DYLD_MAN3) $(DSTROOT)$(MANDIR)/man3 ;	\
+	fi
+	install -c -m 444 $(MAN5) $(DSTROOT)$(MANDIR)/man5
+	install -c -m 444 $(MANL) $(DSTROOT)$(LOCMANDIR)/man1
+	install -c -m 444 $(MANL3) $(DSTROOT)$(LOCMANDIR)/man3
+	install -c -m 444 $(EFI1) $(DSTROOT)$(EFIMANDIR)/man1
+	if [ $(OLD_DYLD_STUFF) ];					\
+	then								\
+	    install -c -m 444 $(DYLD_MANL3) $(DSTROOT)$(LOCMANDIR)/man3;\
+	fi
+
+teflon macos:
+
+nextstep:
+
+installsrc:
+	$(MKDIRS) $(SRCROOT)
+	chmod 755 $(SRCROOT)
+	gnutar cf - $(INSTALL_FILES) | (cd $(SRCROOT); gnutar xf -)
+	chmod 444 $(SRCROOT)/*
+
+$(DSTDIRS) $(DSTDIRS_MAN1):
+	$(MKDIRS) $@
+
+clean shlib_clean:
+
+all:
diff -Nur cctools-855-ld64-236.3/misc/libtool.c ../cctools-port.bak/cctools/misc/libtool.c
--- cctools-855-ld64-236.3/misc/libtool.c	2014-06-30 02:37:05.677089467 +0800
+++ ../cctools-port.bak/cctools/misc/libtool.c	2014-06-30 02:06:45.586154527 +0800
@@ -59,6 +59,8 @@
 #include <servers/bootstrap.h>
 #endif
 
+int asprintf(char **strp, const char *fmt, ...); /* port */
+
 /*
  * This is used internally to build the table of contents.
  */
@@ -1365,6 +1367,7 @@
 			    }
 			}
 		    }
+#ifdef LTO_SUPPORT
 		    else if(ofiles[i].arch_type == OFILE_Mach_O ||
 		            ofiles[i].arch_type == OFILE_LLVM_BITCODE){
 			if(cmd_flags.ranlib == TRUE){
@@ -1376,6 +1379,7 @@
 			else
 			    add_member(ofiles + i);
 		    }
+#endif /* LTO_SUPPORT */
 		    else if(ofiles[i].arch_type == OFILE_UNKNOWN){
 			if(cmd_flags.ranlib == TRUE){
 			    error("for architecture: %s file: %s is not an "
diff -Nur cctools-855-ld64-236.3/otool/arm64_disasm.h ../cctools-port.bak/cctools/otool/arm64_disasm.h
--- cctools-855-ld64-236.3/otool/arm64_disasm.h	2014-06-30 02:37:05.579089471 +0800
+++ ../cctools-port.bak/cctools/otool/arm64_disasm.h	2014-06-30 02:06:45.558154528 +0800
@@ -1,7 +1,7 @@
-#include <stuff/bytesex.h>
-#include <mach-o/reloc.h>
-#include <mach-o/nlist.h>
-#include <stuff/bool.h>
+#import <stuff/bytesex.h>
+#import <mach-o/reloc.h>
+#import <mach-o/nlist.h>
+#import <stuff/bool.h>
 #include "stuff/symbol.h"
 #include "llvm-c/Disassembler.h"
 
diff -Nur cctools-855-ld64-236.3/otool/Makefile.am ../cctools-port.bak/cctools/otool/Makefile.am
--- cctools-855-ld64-236.3/otool/Makefile.am	2014-06-30 01:52:29.000000000 +0800
+++ ../cctools-port.bak/cctools/otool/Makefile.am	2014-06-30 02:06:45.558154528 +0800
@@ -4,9 +4,9 @@
 		$(top_srcdir)/libobjc2/libobjc.la \
 		$(DL_LIBS) 
 
-otool_LDFLAGS = $(PTHREAD_FLAGS) $(CXXABI_LIB) 
+otool_LDFLAGS = $(PTHREAD_FLAGS) $(CXXABI_LIB)
 
-otool_CFLAGS = -I$(top_srcdir)/include -I$(top_srcdir)/include/foreign -I$(top_srcdir)/libstuff -I$(top_srcdir)/libobjc2 $(WARNINGS) $(LTO_DEFS)  -D_DARWIN_C_SOURCE -D__DARWIN_UNIX03 $(ENDIAN_FLAG) -DOTOOL
+otool_CFLAGS = -I$(top_srcdir)/include -I$(top_srcdir)/include/foreign -I$(top_srcdir)/libstuff -I$(top_srcdir)/libobjc2 $(WARNINGS) $(LTO_DEFS) -D_DARWIN_C_SOURCE -D__DARWIN_UNIX03 $(ENDIAN_FLAG) -DOTOOL
 
 otool_SOURCES =  \
 	main.c \
@@ -20,9 +20,8 @@
 	hppa_disasm.c \
 	sparc_disasm.c \
 	arm_disasm.c \
-  	arm64_disasm.c \
-	dyld_bind_info.c \
 	print_objc.c \
 	print_objc2_32bit.c \
-	print_objc2_64bit.c
-
+	print_objc2_64bit.c \
+	arm64_disasm.c \
+	dyld_bind_info.c
diff -Nur cctools-855-ld64-236.3/otool/otool.h ../cctools-port.bak/cctools/otool/otool.h
--- cctools-855-ld64-236.3/otool/otool.h	2014-06-30 02:37:05.580089471 +0800
+++ ../cctools-port.bak/cctools/otool/otool.h	2014-06-30 02:06:45.559154528 +0800
@@ -61,7 +61,7 @@
 extern enum bool qflag; /* use 'C' Public llvm-mc disassembler */
 extern enum bool gflag; /* group the disassembly */
 extern enum bool jflag; /* print opcode bytes */
-extern char *pflag; 	/* procedure name to start disassembling from */
+extern char *pflag;     /* procedure name to start disassembling from */
 extern char *segname,
      *sectname;	    /* name of the section to print the contents of */
 extern char *mcpu; 	/* the arg of the -mcpu=arg flag */
